<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>飞猫</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blueskyadd.github.io/"/>
  <updated>2022-08-03T06:04:22.167Z</updated>
  <id>https://blueskyadd.github.io/</id>
  
  <author>
    <name>火星上的飞猫</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浏览器渲染流程</title>
    <link href="https://blueskyadd.github.io/2022/07/24/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/"/>
    <id>https://blueskyadd.github.io/2022/07/24/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/</id>
    <published>2022-07-24T05:56:57.000Z</published>
    <updated>2022-08-03T06:04:22.167Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>由于渲染机制过于复杂，所以渲染模块在执行过程中会被划分为很多子阶段，输入的 HTML 经过这些子阶段，最后输出像素。我们把这样的一个处理流程叫做<strong>渲染流水线</strong>，其大致流程如下图所示：</p></blockquote><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e4dec4981454b03a90f1e44e0d1261e~tplv-k3u1fbpfcp-watermark.image?" alt="Image.png"></p><p>🐼按照渲染的<strong>时间顺序</strong>，流水线可分为如下几个子阶段：</p><ol><li>构建 DOM 树</li><li>样式计算</li><li>布局阶段</li><li>分层</li><li>绘制</li><li>分块</li><li>光栅化</li><li>合成。</li></ol><p>我们可以把渲染流水线当作一个车间流水线，我们只关注输入输出，中间的处理当作黑盒即可；不去关注过程<br><span id="more"></span></p><h2 id="构建-DOM-树"><a href="#构建-DOM-树" class="headerlink" title="构建 DOM 树"></a>构建 DOM 树</h2><blockquote><p>由于浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM 树。</p></blockquote><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21c2d0c01453424fb93d06b0ea792559~tplv-k3u1fbpfcp-watermark.image?" alt="Image [2].png"></p><blockquote><p><strong>HTML解析器</strong>：接收到HTML字节流时，首先要经过渲染引擎的HTML解析器，将HTML字节流转换成DOM树结构。</p></blockquote><p>构建 DOM 树的输入内容是一个非常简单的 HTML 文件，然后经由 <strong>HTML 解析器解析</strong>，最终输出树状结构的 DOM。</p><p>可以看到，DOM 和 HTML 内容几乎是一样的，但是和 HTML 不同的是，DOM 是保存在内存中树状结构，可以通过 JavaScript 来查询或修改其内容。</p><h2 id="样式计算（Recalculate-Style）"><a href="#样式计算（Recalculate-Style）" class="headerlink" title="样式计算（Recalculate Style）"></a>样式计算（Recalculate Style）</h2><p>已经生成 DOM 树了，但是 DOM 节点的样式我们依然不知道，要让 DOM 节点拥有正确的样式，这就需要样式计算了。</p><p>样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式，这个阶段大体可分为三步来完成。</p><h4 id="1-把-CSS-转换为浏览器能够理解的结构"><a href="#1-把-CSS-转换为浏览器能够理解的结构" class="headerlink" title="1. 把 CSS 转换为浏览器能够理解的结构"></a>1. 把 CSS 转换为浏览器能够理解的结构</h4><p>和 HTML 文件一样，浏览器也是无法直接理解这些纯文本的 CSS 样式，所以当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——<strong>styleSheets</strong>。</p><p>在控制台中输入 <code>document.styleSheets</code>，然后就看到如下图所示的结构：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72a86d84b7634b059384594927fdf4f4~tplv-k3u1fbpfcp-watermark.image?" alt="Image [3].png"></p><p>渲染引擎会把获取到的 CSS 文本全部转换为 <strong>styleSheets 结构</strong>中的数据，并且该结构同时具备了<strong>查询</strong>和<strong>修改</strong>功能，这会为后面的样式操作提供基础。</p><h4 id="2-转换样式表中的属性值，使其标准化"><a href="#2-转换样式表中的属性值，使其标准化" class="headerlink" title="2. 转换样式表中的属性值，使其标准化"></a>2. 转换样式表中的属性值，使其标准化</h4><blockquote><p>将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5501d9086a6498eb74f0589fd0d2813~tplv-k3u1fbpfcp-watermark.image?" alt="Image [4].png"></p><h4 id="3-计算出-DOM-树中每个节点的具体样式"><a href="#3-计算出-DOM-树中每个节点的具体样式" class="headerlink" title="3. 计算出 DOM 树中每个节点的具体样式"></a>3. 计算出 DOM 树中每个节点的具体样式</h4><p>样式计算阶段的目的是为了计算出 DOM 节点中每个元素的具体样式，在计算过程中需要遵守 <strong>CSS 的继承</strong>和<strong>层叠</strong>两个规则。这个阶段最终输出的内容是每个 DOM 节点的样式，并被保存在 ComputedStyle 的结构内</p><p>📚<strong>CSS 继承</strong></p><p>CSS 继承就是每个 DOM 节点都包含有父节点的样式。</p><p>📒<strong>层叠</strong></p><p>层叠是 CSS 的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法。它在 CSS 处于核心地位，CSS 的全称“层叠样式表”正是强调了这一点</p><h2 id="布局阶段"><a href="#布局阶段" class="headerlink" title="布局阶段"></a>布局阶段</h2><p>因为我们还不知道 DOM 元素的几何位置信息。那么接下来就需要计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做<strong>布局</strong>。</p><p>Chrome 在布局阶段需要完成两个任务：<strong>创建布局树</strong>和<strong>布局计算</strong>。</p><h4 id="1-创建布局树"><a href="#1-创建布局树" class="headerlink" title="1. 创建布局树"></a>1. 创建布局树</h4><ul><li>遍历 DOM 树中的所有可见节点，并把这些节点加到布局树中；</li><li>而不可见的节点会被布局树忽略掉，因为它的属性包含 dispaly:none，所以这个元素也没有被包进布局树。</li></ul><h4 id="2-布局计算"><a href="#2-布局计算" class="headerlink" title="2. 布局计算"></a>2. 布局计算</h4><p>当Webkit创建RenderObject对象之后，每个对象是不知道自己的位置，大小等信息的，WebKit根据盒子模型来计算他的位置，大小等信息，这个过程就是<strong>布局计算</strong></p><p>布局计算是一个复杂的过程，我简单的可以总结为：界面是由很多很多的框模型组成的，每个框模型是由元素的类型以及display属性决定的。而不同的Box会参与到不同的格式上下文中(Formatting Context)，完成布局的计算。</p><h2 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h2><p>页面是个二维平面，但是层叠上下文能够让 HTML 元素具有三维概念，这些 HTML 元素按照自身属性的优先级分布在垂直于这个二维平面的 z 轴上。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4c6a00bea454ab88e02e3195cc57fff~tplv-k3u1fbpfcp-watermark.image?" alt="Image [5].png"></p><p>页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-inde 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f8f8516913f646c3a4380b3fc9a7d61d~tplv-k3u1fbpfcp-watermark.image?" alt="Image [6].png"></p><h2 id="图层绘制"><a href="#图层绘制" class="headerlink" title="图层绘制"></a>图层绘制</h2><p>在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制；</p><p>渲染引擎实现图层的绘制与之类似，会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表，如下图所示</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb75467d10e042b49c7478709596e275~tplv-k3u1fbpfcp-watermark.image?" alt="Image [7].png"></p><h2 id="栅格化（raster）操作"><a href="#栅格化（raster）操作" class="headerlink" title="栅格化（raster）操作"></a>栅格化（raster）操作</h2><p>绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b093daacba144578bb4b131de8c6e99d~tplv-k3u1fbpfcp-watermark.image?" alt="Image [8].png"></p><h2 id="合成和显示"><a href="#合成和显示" class="headerlink" title="合成和显示"></a>合成和显示</h2><p>一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9cabb69df754377b7fdca1fce2b767c~tplv-k3u1fbpfcp-watermark.image?" alt="Image [9].png"></p><ol><li>渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。</li><li>渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。</li><li>创建布局树，并计算元素的布局信息。</li><li>对布局树进行分层，并生成分层树。</li><li>为每个图层生成绘制列表，并将其提交到合成线程。</li><li>合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。</li><li>合成线程发送绘制图块命令 DrawQuad 给浏览器进程。</li><li>浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;由于渲染机制过于复杂，所以渲染模块在执行过程中会被划分为很多子阶段，输入的 HTML 经过这些子阶段，最后输出像素。我们把这样的一个处理流程叫做&lt;strong&gt;渲染流水线&lt;/strong&gt;，其大致流程如下图所示：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e4dec4981454b03a90f1e44e0d1261e~tplv-k3u1fbpfcp-watermark.image?&quot; alt=&quot;Image.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;🐼按照渲染的&lt;strong&gt;时间顺序&lt;/strong&gt;，流水线可分为如下几个子阶段：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;构建 DOM 树&lt;/li&gt;
&lt;li&gt;样式计算&lt;/li&gt;
&lt;li&gt;布局阶段&lt;/li&gt;
&lt;li&gt;分层&lt;/li&gt;
&lt;li&gt;绘制&lt;/li&gt;
&lt;li&gt;分块&lt;/li&gt;
&lt;li&gt;光栅化&lt;/li&gt;
&lt;li&gt;合成。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们可以把渲染流水线当作一个车间流水线，我们只关注输入输出，中间的处理当作黑盒即可；不去关注过程&lt;br&gt;
    
    </summary>
    
    
    
      <category term="浏览器工作原理" scheme="https://blueskyadd.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>数据包是如何完整的发送到应用程序</title>
    <link href="https://blueskyadd.github.io/2022/05/26/%E6%95%B0%E6%8D%AE%E5%8C%85%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%8C%E6%95%B4%E7%9A%84%E5%8F%91%E9%80%81%E5%88%B0%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"/>
    <id>https://blueskyadd.github.io/2022/05/26/%E6%95%B0%E6%8D%AE%E5%8C%85%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%8C%E6%95%B4%E7%9A%84%E5%8F%91%E9%80%81%E5%88%B0%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/</id>
    <published>2022-05-26T05:54:51.000Z</published>
    <updated>2022-08-03T05:56:12.387Z</updated>
    
    <content type="html"><![CDATA[<h2 id="把数据包送达目的主机"><a href="#把数据包送达目的主机" class="headerlink" title="把数据包送达目的主机"></a>把数据包送达目的主机</h2><blockquote><p>数据包要在互联网上进行传输，就要符合网际协议（Internet Protocol，简称 IP）标准。<strong>计算机的地址就称为 IP 地址</strong>，访问任何网站实际上只是你的计算机向另外一台计算机请求信息。互联网上不同的在线设备都有唯一的地址，相当于我们的身份证号，有且仅有一个。</p></blockquote><p>如果要想把一个数据包从主机 A 发送给主机 B，那么需要携带一下信息：</p><ul><li>主机 B 的 IP 地址信息</li><li>主机 A 本身的 IP 地址</li></ul><span id="more"></span><p>这些附加的信息会被装进一个叫 IP 头的数据结构里。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/279971bb5117492fa5a6ebb7d16992e1~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><h2 id="把数据包送达应用程序"><a href="#把数据包送达应用程序" class="headerlink" title="把数据包送达应用程序"></a>把数据包送达应用程序</h2><p>IP 是非常底层的协议，只负责把数据包传送到对方电脑，但是对方电脑并不知道把数据包交给哪个程序。那么就需要基于 IP 之上开发能和应用打交道的协议，比如 <strong>UDP（User Datagram Protocol 用户数据包协议）</strong>，或者<strong>TCP（Transmission Control Protocol，传输控制协议</strong>。</p><p>他们都需要一个头部信息，头部信息中包含了目标端口和本机端口号，不同的是TCP协议的头部信息中还提供了用于排序的序列号，以便接收端通过序号来重排数据包。</p><h4 id="TCP协议的特点"><a href="#TCP协议的特点" class="headerlink" title="TCP协议的特点"></a>TCP协议的特点</h4><ul><li>TCP 是面向连接的运输层协议。应用程序在使用 TCP 协议之前，必须先建立 TCP 连接。在传送数据完毕后，必须释放已经建立的 TCP 连接</li><li>每一条 TCP 连接只能有两个端点，每一条 TCP 连接只能是点对点的(一对一)<br>TCP 提供可靠交付的服务。通过 TCP 连接传送的数据，无差错、不丢失、不重复，并且按序到达-  - TCP 提供全双工通信。TCP 允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端都设有发送缓存和接受缓存，用来临时存放双向通信的数据</li><li>面向字节流。TCP 中的“流”指的是流入到进程或从进程流出的字节序列</li></ul><blockquote><p>一个完整的 TCP 连接的生命周期包括了“建立连接”“传输数据”和“断开连接”三个阶段。</p></blockquote><p>第一次：客户端给服务端发送一个带有SYN标志的数据包<br>第二次：服务端给客户端发送带有SYN和ACK标志得数据包<br>第三次：客户端给服务端发送带有ACK标志的数据包</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73b6384838d8491fb069b0b0275bf512~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><h5 id="UDP协议的特点"><a href="#UDP协议的特点" class="headerlink" title="UDP协议的特点"></a>UDP协议的特点</h5><ul><li><p>UDP是无连接的，即通信时不需要创建连接（发送数据结束时也没有连接可以释放）所以减小了开销和发送数据前的时延；</p><ul><li>UDP采用最大努力交付，不保证可靠交付，因此主机不需要维护复杂的连接状态；</li></ul></li><li><p>UDP是面向报文的，只在应用层交下来的报文前增加了首部后就向下交付IP层；</p></li><li><p>UDP是无阻塞控制的，即使网络中存在阻塞，也不会影响发送端的发送频率</p></li><li><p>UDP支持一对一、一对多、多对一、多对多的交互通信</p></li><li><p>DUP的首部开销小，只有8个字节，它比TCP的20个字节的首部要短。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>互联网中的数据是通过数据包来传输的，数据包在传输过程中容易丢失或出错。</li><li>IP 负责把数据包送达目的主机。</li><li>UDP 负责把数据包送达具体应用。</li><li>而 TCP 保证了数据完整地传输，它的连接可分为三个阶段：建立连接、传输数据和断开连接。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;把数据包送达目的主机&quot;&gt;&lt;a href=&quot;#把数据包送达目的主机&quot; class=&quot;headerlink&quot; title=&quot;把数据包送达目的主机&quot;&gt;&lt;/a&gt;把数据包送达目的主机&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;数据包要在互联网上进行传输，就要符合网际协议（Internet Protocol，简称 IP）标准。&lt;strong&gt;计算机的地址就称为 IP 地址&lt;/strong&gt;，访问任何网站实际上只是你的计算机向另外一台计算机请求信息。互联网上不同的在线设备都有唯一的地址，相当于我们的身份证号，有且仅有一个。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果要想把一个数据包从主机 A 发送给主机 B，那么需要携带一下信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主机 B 的 IP 地址信息&lt;/li&gt;
&lt;li&gt;主机 A 本身的 IP 地址&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="浏览器工作原理" scheme="https://blueskyadd.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>浏览器的进程和线程</title>
    <link href="https://blueskyadd.github.io/2022/05/09/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/"/>
    <id>https://blueskyadd.github.io/2022/05/09/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/</id>
    <published>2022-05-09T05:52:24.000Z</published>
    <updated>2022-08-03T05:54:28.086Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是并行处理"><a href="#什么是并行处理" class="headerlink" title="什么是并行处理"></a>什么是并行处理</h2><p>在了解进程和线程之前，先来看一下什么是并行处理；</p><p>计算机中的并行处理就是同一时刻处理多个任务，比如我们要计算下面这两个表达式的值，并显示出结果<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="number">1</span>+<span class="number">2</span></span><br><span class="line">B = <span class="number">2</span>+<span class="number">3</span></span><br></pre></td></tr></table></figure></p><p>在编写代码的时候，我们可以把这个过程拆分为三个任务：</p><ul><li>任务 1 是计算 A=1+2；</li><li>任务 2 是计算 B=2+3；</li><li>任务 3 是显示最后计算的结果;</li></ul><span id="more"></span><p>正常情况下，可以使用<strong>单线程</strong>来处理，也就是说分三步按照顺序分别执行;</p><p>如果采用<strong>多线程</strong>，会怎么样呢？我们只需分“两步走”：</p><ul><li>第一步，使用两个个线程同时执行前两个任务；</li><li>第二步，再执行第四个显示任务。</li></ul><p>通过对比分析，你会发现用单线程执行需要四步，而使用多线程只需要两步。因此，使用<strong>并行处理能大大提升性能</strong>。</p><h2 id="进程-vs-线程"><a href="#进程-vs-线程" class="headerlink" title="进程 vs 线程"></a>进程 vs 线程</h2><blockquote><p>多线程可以并行处理任务，但是线程是不能单独存在的，它是由进程来启动和管理的</p></blockquote><p>在很多地方我们都有看到一句话： <strong>进程是CPU分配资源的最小单位，线程是CPU调度的最小单位。</strong></p><p>那么如何理解这句话，如果把进程比作一个工厂，那么线程就像工厂中的员工，工厂与工厂之间相互独立，工厂中的员工相互协作完成任务，每个工厂至少都有一个员工，员工之间共享工厂的仓库。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60c48839f0d040adbb927518c7c5970f~tplv-k3u1fbpfcp-watermark.image?" alt="Image.png"></p><h3 id="进程和线程有以下四种关系"><a href="#进程和线程有以下四种关系" class="headerlink" title="进程和线程有以下四种关系"></a>进程和线程有以下四种关系</h3><h4 id="1-进程中的任意一线程执行出错，都会导致整个进程的崩溃。"><a href="#1-进程中的任意一线程执行出错，都会导致整个进程的崩溃。" class="headerlink" title="1.  进程中的任意一线程执行出错，都会导致整个进程的崩溃。"></a>1.  进程中的任意一线程执行出错，都会导致整个进程的崩溃。</h4><p>所以js（线程）执行报错时导致整个渲染进程停止工作，比如一个工人（线程）在流水线生产产品时由于操作失误，导致机器故障，那就会导致工厂（进程）停产。</p><p>也可以模拟以下场景：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="number">1</span>+<span class="number">2</span></span><br><span class="line">B = <span class="number">20</span>/<span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>当线程执行到 B = 20/0 时，由于分母为 0，线程会执行出错，这样就会导致整个进程的崩溃，当然另外线程执行的结果也没有了</p><h4 id="2-线程之间共享进程中的数据。"><a href="#2-线程之间共享进程中的数据。" class="headerlink" title="2. 线程之间共享进程中的数据。"></a>2. 线程之间共享进程中的数据。</h4><p>如上图所示，工人之间是共享工厂的仓库的，线程之间可以对进程的公共数据进行读写操作。</p><h4 id="3-当一个进程关闭之后，操作系统会回收进程所占用的内存。"><a href="#3-当一个进程关闭之后，操作系统会回收进程所占用的内存。" class="headerlink" title="3.  当一个进程关闭之后，操作系统会回收进程所占用的内存。"></a>3.  当一个进程关闭之后，操作系统会回收进程所占用的内存。</h4><p>当一个进程退出时，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。</p><p>如果工厂关闭，工厂内的所有资源都会被回收。</p><h4 id="4-进程之间的内容相互隔离。"><a href="#4-进程之间的内容相互隔离。" class="headerlink" title="4. 进程之间的内容相互隔离。"></a>4. 进程之间的内容相互隔离。</h4><p>进程隔离是为保护操作系统中进程互不干扰的技术，每一个进程只能访问自己占有的数据，也就避免出现进程 A 写入数据到进程 B 的情况。如果进程之间需要通信，就需要用到进程之间相互通信的机制了。</p><p>比如Electron桌面应用中内部得也是chromium的内核，有两个进程，分别是Main主进程和Renderer渲染进程，两者的通信也是需要用到IPC (inter-process communication)</p><p>工厂与工厂之间相互独立，资源不共享。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是并行处理&quot;&gt;&lt;a href=&quot;#什么是并行处理&quot; class=&quot;headerlink&quot; title=&quot;什么是并行处理&quot;&gt;&lt;/a&gt;什么是并行处理&lt;/h2&gt;&lt;p&gt;在了解进程和线程之前，先来看一下什么是并行处理；&lt;/p&gt;
&lt;p&gt;计算机中的并行处理就是同一时刻处理多个任务，比如我们要计算下面这两个表达式的值，并显示出结果&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;A = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;+&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;B = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;+&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在编写代码的时候，我们可以把这个过程拆分为三个任务：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;任务 1 是计算 A=1+2；&lt;/li&gt;
&lt;li&gt;任务 2 是计算 B=2+3；&lt;/li&gt;
&lt;li&gt;任务 3 是显示最后计算的结果;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="浏览器工作原理" scheme="https://blueskyadd.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>重定向与负载均衡</title>
    <link href="https://blueskyadd.github.io/2022/04/19/%E9%87%8D%E5%AE%9A%E5%90%91%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>https://blueskyadd.github.io/2022/04/19/%E9%87%8D%E5%AE%9A%E5%90%91%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</id>
    <published>2022-04-19T05:50:56.000Z</published>
    <updated>2022-08-03T05:52:00.514Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、什么是重定向"><a href="#1、什么是重定向" class="headerlink" title="1、什么是重定向"></a>1、什么是重定向</h2><blockquote><p>重定向技术通常可以用来确定报文是否终结于某个代理，缓存或服务器集群中某台特定的服务器.                                                                                   —— HTTP权威指南</p></blockquote><p>感觉很绕口，举个栗子🌰🙋‍简单理解起来相当于你拿着一个地址从家里出发（浏览器发送请求）去找一个亲戚，到了后发现他已经搬家了，邻居告诉了你一个新的地址（新的请求），此时天已经晚了，你回家休息一晚上（又回到了浏览器），第二天拿着新的地址去找（浏览器再次发送请求），终于找到了。</p><span id="more"></span><p>整个过程，家可以看成浏览器，两个不同的地址可以看成两次不同的request，两个地址都是从家里开始出发，相当于浏览器发送两次不同的请求,先找到旧url，没找到，再回到浏览器去找新url，最终跳转到新的url上，这就是url发生改变的原因。</p><p>带入到 HTTP 中，服务器可以通过返回一个重定向响应来进行重定向。这个重定向响应有一个以 <strong>3</strong> 开头的状态码 ，并且有一个 <code>Location</code> 头字段 表示要重定向到的位置。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f5d37443e3e49a3ad07016223088977~tplv-k3u1fbpfcp-watermark.image?" alt="Image.png"></p><h2 id="2、为什么要重定向"><a href="#2、为什么要重定向" class="headerlink" title="2、为什么要重定向"></a>2、为什么要重定向</h2><p>由于HTTP应用程序总是要做下列3件事情，所以现代网络中重定向时普遍存在的</p><ul><li>可靠的执行HTTP事务</li><li>最小化时延</li><li>节约网络带宽</li></ul><p>出于这些原因，Web内容通常分布在很多地方。这样做是出于可靠性的考虑：</p><ul><li>如果一个位置出问题了，还有其他的可用；</li><li>如果客户端能去访问较近的资源，就可以更快的收到所请求的内容，以降低响应时间</li><li>将目标服务器分散，还可以减少网络拥塞</li></ul><p>可以将重定向当作一组有助于找到“最佳”分布式内容的技术。</p><h2 id="3、通用的重定向方法"><a href="#3、通用的重定向方法" class="headerlink" title="3、通用的重定向方法"></a>3、通用的重定向方法</h2><h3 id="http重定向"><a href="#http重定向" class="headerlink" title="http重定向"></a>http重定向</h3><p>web服务器可以将短的重定向报文发回给客户端，与其他形式相比，http重定向的优点之一就是重定向服务器知道客户端的IP地址，从理论上来讲他可以做出更合理的选择；</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76dd605283814e0f979c21b05dce5b3d~tplv-k3u1fbpfcp-watermark.image?" alt="Image [2].png"></p><h4 id="http重定向的局限"><a href="#http重定向的局限" class="headerlink" title="http重定向的局限"></a>http重定向的局限</h4><ul><li>需要原始服务器进行大量处理来判断要重定向到哪条服务器上去。有时，发布重定向所需的处理量几乎与提供页面本身所需的处理量一样。</li><li>增加了用户时延，因为访问页面时要进行两次往返</li><li>如果重定向服务器出故障，站点就会瘫痪。</li></ul><h3 id="DNS重定向"><a href="#DNS重定向" class="headerlink" title="DNS重定向"></a>DNS重定向</h3><p>DNS重定向，有时称为DNS劫持，是从DNS服务器转移结果的做法。下图中，DNS服务器要决定为<a href="http://www.joes.hardware.com返回4个IP地址中的哪一个；">www.joes.hardware.com返回4个IP地址中的哪一个；</a></p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bcc20337df2342919d1ddf7695efa50b~tplv-k3u1fbpfcp-watermark.image?" alt="Image [3].png"></p><p>其中DNS服务器决定要选择使用那个IP，最简单的决策算法就是<strong>轮转</strong>。DNS轮转使用了DNS主机名解析中的一项特性，在Web服务器集群中平衡负载。</p><h4 id="DNS重定向算法："><a href="#DNS重定向算法：" class="headerlink" title="DNS重定向算法："></a>DNS重定向算法：</h4><ul><li>轮转</li><li>负载均衡算法</li><li>邻接路由算法</li><li>故障屏蔽算法</li></ul><h3 id="任播寻址"><a href="#任播寻址" class="headerlink" title="任播寻址"></a>任播寻址</h3><p>几台服务器使用相同的IP地址。每台服务器都会伪装成一个骨干路由器。其他路由器会将共享的IP地址分组发送给最近的服务器。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/602539c9aacd4878acc6db5dc8726bf5~tplv-k3u1fbpfcp-watermark.image?" alt="Image [4].png"></p><h4 id="任播寻址的局限"><a href="#任播寻址的局限" class="headerlink" title="任播寻址的局限"></a>任播寻址的局限</h4><ul><li>需要拥有/配置路由器</li><li>有地址冲突的风险，如果路由变化了，与已建立的TCP连接相关的分组会被发送到其他的服务区，可能会使Tcp连接中断</li></ul><h3 id="IP-MAC-转发"><a href="#IP-MAC-转发" class="headerlink" title="IP/MAC 转发"></a>IP/MAC 转发</h3><p>在以太网中，HTTP 报文都是以携带地址的数据分组的形式发送的。每个分组都有一个第四层地址，由源 IP 地址、目的 IP 地址以及 TCP 端口号组成，它是第四层设备所关注的地址。</p><p>每个分组还有一个第二层地址，MAC(Media Access Control，媒体访问控制)地址，这是第二层设备(通常是交换机和 Hub)所关注的地址。第二层设备的任务是接收具有特定输入 MAC 地址的分组，然后将其转发到特定的输出 MAC 地址上去。</p><h3 id="IP-地址转发"><a href="#IP-地址转发" class="headerlink" title="IP 地址转发"></a>IP 地址转发</h3><p>在 IP 地址转发中，交换机或其他第四层设备会检测输入分组中的 TCP/IP 地址，并通过修改目的 IP 地址(不是目的 MAC 地址)，对分组进行相应的转发。</p><p>与 MAC 转 发相比，这么做的优点是目标服务器不需要位于一跳远的地方；只需要位于交换机的上游就行了，而且通常第三层的端到端因特网路由都会将分组传送到正确的地方。这种类型的转发也被称为 NAT(Network Address Translation，网络地址转换)。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd24dd3afa074c68b9cdbee71d8f18e7~tplv-k3u1fbpfcp-watermark.image?" alt="Image [13].png"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1、什么是重定向&quot;&gt;&lt;a href=&quot;#1、什么是重定向&quot; class=&quot;headerlink&quot; title=&quot;1、什么是重定向&quot;&gt;&lt;/a&gt;1、什么是重定向&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;重定向技术通常可以用来确定报文是否终结于某个代理，缓存或服务器集群中某台特定的服务器.                                                                                   —— HTTP权威指南&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;感觉很绕口，举个栗子🌰🙋‍简单理解起来相当于你拿着一个地址从家里出发（浏览器发送请求）去找一个亲戚，到了后发现他已经搬家了，邻居告诉了你一个新的地址（新的请求），此时天已经晚了，你回家休息一晚上（又回到了浏览器），第二天拿着新的地址去找（浏览器再次发送请求），终于找到了。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="网络" scheme="https://blueskyadd.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>jwt鉴权机制</title>
    <link href="https://blueskyadd.github.io/2022/03/27/jwt%E9%89%B4%E6%9D%83%E6%9C%BA%E5%88%B6/"/>
    <id>https://blueskyadd.github.io/2022/03/27/jwt%E9%89%B4%E6%9D%83%E6%9C%BA%E5%88%B6/</id>
    <published>2022-03-27T05:48:31.000Z</published>
    <updated>2022-08-03T05:50:30.280Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、摘要"><a href="#1、摘要" class="headerlink" title="1、摘要"></a>1、摘要</h2><blockquote><p>JSON Web Token（缩写 JWT）是目前最流行的跨域认证解决方案，本质就是一个字符串书写规范，作用是用来在用户和服务器之间传递安全可靠的信息。</p></blockquote><h2 id="2-JWT是什么"><a href="#2-JWT是什么" class="headerlink" title="2. JWT是什么"></a>2. JWT是什么</h2><p>根据维基百科的定义，JSON WEB Token（JWT，读作 [/dʒɒt/]），是一种基于JSON的、用于在网络上声明某种主张的令牌（token）。JWT通常由三部分组成: 头信息（header）, 消息体（payload）和签名（signature）。</p><span id="more"></span><p>在目前前后端分离的开发过程中，使用token鉴权机制用于身份验证是最常见的方案，流程如下</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7bc95b7fab854121900bfa9db432d1c3~tplv-k3u1fbpfcp-watermark.image?" alt="Image.png"></p><ol><li>假设用户要登录一个APP，用户就需要输入用户名和密码，然后发送给APP的服务器</li><li>服务器验证过用户发来的用户名和密码后，就会生成一个token，</li><li>服务端返回JWT信息给用户，JWT中</li><li>用户发送请求的时候一般会在HTTP头部加上这个Token</li><li>服务器收到Token后，对Token进行核实，Token验证通过，且没有过期</li><li>用户直接登录，不需要再次输入用户名密码，服务器只需识别头部的Token就可以确认用户身份</li></ol><p>这里生成的Token就用的JWT这种数据结构</p><p>✒️Token的携带<br>token可以放在Cookie，Authorization，或者Body里面</p><h4 id="什么情况下使用JWT比较适合？"><a href="#什么情况下使用JWT比较适合？" class="headerlink" title="什么情况下使用JWT比较适合？"></a>什么情况下使用JWT比较适合？</h4><h2 id="3-JWT-的数据结构"><a href="#3-JWT-的数据结构" class="headerlink" title="3. JWT 的数据结构"></a>3. JWT 的数据结构</h2><p>Token，分成了三部分，头部（Header）、载荷（Payload）、签名（Signature），并以.进行拼接。其中头部和载荷都是以JSON格式存放数据，只是进行了base64 编码(secret 部分是否进行 base64 编码是可选的，header 和 payload 则是必须进行 base64 编码)，由于编码过程是可逆的，如果得知编码方式后，那么整个 jwt 串便是明文了，所以pyaload中一定不能放密码等重要信息。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a979f6cbd9e48eda11c79268ad975f4~tplv-k3u1fbpfcp-watermark.image?" alt="Image [2].png"></p><h4 id="header"><a href="#header" class="headerlink" title="header"></a>header</h4><p>头部主要是用来指明签名的算法，避免消息被篡改，jwt 中常用的签名算法是 HS256，常见的还有md5,sha 等，签名算法是不可逆的。声明算法的字段名为alg，同时还有一个typ的字段，默认JWT即可。以下示例中算法为HS256,<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;alg&quot;</span>: HS256, <span class="string">&quot;typ&quot;</span>: <span class="string">&quot;JWT&quot;</span>&#125;</span><br></pre></td></tr></table></figure></p><h4 id="pyaload"><a href="#pyaload" class="headerlink" title="pyaload"></a>pyaload</h4><p>负载主要是用来存放数据，一般可以存放相应用户数据来生成不同的JWT<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  <span class="string">&quot;payload&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;data&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">&quot;tooltt&quot;</span>: <span class="string">&quot;https://tooltt.com&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="string">&quot;iat&quot;</span>: <span class="number">1650451633</span>,</span><br><span class="line">      <span class="string">&quot;exp&quot;</span>: <span class="number">1650556799</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>JWT规定了7个官方字段，供选用</p><ul><li>iss (issuer)：签发人</li><li>exp (expiration time)：过期时间</li><li>sub (subject)：主题</li><li>aud (audience)：受众</li><li>nbf (Not Before)：生效时间</li><li>iat (Issued At)：签发时间</li><li>jti (JWT ID)：编号</li></ul><p>除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">      <span class="string">&quot;sub&quot;</span>: <span class="string">&quot;1234567890&quot;</span>,</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: <span class="string">&quot;John Doe&quot;</span>,</span><br><span class="line">      <span class="string">&quot;admin&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>由于编码的可逆性，不要把秘密信息放在这个部分。</p><h4 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h4><p>签名是对头部和负载两个部分进行签名，防止数据篡改。<br>签名里面有个核心就是要定义一个密钥，这个密钥只有服务器能知道，然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。<br>公式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Signature = HMACSHA256(base64Url(header)+.+base64Url(payload),secretKey)</span><br></pre></td></tr></table></figure><p>一旦前面两部分数据被篡改，只要服务器加密用的密钥没有泄露，得到的签名肯定和之前的签名不一致</p><h2 id="4-鉴权机制时如何实现的"><a href="#4-鉴权机制时如何实现的" class="headerlink" title="4. 鉴权机制时如何实现的"></a>4. 鉴权机制时如何实现的</h2><p>相关代码已上传github  <a href="https://github.com/blueskyadd/JWT">https://github.com/blueskyadd/JWT</a></p><h4 id="基础服务器的搭建"><a href="#基础服务器的搭建" class="headerlink" title="基础服务器的搭建"></a>基础服务器的搭建</h4><p>首先初始化项目<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/141db56c22ed4f3db9642e72fe7fbcaf~tplv-k3u1fbpfcp-watermark.image?" alt="Image [3].png"></p><p>第二步 安装 express jsonwebtoken依赖<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i express jsonwebtoken -D</span><br></pre></td></tr></table></figure></p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/18cdeca3328e46e8a9d279331619372e~tplv-k3u1fbpfcp-watermark.image?" alt="Image [4].png"></p><p>第三步，调整配置文件<br>为了方便我们本地调试代码，安装nodemon</p><p>nodemon用来监视node.js应用程序中的任何更改并自动重启服务,非常适合用在开发环境中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i nodemon -D</span><br></pre></td></tr></table></figure><p>打开pakage.json文件调整scripts，调试命令</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ac7093249444b00916e2be6d10c1cfa~tplv-k3u1fbpfcp-watermark.image?" alt="Image [5].png"></p><p>然后创建app.js文件</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/074aa7bb557f4adcb8a1dd16b6479444~tplv-k3u1fbpfcp-watermark.image?" alt="Image [6].png"></p><p>监听3000端口，运行<code>npm run egg</code>启动服务</p><h4 id="登录生成JWT"><a href="#登录生成JWT" class="headerlink" title="登录生成JWT"></a>登录生成JWT</h4><p>借助第三方库jsonwebtoken，通过jsonwebtoken 的 sign 方法生成一个 token</p><ul><li>第一个参数指的是 Payload</li><li>第二个是秘钥，服务端特有</li><li>第三个参数是 option，可以定义 token 过期时间</li></ul><p>此处的密钥，使用crypto来生成30位的随机字符串</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4687036aa4b54fc6896fece822884735~tplv-k3u1fbpfcp-watermark.image?" alt="Image [7].png"></p><p>然后来尝试调用接口，我这里使用的是<code>REST Client</code> 插件，可以直接安装，<br>然后创建一个以http结尾的文件</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1049037db8842ba9c8ed10c0be35625~tplv-k3u1fbpfcp-watermark.image?" alt="Image [8].png"></p><p>然后点击send Request 发送请求，请求成功后，可以看到返回的信息</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38e43e4a064b4b3cbd899a168f3c7e8a~tplv-k3u1fbpfcp-watermark.image?" alt="Image [9].png"></p><h4 id="校验token"><a href="#校验token" class="headerlink" title="校验token"></a>校验token</h4><p>使用jwt.verify（token，secretOrPublicKey，[options，callback]）来<br>验证token的合法性；</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40d099c0185c4ffa8f8eba7774828301~tplv-k3u1fbpfcp-watermark.image?" alt="Image [10].png"></p><p>同理发送get请求，将登录返回的token, 复制到请求头的authorization字段上，拼接<code>Bearer 空格 token</code>  这是遵守OAuth2.0规则的</p><p>然后点击发送，返回认证成功的信息</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/867ab2272ec647a985581fd92bd5da9f~tplv-k3u1fbpfcp-watermark.image?" alt="Image [11].png"></p><h2 id="5-JWT的优缺点"><a href="#5-JWT的优缺点" class="headerlink" title="5. JWT的优缺点"></a>5. JWT的优缺点</h2><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>json具有通用性，所以可以跨语言组成简单，</li><li>字节占用小，便于传输服务端无需保存会话信息，</li><li>很容易进行水平扩展一处生成，多处使用，</li><li>可以在分布式系统中，</li><li>解决单点登录问题可防护CSRF攻击</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>payload部分仅仅是进行简单编码，所以只能用于存储逻辑必需的非敏感信息</li><li>需要保护好加密密钥，一旦泄露后果不堪设想</li><li>为避免token被劫持，最好使用https协议</li></ul><h2 id="6-推荐阅读"><a href="#6-推荐阅读" class="headerlink" title="6. 推荐阅读"></a>6. 推荐阅读</h2><p><a href="https://www.freebuf.com/vuls/219056.html">JWT介绍及其安全性分析</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1、摘要&quot;&gt;&lt;a href=&quot;#1、摘要&quot; class=&quot;headerlink&quot; title=&quot;1、摘要&quot;&gt;&lt;/a&gt;1、摘要&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;JSON Web Token（缩写 JWT）是目前最流行的跨域认证解决方案，本质就是一个字符串书写规范，作用是用来在用户和服务器之间传递安全可靠的信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;2-JWT是什么&quot;&gt;&lt;a href=&quot;#2-JWT是什么&quot; class=&quot;headerlink&quot; title=&quot;2. JWT是什么&quot;&gt;&lt;/a&gt;2. JWT是什么&lt;/h2&gt;&lt;p&gt;根据维基百科的定义，JSON WEB Token（JWT，读作 [/dʒɒt/]），是一种基于JSON的、用于在网络上声明某种主张的令牌（token）。JWT通常由三部分组成: 头信息（header）, 消息体（payload）和签名（signature）。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="javascript" scheme="https://blueskyadd.github.io/tags/javascript/"/>
    
      <category term="jwt" scheme="https://blueskyadd.github.io/tags/jwt/"/>
    
  </entry>
  
  <entry>
    <title>JS模块化</title>
    <link href="https://blueskyadd.github.io/2022/03/05/JS%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <id>https://blueskyadd.github.io/2022/03/05/JS%E6%A8%A1%E5%9D%97%E5%8C%96/</id>
    <published>2022-03-05T14:22:24.000Z</published>
    <updated>2022-08-03T05:47:51.540Z</updated>
    
    <content type="html"><![CDATA[<h2 id="📚一-什么是模块化"><a href="#📚一-什么是模块化" class="headerlink" title="📚一. 什么是模块化"></a>📚一. 什么是模块化</h2><blockquote><p>📣模块化是指解决一个复杂问题时自顶向下逐层把系统划分成若干模块的过程，有多种属性，分别反映其内部特性。                                ——维基百科</p></blockquote><p>这是维基百科对模块化的介绍，简单理解就是：</p><ul><li>将代码拆分成独立的块，然后把这些块连接起来可以通过模块模式来实现。</li><li><p>块的内部数据与实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信</p><span id="more"></span><h2 id="📚二-js模块化发展历程"><a href="#📚二-js模块化发展历程" class="headerlink" title="📚二. js模块化发展历程"></a>📚二. js模块化发展历程</h2><p>在JS设计之初，本身就是为了满足简单的页面设计： 页面动画 + 表单提交，并无模块化 or 命名空间的概念。但随着CPU、浏览器性能得到了极大的提升，页面的复杂程度也显著提高，JS的模块化需求也日益增加。</p><p>js模块化的发展一共经历了以下几个阶段：</p></li></ul><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6573afb4961a48fd91c34fe585aecf45~tplv-k3u1fbpfcp-watermark.image?" alt="微信截图_20220412022618.png"></p><h3 id="✏️2-1-幼年期：无模块化"><a href="#✏️2-1-幼年期：无模块化" class="headerlink" title="✏️2.1 幼年期：无模块化"></a>✏️2.1 幼年期：无模块化</h3><p>在发展之初，没有模块化的概念，但随着业务逻辑的复杂度增加，我们也遇到了一些需求，比如：</p><ul><li>开始需要在页面中加载不同的JS：动画、组件、格式化 </li><li>多种js文件会被分在不同的文件中</li><li>不同的文件又被同一个模板所引用</li></ul><h4 id="🎈作用：将不同的业务逻辑（js文件），引入到同一个页面上去"><a href="#🎈作用：将不同的业务逻辑（js文件），引入到同一个页面上去" class="headerlink" title="🎈作用：将不同的业务逻辑（js文件），引入到同一个页面上去"></a>🎈作用：将不同的业务逻辑（js文件），引入到同一个页面上去</h4><p>这种文件分离拆分是最基础的模块化（第一步）</p><h3 id="✒️2-2-成长期：模块化前夜-IIFE-语法侧的优化"><a href="#✒️2-2-成长期：模块化前夜-IIFE-语法侧的优化" class="headerlink" title="✒️2.2 成长期：模块化前夜 - IIFE(语法侧的优化)"></a>✒️2.2 成长期：模块化前夜 - IIFE(语法侧的优化)</h3><blockquote><p>IIFE: 立即调用函数表达式</p></blockquote><h5 id="📒编码-将数据和行为封装到一个函数内部-通过给window添加属性来向外暴露接口"><a href="#📒编码-将数据和行为封装到一个函数内部-通过给window添加属性来向外暴露接口" class="headerlink" title="📒编码: 将数据和行为封装到一个函数内部, 通过给window添加属性来向外暴露接口"></a>📒编码: 将数据和行为封装到一个函数内部, 通过给window添加属性来向外暴露接口</h5><h5 id="🎈作用-数据是私有的-外部只能通过暴露的方法操作"><a href="#🎈作用-数据是私有的-外部只能通过暴露的方法操作" class="headerlink" title="🎈作用:  数据是私有的, 外部只能通过暴露的方法操作"></a>🎈作用:  数据是私有的, 外部只能通过暴露的方法操作</h5><p>为按照模块模式提供必要的封装，ES6之前的模块会使用函数作用域和IIFE将模块定义封装在匿名闭包中。</p><p>例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> increase = <span class="function">() =&gt;</span> ++count;</span><br><span class="line"><span class="keyword">const</span> reset = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>利用函数的块级作用域 - 隔离区</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">   <span class="comment">// ……</span></span><br><span class="line"> &#125;)();</span><br></pre></td></tr></table></figure><h5 id="🐛问题：-独立模块本身的额外依赖，如何优化？"><a href="#🐛问题：-独立模块本身的额外依赖，如何优化？" class="headerlink" title="🐛问题： 独立模块本身的额外依赖，如何优化？"></a>🐛问题： 独立模块本身的额外依赖，如何优化？</h5><p>方案： 依赖其他模块的传参型<br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> iifeModule = (<span class="function">(<span class="params">dependencyModule1, dependencyModule2</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">const</span> increase = <span class="function">() =&gt;</span> ++count;</span><br><span class="line">   <span class="keyword">const</span> reset = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">     count = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">console</span>.log(count);</span><br><span class="line">   increase();</span><br><span class="line"> &#125;)(dependencyModule1, dependencyModule2);</span><br></pre></td></tr></table></figure><br> 将依赖作为参数，传入到独立模块。</p><h3 id="2-3-🪡成熟期：CJS-Commonjs"><a href="#2-3-🪡成熟期：CJS-Commonjs" class="headerlink" title="2.3 🪡成熟期：CJS - Commonjs"></a>2.3 🪡成熟期：CJS - Commonjs</h3><h4 id="2-3-1-🌭说明："><a href="#2-3-1-🌭说明：" class="headerlink" title="2.3.1 🌭说明："></a>2.3.1 🌭说明：</h4><p><code>CommonJS</code>规范概述了同步声明依赖的模块定义。CommonJS模块语法不能直接在浏览器中直接运行。</p><h4 id="2-3-2-基本语法"><a href="#2-3-2-基本语法" class="headerlink" title="2.3.2 基本语法"></a>2.3.2 基本语法</h4><ol><li><p>暴露模块：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = value</span><br><span class="line"><span class="built_in">exports</span>.xxx = value</span><br></pre></td></tr></table></figure></li><li><p>引入模块:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(xxx)</span><br></pre></td></tr></table></figure><p>CommonJS 模块定义需要使用<code>require（）</code>指定依赖</p></li></ol><blockquote><p>❗无论一个模块在require（）中被引用多少次，模块永远是单例。模块第一次加载后会被缓存，后续加载会取得缓存的模块。</p></blockquote><p>每个模块内部，module对象代表当前模块，它的exports属性（即module.exports）是对外的接口(暴露出去)。加载某个模块，其实是加载该模块的module.exports属性。</p><h4 id="2-3-3-加载机制"><a href="#2-3-3-加载机制" class="headerlink" title="2.3.3 加载机制"></a>2.3.3 加载机制</h4><ul><li>CommonJS 用于 node 端，是同步加载的，也就是说，只有加载完成，才能执行后面的操作。</li><li>输入的是被输出的值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</li></ul><h4 id="2-3-4-优点"><a href="#2-3-4-优点" class="headerlink" title="2.3.4 优点"></a>2.3.4 优点</h4><p>CommonJs率先在服务端实现了，从框架层面解决了依赖、全局变量污染的问题</p><h5 id="2-3-5-缺点"><a href="#2-3-5-缺点" class="headerlink" title="2.3.5 缺点"></a>2.3.5 缺点</h5><p>针对了服务端的解决方案。异步拉取依赖处理不是很完美</p><h4 id="2-3-6-面试问题"><a href="#2-3-6-面试问题" class="headerlink" title="2.3.6 面试问题"></a>2.3.6 面试问题</h4><p><strong>🐛exports 与 module.exports</strong></p><p>为了方便，Node为每个模块提供一个exports变量，指向module.exports。这等同在每个模块头部，有一行这样的命令。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">exports</span> = <span class="built_in">module</span>.exports;</span><br></pre></td></tr></table></figure></p><p>exports其实是module.exports的引用 ，可以直接在exports对象上添加相关的方法。</p><h3 id="2-4-💁‍-AMD规范"><a href="#2-4-💁‍-AMD规范" class="headerlink" title="2.4 💁‍ AMD规范"></a>2.4 💁‍ <a href="https://github.com/amdjs/amdjs-api/wiki/AMD">AMD规范</a></h3><p>CommonJS以服务端为目标环境，能够一次性把所有模块都加载到内存中，而异步模块定义（AMD）的模块定义系统则以浏览器为目标执行环境，只需要考虑网络延迟的问题。</p><p>经典实现框架：require.js</p><h4 id="2-4-1-🌭说明："><a href="#2-4-1-🌭说明：" class="headerlink" title="2.4.1 🌭说明："></a>2.4.1 🌭说明：</h4><p>AMD规范是非同步加载模块，允许指定回调函数。</p><h4 id="2-4-2-基本语法"><a href="#2-4-2-基本语法" class="headerlink" title="2.4.2 基本语法"></a>2.4.2 基本语法</h4><p><strong>1. 定义暴露模块:</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define([module-name?], [array-of-dependencies?], [module-factory-or-object]);</span><br></pre></td></tr></table></figure></p><p>其中：</p><ol><li>module-name: 模块标识，可以省略。</li><li>array-of-dependencies: 所依赖的模块，可以省略。</li><li>module-factory-or-object: 模块的实现，或者一个JavaScript对象。</li></ol><p><strong>2. 引入使用模块:</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">&#x27;module1&#x27;</span>, <span class="string">&#x27;module2&#x27;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">m1, m2</span>)</span>&#123;</span><br><span class="line">   <span class="comment">//使用m1/m2</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h4 id="2-4-3-模块的加载机制"><a href="#2-4-3-模块的加载机制" class="headerlink" title="2.4.3 模块的加载机制"></a>2.4.3 模块的加载机制</h4><p>AMD 依赖于 requirejs,是异步加载的，是提前加载，立即加载</p><h4 id="2-4-4-优点"><a href="#2-4-4-优点" class="headerlink" title="2.4.4 优点"></a>2.4.4 优点</h4><p>适合在浏览器中加载异步模块的方案</p><h4 id="2-4-5-缺点"><a href="#2-4-5-缺点" class="headerlink" title="2.4.5 缺点"></a>2.4.5 缺点</h4><p>引入成本</p><h3 id="2-5-💁‍-CMD规范"><a href="#2-5-💁‍-CMD规范" class="headerlink" title="2.5 💁‍ CMD规范"></a>2.5 💁‍ <a href="https://github.com/seajs/seajs/issues/242">CMD规范</a></h3><p>CMD是SeaJS 在推广过程中对模块定义的规范化产出, CMD规范专门用于浏览器端，模块的加载是异步的，模块使用时才会加载执行。CMD规范整合了CommonJS和AMD规范的特点。</p><h4 id="2-5-1-🥯基本语法"><a href="#2-5-1-🥯基本语法" class="headerlink" title="2.5.1 🥯基本语法"></a>2.5.1 🥯基本语法</h4><p>定义暴露模块:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义没有依赖的模块</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">exports</span>.xxx = value</span><br><span class="line">  <span class="built_in">module</span>.exports = value</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义有依赖的模块</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, dom</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//引入依赖模块(同步)</span></span><br><span class="line">  <span class="keyword">var</span> dom2 = <span class="built_in">require</span>(<span class="string">&#x27;./dom2&#x27;</span>)</span><br><span class="line">  <span class="comment">//引入依赖模块(异步)</span></span><br><span class="line">    <span class="built_in">require</span>.async(<span class="string">&#x27;./dom3&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">m3</span>) </span>&#123;</span><br><span class="line">    &#125;)</span><br><span class="line">  <span class="comment">//暴露模块</span></span><br><span class="line">  <span class="built_in">exports</span>.xxx = value</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>引入使用模块:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> m1 = <span class="built_in">require</span>(<span class="string">&#x27;./module1&#x27;</span>)</span><br><span class="line">  <span class="keyword">var</span> m4 = <span class="built_in">require</span>(<span class="string">&#x27;./module4&#x27;</span>)</span><br><span class="line">  m1.show()</span><br><span class="line">  m4.show()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h4 id="2-5-2-🥨模块的加载机制"><a href="#2-5-2-🥨模块的加载机制" class="headerlink" title="2.5.2 🥨模块的加载机制"></a>2.5.2 🥨模块的加载机制</h4><p>CMD 依赖于 seajs ,是异步加载，延后加载，就近加载，用时加载</p><h4 id="2-5-3-🥐优点"><a href="#2-5-3-🥐优点" class="headerlink" title="2.5.3 🥐优点"></a>2.5.3 🥐优点</h4><p>按需加载，依赖就近</p><h4 id="2-5-4-🥗缺点"><a href="#2-5-4-🥗缺点" class="headerlink" title="2.5.4  🥗缺点"></a>2.5.4  🥗缺点</h4><p>依赖打包，加载逻辑存在于每个模块中，扩大了模块体积，同时功能上依赖编译</p><h4 id="2-5-5-🐛问题"><a href="#2-5-5-🐛问题" class="headerlink" title="2.5.5 🐛问题"></a>2.5.5 🐛问题</h4><p>AMD 和 CMD 的区别有哪些?</p><ol><li>对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.</li><li>CMD 推崇依赖就近，AMD 推崇依赖前置。</li><li>AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一.</li></ol><h3 id="2-6-✒️ES6模块化"><a href="#2-6-✒️ES6模块化" class="headerlink" title="2.6  ✒️ES6模块化"></a>2.6  ✒️ES6模块化</h3><h4 id="2-6-1-🍡基本语法"><a href="#2-6-1-🍡基本语法" class="headerlink" title="2.6.1 🍡基本语法"></a>2.6.1 🍡基本语法</h4><p><strong>1. 导出</strong></p><p>export命令<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> obj = &#123;<span class="attr">name</span>: <span class="string">&#x27;E1e&#x27;</span>&#125;；</span><br></pre></td></tr></table></figure></p><p>默认导出 export default命令<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;n</span><br><span class="line"></span><br><span class="line"><span class="attr">ame</span>: <span class="string">&#x27;E1e&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>2. 引入</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入普通导出</span></span><br><span class="line"><span class="keyword">import</span> &#123; obj &#125; <span class="keyword">from</span> <span class="string">&#x27;./test.js&#x27;</span>;</span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入默认导出 </span></span><br><span class="line"><span class="keyword">import</span> obj <span class="keyword">from</span> <span class="string">&#x27;./test.js&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="2-6-2-🍭模块的加载机制"><a href="#2-6-2-🍭模块的加载机制" class="headerlink" title="2.6.2 🍭模块的加载机制"></a>2.6.2 🍭模块的加载机制</h4><ul><li>模块支持异步加载</li><li>同一个模块如果加载多次，将只执行一次。</li><li>既可以通过浏览器原生加载，也可以与第三方加载器和构建工具一起加载</li></ul><h4 id="2-6-3-🍬优点"><a href="#2-6-3-🍬优点" class="headerlink" title="2.6.3 🍬优点"></a>2.6.3 🍬优点</h4><p>通过一种最终统一各端的形态，整合了js模块化的通用方案</p><h4 id="2-6-4-🍫局限性"><a href="#2-6-4-🍫局限性" class="headerlink" title="2.6.4 🍫局限性"></a>2.6.4 🍫局限性</h4><p>本质上还是运行时的依赖分析</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;📚一-什么是模块化&quot;&gt;&lt;a href=&quot;#📚一-什么是模块化&quot; class=&quot;headerlink&quot; title=&quot;📚一. 什么是模块化&quot;&gt;&lt;/a&gt;📚一. 什么是模块化&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;📣模块化是指解决一个复杂问题时自顶向下逐层把系统划分成若干模块的过程，有多种属性，分别反映其内部特性。                                ——维基百科&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是维基百科对模块化的介绍，简单理解就是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将代码拆分成独立的块，然后把这些块连接起来可以通过模块模式来实现。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;块的内部数据与实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="模块化" scheme="https://blueskyadd.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>深入理解URL</title>
    <link href="https://blueskyadd.github.io/2022/02/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3URL/"/>
    <id>https://blueskyadd.github.io/2022/02/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3URL/</id>
    <published>2022-02-22T14:12:42.000Z</published>
    <updated>2022-08-02T14:18:25.657Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>📢📢📢url就是因特资源网的标准化名称。URL指向一条电子信息片段，告诉你它们位于何处，以及如何与之进行交互                                                                               ——《http权威指南》</p></blockquote><h3 id="📚-1、URL和URI"><a href="#📚-1、URL和URI" class="headerlink" title="📚 1、URL和URI"></a>📚 1、URL和URI</h3><p>说起URL,我们不得不提起URI。URI是一类更通用的资源标识符，URL实际上是它的一个子集。URI包含URL和URN，URL是通过资源位置来标识资源的，而URN是通过名字来识别资源的。那么这三者的关系，就类似我我们身份证上的身份证号、家庭住址、姓名。</p><p>虽然规范的做法是URI作为统一资源标识符，但是在http中只处理了URL，那么我们就来看看我们熟悉的URL<br><span id="more"></span></p><h3 id="📚-2、url的组成"><a href="#📚-2、url的组成" class="headerlink" title="📚 2、url的组成"></a>📚 2、url的组成</h3><p>每天上网的我们，几乎每天都会打开几十个网页，这些网页都会有一个唯一的URL地址。我们可以通过这个地址来找到网页，那么这个地址中都包含哪些信息呢？它是如何与浏览器、客户端、服务器以及服务器文件系统中位置进行关联的🤸‍♂️ \<br>举个例子🌰 \<br>比如 我们要看阮大大的文章🥴<p><a href="https://www.bookstack.cn/read/html-tutorial/docs-url.md">https://www.bookstack.cn/read/html-tutorial/docs-url.md</a></p> 那么这个URL就分为以下三个部分。</p><ul><li>URL的第一部分（https）是URL的方案（scheme）。方案可以告知Web客户端怎样访问资源。在这个例子中，URL说明要使用https协议。</li><li>URL的第二个部分（<a href="http://www.bookstack.cn）">www.bookstack.cn）</a> 指的是服务器的位置。这部分告知Web客户端资源位于何处。</li><li>URL的第三个部分（/read/html-tutorial/docs-url.md）是资源路径。历经说明了请求的是服务器上的哪个特定的本地资源。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf80052dc9ac40c1a621a82f17e921c7~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>其实URL最主要的组成也就是这三部分<code>方案（scheme）</code>、<code>主机（host）</code>、<code>路径（path）</code>。但其实URL是由于9部分组成的，我们一起来看下面这个表格</p><table><thead><tr><th>组件</th><th>描述</th></tr></thead><tbody><tr><td>scheme</td><td>方法描述了请求资源时用了什么协议，用“:”与url其它部分隔开；</td></tr><tr><td>password</td><td>密码描述了用户名后面可能跟的密码，用“:”跟用户名隔开；</td></tr><tr><td>host</td><td>主机描述了网站主机名或ip地址，如果前面有用户名和密码，用@分开；</td></tr><tr><td>post</td><td>服务器当前正在监听的端口，http默认为80，https默认为443;</td></tr><tr><td>path</td><td>路劲描述了资源在服务器上的位置，用‘/’跟前面部分隔开；</td></tr><tr><td>params</td><td>参数描述了请求需要附加的参数，用“;”与其他部分隔开；</td></tr><tr><td>query</td><td>查询是用来激活服务器程序去执行某些操作，比如查询数据库等，用“?”与其余部分隔开；</td></tr><tr><td>frag</td><td>片段只在客户端使用，不发送到服务器端</td></tr></tbody></table><p>那么接下来我们来看几个我们实际开发常用的几个组件</p><h4 id="📕-2-1-方案"><a href="#📕-2-1-方案" class="headerlink" title="📕 2.1 方案"></a>📕 2.1 方案</h4><p>方案实际上是规定如何访问指定资源的主要标识，它会负责解析URL的应用程序应该是用什么协议，我们比较常见的就是HTTP、HTTPS。一共有如下几种方案</p><ul><li>http</li><li>https</li><li>mailto</li><li>ftp</li><li>rtsp、rtspu</li></ul><h4 id="📗-2-2-主机和端口"><a href="#📗-2-2-主机和端口" class="headerlink" title="📗 2.2 主机和端口"></a>📗 2.2 主机和端口</h4><p>我们想要从因特网上获取资源，就必须要知道是哪台机器，以及在那台机器的什么地方可以找到能对目标资源进行访问的服务器。URL的主机和端口就提供了这个信息。\<br>我们可以通过主机名或者IP地址来访问， 其实在前端使用框架开发的话，由于本地启动的服务，那其实我们访问的就是本机的IP地址。</p><h4 id="📘-2-3-路径"><a href="#📘-2-3-路径" class="headerlink" title="📘 2.3 路径"></a>📘 2.3 路径</h4><p>URL的路径组件说明了资源位于服务器的什么地方。路径通常很像一个分级的文件系统路径。<br/><br>🌰比如：</p><p><a href="https://www.bookstack.cn/read/html-tutorial/docs-url.md">https://www.bookstack.cn/read/html-tutorial/docs-url.md</a></p>🤸‍<br><br>这个URL中的路径为/html-tutorial/docs-url.md，很像UNIX文件系统中的文件系统路径。路径是服务器定位资源时所需的信息。<br><br><h4>📙 2.4 参数</h4><br>对很多方案来说，只有简单的主机名和到达对象的路径是不够的。除了服务器正在监听的端口，以及是否能够通过用户名和密码访问资源外，很多协议都还需要更多的信息才能工作。<br><br><strong>为了向应用程序提供它们所需的输入参数，以便正确地与服务器进行交互，URL中有一个参数组件。</strong><br>这个组件就是URL中的名值对列表，由字符“; ”将其与URL的其余部分（以及各名值对）分隔开来。它们为应用程序提供了访问资源所需的所有附加信息。<br><br><h4>📒 2.5 查找字符串</h4><br>查找字符串，我们在日常开发中有经常使用。比如说我们从商品列表跳转商品详情时，会将商品ID传递到商品详情页面，然后通过商品ID来获取商品详情。\<br>🌰举个例子：<br><p><a href="https://search.bilibili.com/all?keyword=哈利波特&amp;from_source=webtop_search&amp;spm_id_from=333.851">https://search.bilibili.com/all?keyword=哈利波特&amp;from_source=webtop_search&amp;spm_id_from=333.851</a></p><p>🤸‍我们在哔哩哔哩上搜索哈利波特，按下回车我们会的到上面的URL，这个URL的大部分都与我们见过的其他URL类似。只有问号（?）右边的内容是新出现的。这部分被称为<code>查询（query）组件</code>。URL的查询组件和标识网关资源的URL路径组件一起被发送给网关资源。<br>上个链接中，我们获取到三个参数，<code>keyword</code>、<code>from_source</code>、<code>spm_id_from</code>,按照常规，很多网关都希望查询字符串以一系列“名/值”对的形式出现，名值对之间用字符“&amp;”分隔 </p><h4 id="📗-2-6-片段"><a href="#📗-2-6-片段" class="headerlink" title="📗 2.6 片段"></a>📗 2.6 片段</h4><p>为了引用部分资源或资源的一个片段，URL支持使用片段（frag）组件来表示一个资源内部的片段。\<br>在日常开发中，我们也称之为<code>锚点（anchor）</code> ，它是网页内部的定位点，使用<code>#</code>加上锚点名称，放在网址的最后，比如<code>#anchor</code>。浏览器加载页面以后，会自动滚动到锚点所在的位置。 </p><p>HTTP服务器通常只处理整个对象，而不是对象的片段，客户端不能将片段传送给服务器。浏览器从服务器获得了整个资源之后，会根据片段来显示你感兴趣的那部分资源。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ffa4a0aa46b4bde9394a70f468662dc~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h3 id="📚-3-、url编码"><a href="#📚-3-、url编码" class="headerlink" title="📚 3 、url编码"></a>📚 3 、url编码</h3><h4 id="📙-3-1什么时URL编码"><a href="#📙-3-1什么时URL编码" class="headerlink" title="📙 3.1什么时URL编码"></a>📙 3.1什么时URL编码</h4><p>为了避开安全字符集表示法带来的限制，人们设计了一种编码机制，用来在URL中表示各种不安全的字符。这种编码机制就是通过一种“转义”表示法来表示不安全字符的，这种转义表示法包含一个百分号（%），后面跟着两个表示字符ASCII码的十六进制数。</p><h4 id="📘-3-2-为什么要对URL进行编码"><a href="#📘-3-2-为什么要对URL进行编码" class="headerlink" title="📘 3.2 为什么要对URL进行编码"></a>📘 3.2 为什么要对URL进行编码</h4><p>通常如果一样东西需要编码，说明这样东西并不适合传输。原因多种多样，如<code>Size</code>过大，包含隐私数据，对于Url来说，之所以要进行编码，是因为以下两种原因：</p><ol><li><p>http协议规定请求头与请求行必须是<code>ascii编码</code>，这也就是说你不能在Url中包含任何非<code>ASCII字符</code>，例如中文。这一部分的编解码任务<code>encodeURI</code>、<code>decodeURL</code>就能完成，而事实上浏览器跟web服务器一般都帮我们做了。</p></li><li><p>url中部分内容包含不安全字符，比如，Url参数字符串中使用<code>key=value</code>键值对这样的形式来传参，键值对之间以&amp;符号分隔，如<code>/s?q=abc&amp;ie=utf-8</code>。如果你的value字符串中包含了=或者&amp;，那么势必会造成接收Url的服务器解析错误，因此必须将引起歧义的&amp;和=符号进行转义，也就是对其进行编码。这一部分可以用<code>encodeURIComponent</code>完成，解码后台服务器自动完成</p></li></ol><p>但是服务器并不会对url进行编码，服务器不可能对错综复杂的编码结果进行处理，所以，需要使用Javascript先对URL编码，然后再向服务器提交，不给浏览器插手的机会。</p><h4 id="📗-3-3-js对url进行编码和解码"><a href="#📗-3-3-js对url进行编码和解码" class="headerlink" title="📗 3.3 js对url进行编码和解码"></a>📗 3.3 js对url进行编码和解码</h4><p>以下三种函数都可以对URL进行编码，区别主要在于不编码的字符不同，具体使用详见各自的使用场景：</p><p>📃  <strong>1.escape 和 unescape</strong></p><pre><code>对除ASCII字母、数字、标点符号 @  *  _  +  -  .  / 以外的其他字符进行编码。</code></pre><p>📄 <strong>2. encodeURI 和 decodeURI</strong></p><pre><code>返回编码为有效的统一资源标识符 (URI) 的字符串，不会被编码的字符：! @ # $ &amp; * ( ) = : / ; ? + &apos;encodeURI()是Javascript中真正用来对URL编码的函数。</code></pre><p>📑 <strong>3. encodeURIComponent 和 decodeURIComponent</strong></p><pre><code>对URL的组成部分进行个别编码，而不用于对整个URL进行编码</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;📢📢📢url就是因特资源网的标准化名称。URL指向一条电子信息片段，告诉你它们位于何处，以及如何与之进行交互                                                                               ——《http权威指南》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;📚-1、URL和URI&quot;&gt;&lt;a href=&quot;#📚-1、URL和URI&quot; class=&quot;headerlink&quot; title=&quot;📚 1、URL和URI&quot;&gt;&lt;/a&gt;📚 1、URL和URI&lt;/h3&gt;&lt;p&gt;说起URL,我们不得不提起URI。URI是一类更通用的资源标识符，URL实际上是它的一个子集。URI包含URL和URN，URL是通过资源位置来标识资源的，而URN是通过名字来识别资源的。那么这三者的关系，就类似我我们身份证上的身份证号、家庭住址、姓名。&lt;/p&gt;
&lt;p&gt;虽然规范的做法是URI作为统一资源标识符，但是在http中只处理了URL，那么我们就来看看我们熟悉的URL&lt;br&gt;
    
    </summary>
    
    
    
      <category term="http" scheme="https://blueskyadd.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>HTTP报文是什么</title>
    <link href="https://blueskyadd.github.io/2022/01/22/HTTP%E6%8A%A5%E6%96%87%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>https://blueskyadd.github.io/2022/01/22/HTTP%E6%8A%A5%E6%96%87%E6%98%AF%E4%BB%80%E4%B9%88/</id>
    <published>2022-01-22T14:07:32.000Z</published>
    <updated>2022-08-02T14:11:38.555Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 📢📢如果说http是因特网的信使，那么http报文就是他用来送信的包裹了</p></blockquote><h2 id="1-📚什么是报文"><a href="#1-📚什么是报文" class="headerlink" title="(1)📚什么是报文"></a>(1)📚什么是报文</h2><p>在度娘的介绍中</p><blockquote><p><em>📣报文(message)是网络中交换与传输的数据单元，即站点一次性要发送的数据块。报文包含了将要发送的完整的数据信息，其长短很不一致，长度不限且可变。</em>  </p></blockquote><p>也就是说http报文是在http应用程序之间发送的数据块，，它包裹着我们进行请求数据交换的信息✔。</p><span id="more"></span><h2 id="2-📚报文的组成部分"><a href="#2-📚报文的组成部分" class="headerlink" title="(2)📚报文的组成部分"></a>(2)📚报文的组成部分</h2><h3 id="📃2-1-报文基本结构"><a href="#📃2-1-报文基本结构" class="headerlink" title="📃2.1 报文基本结构"></a>📃2.1 报文基本结构</h3><p>http报文是简单的格式化数据块，它有三个部分组成。对报文进行描述的<code>起始行（start line）</code>、包含属性的<code>首部（header）</code>、以及可选的包含数据的<code>主体（body）</code>部分，主体部分可以包含文本或二进制数据也可以为空。</p><p>举个栗子🌰，如图所示，这里列举了一个服务端响应的报文<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c892589b5e794592aba98cfe1bbd5671~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>📊在这张图中，<code>首部</code>给出了一些与主体信息有关的信息。<code>Content-Type</code>行说明了主体是纯文本文档<code>text/plain</code>，<code>Content-Length</code>行说明了当前主体的大小16个字节。</p><h3 id="📃2-2-报文的分类"><a href="#📃2-2-报文的分类" class="headerlink" title="📃2.2 报文的分类"></a>📃2.2 报文的分类</h3><p>所有的HTTP报文都可以分为两类，<code>请求报文（request message）</code>和<code>响应报文（response message）</code>。请求报文由客户端向服务器发出，响应报文由服务器响应客户端返回响应结果。虽然有区别，但是两种报文的结构是相同的，都是由起始行、首部、主体三部分组成。</p><p>📒请求报文的格式<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;method&gt; &lt;request-URL&gt; &lt;versin&gt;</span><br><span class="line">&lt;header&gt;</span><br><span class="line">&lt;entity-body&gt;</span><br></pre></td></tr></table></figure><br>📒响应报文的格式（只有起始行是不同的）<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;versin&gt; &lt;status&gt; &lt;reason-phrase&gt;</span><br><span class="line">&lt;header&gt;</span><br><span class="line">&lt;entity-body&gt;</span><br></pre></td></tr></table></figure></p><ul><li>请求方法（method）\<br>  客户端对服务端发起请求的方式，比如get、post、put等</li><li>请求URL（request-URL）\<br>  请求服务器资源的url路径</li><li>版本（versin）\<br>  报文所使用的http的版本</li><li>状态码（status-code)\<br>  这三位数字描述了请求过程中所发生的情况。</li><li>原因短语（reason-phrase）\<br>  数字状态码的可读版本，比如上面例子中的OK</li><li>首部（header）\<br>  可以有零个或者多个首部，每个首部都包含一个名字。</li><li>实体的主体部分（entity-body）\<br>  包含一个由任意数据组成的数据块</li></ul><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73c392ac72f64909a6f45fb131fda7fb~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h2 id="3-📚请求报文支持的各种方法"><a href="#3-📚请求报文支持的各种方法" class="headerlink" title="(3)📚请求报文支持的各种方法"></a>(3)📚请求报文支持的各种方法</h2><p>请求的起始行以方法作为开始，方法使用来告知服务器要做些什么。<strong>但值得注意的是并不是每个服务器都实现了所有方法，这些限制通常都是在服务器的配置中进行设置的，因此会随着站点和服务器的不同而有所不同。</strong></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c867cba3188b4001bd6fe929a7e0dbc0~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br><em>此图来自菜鸟驿站</em></p><h3 id="📃3-1-GET请求"><a href="#📃3-1-GET请求" class="headerlink" title="📃3.1  GET请求"></a>📃3.1  GET请求</h3><p>主要用于向指定的URL（URI）请求资源（资源文件或是数据均可）， 可以带参数也可以不带参数， 带参数时，参数是明文传递，你可以在浏览器的地址栏中看到参数名及参数值，get安全性不高，所以常用于安全性要求低的场合， 比如登录后请求数据。</p><h3 id="📃3-2-HEAD请求"><a href="#📃3-2-HEAD请求" class="headerlink" title="📃3.2 HEAD请求"></a>📃3.2 HEAD请求</h3><p>HEAD 请求和 GET请求很类似，都是从服务器获取资源，但是服务器在响应中并不会返回主体，只返回首部。<strong>服务器开发者必须确保返回的首部和GET请求返回的首部是完全相同的</strong>。</p><p>HEAD请求常常被忽略，但是能提供很多有用的信息，特别是在有限的速度和带宽下，使用HEAD请求，可以：</p><p>1、只请求资源的首部；</p><p>2、检查超链接的有效性、以及最近是否更新；</p><p>3、通过查看首部，检查网页是否被修改；</p><p>4、多用于自动搜索机器人获取网页的标志信息，获取rss种子信息，或者传递安全认证信息等</p><h3 id="📃3-3-POST请求"><a href="#📃3-3-POST请求" class="headerlink" title="📃3.3 POST请求"></a>📃3.3 POST请求</h3><p>在Http请求里post是其中比较常用的提交数据的请求方式, POST方法起初是用来向服务器输入数据的。实际上，我们通常会用它来提交form表单。</p><h3 id="📃3-4-PUT请求"><a href="#📃3-4-PUT请求" class="headerlink" title="📃3.4 PUT请求"></a>📃3.4 PUT请求</h3><p>PUT请求是向服务器端发送数据的，从而改变信息，该请求就像数据库的update操作一样，用来修改数据的内容，但是不会增加数据的种类等，也就是说无论进行多少次PUT操作，其结果并没有不同。</p><h3 id="📃3-5-DELETE请求"><a href="#📃3-5-DELETE请求" class="headerlink" title="📃3.5 DELETE请求"></a>📃3.5 DELETE请求</h3><p>DELETE请求顾名思义，就是用来删除某一个资源的，该请求就像数据库的delete操作。</p><h3 id="📃3-6-CONNECT请求"><a href="#📃3-6-CONNECT请求" class="headerlink" title="📃3.6 CONNECT请求"></a>📃3.6 CONNECT请求</h3><p>connect在网页开发中不会使用到， connect的作用就是将服务器作为代理，让服务器代替用户去访问其他网页（说白了，就是翻墙），之后将数据返回给用户。</p><h3 id="📃3-7-OPTIONS请求"><a href="#📃3-7-OPTIONS请求" class="headerlink" title="📃3.7 OPTIONS请求"></a>📃3.7 OPTIONS请求</h3><p>OPTIONS请求web服务器告知其支持的各种功能。可以询问服务器支持哪些方法，或者对某些特殊资源支持哪些方法，这就为客户端提供了一种手段，使其不用访问那些资源就可以知道访问这种资源最优的方式，仅作查询使用。<br>简而言之，OPTIONS请求方法的主要用途有两个：</p><ol><li><p>获取服务器支持的HTTP请求方法；</p></li><li><p>用来检查服务器的性能。</p></li></ol><p>🙄其实在实际开发中我们可能经常有见到OPTIONS请求，因为在<strong>某些情况</strong>下，普通的get或者post请求回首先自动发起一次options请求，当options请求成功返回后，真正的ajax请求才会再次发起。<br>那么是哪些情况会发起OPTIONS请求呢?</p><ol><li>跨域请求，非跨域请求不会出现options请求</li><li>自定义请求头</li><li>请求头中的content-type是application/x-www-form-urlencoded，multipart/form-data，text/plain之外的格式<h3 id="📃3-8-TRACE请求"><a href="#📃3-8-TRACE请求" class="headerlink" title="📃3.8 TRACE请求"></a>📃3.8 TRACE请求</h3></li></ol><p>TRACE方法允许客户端在最终将请求发送给服务器时看一看它变成什么样子了，因为当客户端发送一个请求时，这个请求可能要穿过防火墙、代理、网关或者其他的应用程序，每个中间节点都有可能修改原始的http请求。</p><p>TRACE方法主要用来诊断，当然他也有缺点，<br>TRACE方法是HTTP（超文本传输）协议定义的一种协议调试方法，该方法使得服务器原样返回任何客户端请求的内容（可能会附加路由中间的代理服务器的信息），由于该方法原样返回客户端提交的任意数据，因此，可用来进行跨站脚本（XSS）攻击，这种攻击方式又称为跨站跟踪攻击（XST）。</p><h3 id="📃3-9-PATCH请求"><a href="#📃3-9-PATCH请求" class="headerlink" title="📃3.9 PATCH请求"></a>📃3.9 PATCH请求</h3><p>HTTP中为了提高交互操作性与防止错误，确实需要一种新的修改方法，而PUT方法已经被定义为用一个请求体去修改一个完整的资源。并且不能重复做部分更改，否则代理和缓存、甚至服务器或者客户端都会得到有问题的操作结果。</p><p>至此，PATCH方法有了被完全定义的必要。</p><p>PATCH在请求中定义了一个描述修改的实体集合，如果被请求修改的资源不存在，服务器可能会创建一个新的资源。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt; 📢📢如果说http是因特网的信使，那么http报文就是他用来送信的包裹了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-📚什么是报文&quot;&gt;&lt;a href=&quot;#1-📚什么是报文&quot; class=&quot;headerlink&quot; title=&quot;(1)📚什么是报文&quot;&gt;&lt;/a&gt;(1)📚什么是报文&lt;/h2&gt;&lt;p&gt;在度娘的介绍中&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;📣报文(message)是网络中交换与传输的数据单元，即站点一次性要发送的数据块。报文包含了将要发送的完整的数据信息，其长短很不一致，长度不限且可变。&lt;/em&gt;  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是说http报文是在http应用程序之间发送的数据块，，它包裹着我们进行请求数据交换的信息✔。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="http" scheme="https://blueskyadd.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>React SSR 的实现</title>
    <link href="https://blueskyadd.github.io/2021/11/10/React%20SSR%20%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://blueskyadd.github.io/2021/11/10/React%20SSR%20%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-11-10T12:01:14.000Z</published>
    <updated>2022-08-02T13:59:47.384Z</updated>
    
    <content type="html"><![CDATA[<p>再看react ssr 之前，我们先来看一个使用react ssr 实现的应用，感受一下它飞一般的渲染速度 <a href="https://m.xin.com/">https://m.xin.com/</a> 看过之后我们再来看文章。</p><h2 id="📚导读"><a href="#📚导读" class="headerlink" title="📚导读"></a>📚导读</h2><p>关于服务端渲染（SSR）、客户端渲染（CSR）和 同构渲染，我在<a href="https://juejin.cn/post/6854573217365884941">next.js从入门到实战</a>这篇文章中开头有详细的介绍，还不了解这三种渲染方式的可以简单了解一下。</p><p>但只实现 SSR 没什么意义，技术上没有任何改进，否则 SPA 技术就不会出现😀。<br>但是单纯的 SPA 又不够完美，所以最好的方案就是这两种技术和体验的结合。但是要实现两种技术的结合，同时可以最大限度的重用代码（同构），减少开发维护成本，那就需要采用 react 或者 vue 等前端框架和node(ssr)相结合的方式来实现。</p><p>如果我们使用react ssr 来实际开发项目，我们就需要一个完整的开发框架，next.js其实就是这种框架，类似的还有nuxt.js。那这种框架的实现原理是什么呢？<br><span id="more"></span></p><h2 id="📚react-ssr-实现原理"><a href="#📚react-ssr-实现原理" class="headerlink" title="📚react ssr 实现原理"></a>📚react ssr 实现原理</h2><p>在了解react ssr 我们先来看两个概念。</p><h3 id="📒虚拟dom"><a href="#📒虚拟dom" class="headerlink" title="📒虚拟dom"></a>📒虚拟dom</h3><p>react ssr其中的<code>SSR</code>指的是在服务端渲染组件。而组件可以在服务端渲染的根本原因就是<code>虚拟 DOM</code>，我们一般使用jsx来编写react组件，但其实jsx是一个语法糖，其实我们编写的组件都可以解析为一个个对象。这个对象包含</p><ul><li>🎈tag：节点标签名</li><li>🎈props：DOM的属性，用一个对象存储键值对</li><li>🎈children： 该节点的子节点<br>我们有了这个对象，我们就可以轻松的将其转换为我们需要的格式，比如<code>html</code>格式，当然这个转换不需要我们来完成，这个转换<code>react</code>已经帮我们完成了，其本身提供内置方法支持服务端渲染；我们先来具体了解一下同构的概念；</li></ul><h3 id="📒同构"><a href="#📒同构" class="headerlink" title="📒同构"></a>📒同构</h3><p>同构是将传统的纯服务端直出的首屏优势和SPA的站内体验优势结合起来，以取得最优解的解决方案。</p><p>就是服务端把首屏的内容直出，让用户更快的看到页面，然后后面的数据采用js来异步请求和加载。貌似不用<code>react</code>一样可以做到的呀，那为什么还一定要使用<code>react</code>或者<code>vue</code>这种框架来结合<code>ssr</code>呢？</p><p>我们知道同构就是指前后端公用一套代码，比如我们的组件可以在服务端渲染也可以在客户端渲染，但都是同一个组件。这也是react本身的优势。我们使用react来写，可以减少我们的代码量，基于react来实现更加方便，高效，因为我们可以使用react + node 来构造</p><h3 id="📒结语"><a href="#📒结语" class="headerlink" title="📒结语"></a>📒结语</h3><p>其实到这里我们也明白了什么是react ssr , react ssr 就是react 利用自身虚拟dom    的优势，然后通过同构渲染来实现的。react ssr 的核心就是同构，没有同构的 ssr 是没有意义的。</p><h2 id="📚react-ssr-是如何实现的"><a href="#📚react-ssr-是如何实现的" class="headerlink" title="📚react ssr 是如何实现的"></a>📚react ssr 是如何实现的</h2><p>我们了解了什么是react ssr ，那么react ssr 是怎么实现的呢，是怎么实现的服务端渲染，html的转换？</p><p>为了实现服务端渲染，打造同构应用，react内部实现了相关的API，可以将组件转换为html，可以一起来看一下这ReactDOMServer 这个 api</p><h3 id="📒ReactDOMServer"><a href="#📒ReactDOMServer" class="headerlink" title="📒ReactDOMServer"></a>📒ReactDOMServer</h3><p>ReactDOMServer 类可以帮我们在服务端渲染组件 - 得到组件的 html 字符串。</p><p>该模块有两个方法renderToString 和 renderToStaticMarkup，两个方法都是将组件转换为html格式的，它们的使用方式也是相同的，不同的是renderToStaticMarkup不需要计算，所以性能能高，速度更快。</p><h2 id="📚react-ssr-如何解决seo-tdk支持"><a href="#📚react-ssr-如何解决seo-tdk支持" class="headerlink" title="📚react ssr 如何解决seo tdk支持"></a>📚react ssr 如何解决seo tdk支持</h2><p>对于这个问题，其实有现成的轮子可以使用。它就是<a href="ReactDOMServer.renderToString(&lt;Handler /">react-helmet</a>;<br>const helmet = Helmet.renderStatic();)。</p><h3 id="📒简介"><a href="#📒简介" class="headerlink" title="📒简介"></a>📒简介</h3><p>React Helmet是一个HTML文档head管理工具，管理对文档头的所有更改。</p><h3 id="📒特点"><a href="#📒特点" class="headerlink" title="📒特点"></a>📒特点</h3><ul><li>支持所有有效的head标签: title、 base、 meta、 link、 script、 noscript、 和style。</li><li>支持body、 html 和 title 的属性</li><li>支持服务端渲染</li><li>嵌套组件覆盖重复的head标签更改。</li><li>在同一组件中定义时，将保留重复的head标签更改。(支持如”apple-touch-icon”的标签).</li><li>支持跟踪DOM更改的回调</li></ul><h3 id="📒安装"><a href="#📒安装" class="headerlink" title="📒安装"></a>📒安装</h3><p>Npm</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i react-helmet</span><br></pre></td></tr></table></figure><p>Yarn</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add react-helmet</span><br></pre></td></tr></table></figure><h3 id="📒💁‍♀️🌰简单示例"><a href="#📒💁‍♀️🌰简单示例" class="headerlink" title="📒💁‍♀️🌰简单示例"></a>📒💁‍♀️🌰简单示例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;Helmet&#125; <span class="keyword">from</span> <span class="string">&quot;react-helmet&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Application</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;application&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Helmet</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charSet</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">title</span>&gt;</span>My Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;canonical&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://mysite.com/example&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">Helmet</span>&gt;</span></span></span><br><span class="line"><span class="xml">            ...</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;再看react ssr 之前，我们先来看一个使用react ssr 实现的应用，感受一下它飞一般的渲染速度 &lt;a href=&quot;https://m.xin.com/&quot;&gt;https://m.xin.com/&lt;/a&gt; 看过之后我们再来看文章。&lt;/p&gt;
&lt;h2 id=&quot;📚导读&quot;&gt;&lt;a href=&quot;#📚导读&quot; class=&quot;headerlink&quot; title=&quot;📚导读&quot;&gt;&lt;/a&gt;📚导读&lt;/h2&gt;&lt;p&gt;关于服务端渲染（SSR）、客户端渲染（CSR）和 同构渲染，我在&lt;a href=&quot;https://juejin.cn/post/6854573217365884941&quot;&gt;next.js从入门到实战&lt;/a&gt;这篇文章中开头有详细的介绍，还不了解这三种渲染方式的可以简单了解一下。&lt;/p&gt;
&lt;p&gt;但只实现 SSR 没什么意义，技术上没有任何改进，否则 SPA 技术就不会出现😀。&lt;br&gt;但是单纯的 SPA 又不够完美，所以最好的方案就是这两种技术和体验的结合。但是要实现两种技术的结合，同时可以最大限度的重用代码（同构），减少开发维护成本，那就需要采用 react 或者 vue 等前端框架和node(ssr)相结合的方式来实现。&lt;/p&gt;
&lt;p&gt;如果我们使用react ssr 来实际开发项目，我们就需要一个完整的开发框架，next.js其实就是这种框架，类似的还有nuxt.js。那这种框架的实现原理是什么呢？&lt;br&gt;
    
    </summary>
    
    
    
      <category term="react" scheme="https://blueskyadd.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>javascript设计模式</title>
    <link href="https://blueskyadd.github.io/2021/10/02/javascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://blueskyadd.github.io/2021/10/02/javascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-10-02T12:02:17.000Z</published>
    <updated>2022-08-02T13:59:13.757Z</updated>
    
    <content type="html"><![CDATA[<p>设计模式是我们在 解决问题的时候针对特定问题给出的简洁而优化的处理方案，这里我跟大家简单聊一下前端中常用的三个设计模式 </p><blockquote><p>每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动。 —— Christopher Alexander</p></blockquote><h2 id="设计模式的核心思想"><a href="#设计模式的核心思想" class="headerlink" title="设计模式的核心思想"></a>设计模式的核心思想</h2><p> 设计模式出现的背景，是软件设计的复杂度日益飙升。软件设计越来越复杂的“罪魁祸首”，就是变化。比如我们写一个应用，这个应用以后完全不会发生迭代和优化，那么我们可以随便写，反正实现功能就行了，根本不用去考虑它的维护和升级。</p><p>但在实际开发中，不发生变化的代码可以说是不存在的。我们能做的只有将这个变化造成的影响最小化 —— 将变与不变分离，确保变化的部分灵活、不变的部分稳定。</p><p>这个过程，就叫“封装变化”；这样的代码，就是我们所谓的“健壮”的代码，它可以经得起变化的考验。而设计模式出现的意义，就是帮我们写出这样的代码。<br><span id="more"></span></p><h2 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h2><p>设计模式的分类其实是非常多的，在《设计模式：可复用面向对象软件的基础》这本书中根据“创建型”、“行为型”和“结构型”将设计模式分为23种。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e48f49319c6a41b2a381d327844a6010~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>设计模式会有很多，但是实际项目开发中并没有那么多，本片我们先简单来看一下项目中经常用到的单例和组合模式。</p><h3 id="📚单例模式"><a href="#📚单例模式" class="headerlink" title="📚单例模式"></a>📚单例模式</h3><p><strong>概念</strong></p><blockquote><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点，这样的模式就叫做单例模式。<br>这种模式其实挺常见，其中应用最广泛的要数 Redux 和 Vuex。无论是 Redux 和 Vuex，它们都实现了一个全局的 Store 用于存储应用的所有状态。这个 Store 的实现，正是单例模式的典型应用。</p></blockquote><p><strong>简单实现</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 准备一个构造函数</span></span><br><span class="line"><span class="comment">// 将来要 new 的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 准备一个单例模式函数</span></span><br><span class="line"><span class="comment">// 这个单例模式函数要把 Person 做成一个单例模式</span></span><br><span class="line"><span class="comment">// 将来再想要 new Person 的时候只要执行这个 singleton 函数就可以了</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">singleton</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> instance</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (!instance) &#123; <span class="comment">// 如果 instance 没有内容</span></span><br><span class="line">    <span class="comment">// 来到这里，证明 instance 没有内容</span></span><br><span class="line">    <span class="comment">// 给他赋值为 new Person</span></span><br><span class="line">      instance = <span class="keyword">new</span> Person()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 返回的永远都是第一次 new Person 的实例</span></span><br><span class="line">  <span class="comment">// 也就是永远都是一个实例</span></span><br><span class="line">  <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = singleton()</span><br><span class="line"><span class="keyword">const</span> p2 = singleton()</span><br><span class="line"><span class="built_in">console</span>.log(p1 === p2) <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><br>单例模式的核心代码很简单,其实就是判断一下，他曾经有没有 new 出来过对象,如果有，就还继续使用之前的那个对象，如果没有，那么就给你 new 一个.</p><h3 id="📚组合模式"><a href="#📚组合模式" class="headerlink" title="📚组合模式"></a>📚组合模式</h3><p><strong>概念</strong></p><blockquote><p>将对象以树形结构组织起来，以达成“部分－整体”的层次结构，使得客户端对单个对象和组合对象的使用具有一致性<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetHome</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    init () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;到家了&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenComputer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    init () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;打开电脑&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LookTv</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    init () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;看夏目友人帐&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p></blockquote><p>上面几个构造函数的创造的实例化对象的 启动方式 都一致，那么我们就可以把这几个函数以组合模式的情况书写，然后统一启动</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compose</span> </span>&#123;</span><br><span class="line">    <span class="title">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.compose = []</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加任务的方法</span></span><br><span class="line">    add (task) &#123;</span><br><span class="line">        <span class="built_in">this</span>.compose.push(task)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 一个执行任务的方法</span></span><br><span class="line">    execute () &#123;</span><br><span class="line">        <span class="built_in">this</span>.compose.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">            item.init()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们就用我们的组合模式构造函数来吧前面的几个功能组合起来</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Compose()</span><br><span class="line"><span class="comment">// 把所有要完成的任务都放在队列里面</span></span><br><span class="line">c.add(<span class="keyword">new</span> GetHome())</span><br><span class="line">c.add(<span class="keyword">new</span> OpenComputer)</span><br><span class="line">c.add(<span class="keyword">new</span> PlayGame)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接器动任务队列</span></span><br><span class="line">c.execute()</span><br><span class="line"><span class="comment">// 就会按照顺序执行三个对象中的 init 函数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;设计模式是我们在 解决问题的时候针对特定问题给出的简洁而优化的处理方案，这里我跟大家简单聊一下前端中常用的三个设计模式 &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动。 —— Christopher Alexander&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;设计模式的核心思想&quot;&gt;&lt;a href=&quot;#设计模式的核心思想&quot; class=&quot;headerlink&quot; title=&quot;设计模式的核心思想&quot;&gt;&lt;/a&gt;设计模式的核心思想&lt;/h2&gt;&lt;p&gt; 设计模式出现的背景，是软件设计的复杂度日益飙升。软件设计越来越复杂的“罪魁祸首”，就是变化。比如我们写一个应用，这个应用以后完全不会发生迭代和优化，那么我们可以随便写，反正实现功能就行了，根本不用去考虑它的维护和升级。&lt;/p&gt;
&lt;p&gt;但在实际开发中，不发生变化的代码可以说是不存在的。我们能做的只有将这个变化造成的影响最小化 —— 将变与不变分离，确保变化的部分灵活、不变的部分稳定。&lt;/p&gt;
&lt;p&gt;这个过程，就叫“封装变化”；这样的代码，就是我们所谓的“健壮”的代码，它可以经得起变化的考验。而设计模式出现的意义，就是帮我们写出这样的代码。&lt;br&gt;
    
    </summary>
    
    
    
      <category term="设计模式" scheme="https://blueskyadd.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>前端性能优化——浏览器缓存机制</title>
    <link href="https://blueskyadd.github.io/2021/09/02/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <id>https://blueskyadd.github.io/2021/09/02/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</id>
    <published>2021-09-02T12:00:08.000Z</published>
    <updated>2022-08-02T12:00:37.861Z</updated>
    
    <content type="html"><![CDATA[<h2 id="📚-一-浏览器缓存概览"><a href="#📚-一-浏览器缓存概览" class="headerlink" title="📚(一)浏览器缓存概览"></a>📚(一)浏览器缓存概览</h2><p>关于前端性能优化，一直是一个老生常谈的话题，在性能优化的诸多方法中，缓存可以说是性能优化中简单高效的一种优化方式了。</p><p>🙄那么浏览器缓存可以在哪方面给我们带来实质性的性能优化呢？</p><p>📣我们知道从我们从输入 URL 到页面加载完成，大致可以分为5个步骤</p><ol><li>DNS 域名解析</li><li>建立TCP 连接</li><li>HTTP 请求抛出</li><li>服务端处理请求，HTTP 响应返回</li><li>浏览器拿到响应数据，解析响应内容，把解析的结果展示给用户</li></ol><p>浏览器缓存可以帮助我们在第3和第5步骤中优化性能。利用浏览器存储机制，将一部分数据保存在客户端，从而减少对服务器的请求降低服务器的压力，提升效率。</p><p>📢📢一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷👍。</p><span id="more"></span><h2 id="📚-二-浏览器缓存的具体使用"><a href="#📚-二-浏览器缓存的具体使用" class="headerlink" title="📚(二)浏览器缓存的具体使用"></a>📚(二)浏览器缓存的具体使用</h2><p>对于我这种菜鸡而言，对于浏览器缓存机制的理解就是HTTP 缓存🥴，但查阅资料发现浏览器缓存可以分为4种，而且它们按照获取资源时请求的优先级依次排列如下😳：</p><ol><li>Memory Cache</li><li>Service Worker Cache</li><li>HTTP Cache</li><li>Push Cache</li></ol><p>我们依次来看一下吧，乌拉~</p><h3 id="1、🍜Memory-Cache"><a href="#1、🍜Memory-Cache" class="headerlink" title="1、🍜Memory Cache"></a>1、🍜Memory Cache</h3><p>Memory Cache 也就是内存中的缓存，主要包含的是当前中页面中已经抓取到的资源,例如页面上已经下载的样式、脚本、图片等，从效率上来说，它是响应速度最快的一种缓存。</p><p>那我们是否可以无限制的使用Memory Cache呢？答案是否定的，因为我们电脑的内存是很有限的。一般情况下Base64 格式的图片或者小一点的js文件会放在Memory Cache中，大一点的文件我们一般放在磁盘中，比如这张图：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f8d9a45c5508400b93e1f0b5d2731ad5~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>图中这些文件都是使用缓存中的数据</p><h3 id="2、-🍣Service-Worker-Cache"><a href="#2、-🍣Service-Worker-Cache" class="headerlink" title="2、 🍣Service Worker Cache"></a>2、 🍣Service Worker Cache</h3><p>Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。这是网上对它的介绍，后发现使用 Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。它可以帮我们实现离线缓存、消息推送和网络代理等功能。</p><p>Service Worker 的生命周期包括 install、active、working 三个阶段。一旦 Service Worker 被 install，它将始终存在，只会在 active 与 working 之间切换，除非我们主动终止它。这是它可以用来实现离线存储的重要先决条件。</p><p>📢📢发现一个很不错的Service Worker实践文章，有兴趣的小伙伴可以看一下<a href="https://www.cnblogs.com/xy2c/p/7501321.html">借助Service Worker和cacheStorage缓存及离线开发</a>👍</p><h3 id="3、🍤HTTP-Cache"><a href="#3、🍤HTTP-Cache" class="headerlink" title="3、🍤HTTP Cache"></a>3、🍤HTTP Cache</h3><p>HTTP 缓存是我们日常开发中最为熟悉的一种缓存机制，也是最主要、最具有代表性的缓存策略。HTTP缓存有多种规则，根据是否需要重新向服务器发起请求来分类，它可以分为强缓存和协商缓存。</p><p>强制缓存如果生效，不需要再和服务器发生交互，而对比缓存不管是否生效，都需要与服务端发生交互。<br>两类缓存规则可以同时存在，强制缓存优先级高于对比缓存，也就是说，当执行强制缓存的规则时，如果缓存生效，直接使用缓存，不再执行对比缓存规则。</p><h4 id="📙（1）强缓存"><a href="#📙（1）强缓存" class="headerlink" title="📙（1）强缓存"></a>📙（1）强缓存</h4><p>可以理解为无须验证的缓存策略，强制缓存。对强缓存来说，响应头中有两个字段 Expires/Cache-Control 来表明规则。<br><strong>Expires</strong><br>Expires用来设置过期时间，超过这个时间点就表示资源过期。但是会有一个问题，由于这个时间使用时间戳表示，客户端和服务端可能会存在差别，这可能造成缓存生命周期出错。在HTTP/1.1中加入了Cache-Control，并且两个同时存在时也是 Cache-Control 的优先级更高。<br><strong>Cache</strong>-Control<br>Cache-Control 有几个值：</p><p>🎈1. <strong>private</strong>:             客户端可以缓存，表明响应只能被单个用户（可能是操作系统用户、浏览器用户）缓存，是非共享的，不能被代理服务器缓存。</p><p>🎈2. <strong>public</strong>:              客户端和代理服务器都可缓存</p><p>🎈3. <strong>max-age=xxx</strong>:   缓存的内容将在 xxx 秒后失效</p><p>🎈4. <strong>no-cache</strong>:          需要使用对比缓存来验证缓存数据</p><p>🎈5. <strong>no-store</strong>:           禁止缓存，每次请求都要向服务器重新获取数据</p><p>🎈6. <strong>s-maxage</strong>         但仅适用于共享缓存       </p><h4 id="📙（2）-协商缓存"><a href="#📙（2）-协商缓存" class="headerlink" title="📙（2） 协商缓存"></a>📙（2） 协商缓存</h4><p>📌浏览器与服务器合作之下的缓存策略</p><p>缓存的资源到期了，并不意味着资源内容发生了改变，如果和服务器上的资源没有差异，实际上没有必要再次请求。客户端和服务器端通过某种验证机制验证当前请求资源是否可以使用缓存。</p><p>如果服务端提示缓存资源未改动（Not Modified），资源会被重定向到浏览器缓存，这种情况下网络请求对应的状态码是 304。反之返回 200 就相当于重新请求了一遍资源并替换旧资源。</p><p>我们具体来看一下协商缓存时的请求头Last-modified/If-Modified-Since 和 Etag/If-None-Match；</p><h5 id="I、🎈Last-modified-If-Modified-Since"><a href="#I、🎈Last-modified-If-Modified-Since" class="headerlink" title="I、🎈Last-modified/If-Modified-Since"></a>I、🎈Last-modified/If-Modified-Since</h5><p>Last-Modified 是一个时间戳，它表示服务器端资源的最后修改时间。<br> 如果我们启用了协商缓存，它会在首次请求时随着 Response Headers 返回。第一次请求之后，浏览器记录这个时间，再次请求时，请求头部带上 If-Modified-Since 即为之前记录下的时间。<br>服务器端收到带 If-Modified-Since 的请求后会去和资源的最后修改时间对比。若修改过就返回最新资源，状态码 200，若没有修改过则返回 304;</p><p>📣📣但其实使用Last-modified会有弊端存在，由于这个时间是浏览器自己记录的。<br>🍒由于Last-modified 只能精确到秒，如果我们修改文件的速度过快（100ms)那么，浏览器旧纪录不到这个时间，导致文件没有实时更新。<br>🍒或者我们编辑了文件，但是没有修改内容再次提交时更新了Last-Modified ，这就导致服务器会有一次完整的响应请求</p><p>那么怎么解决这个问题呢？Etag 作为 Last-Modified 的补充出现了</p><h5 id="II、🎈Etag"><a href="#II、🎈Etag" class="headerlink" title="II、🎈Etag"></a>II、🎈Etag</h5><p>Etag 是由服务器为每个资源生成的唯一的hash字符串，这个标识字符串是基于文件内容编码的，只要文件内容不同，它们对应的 Etag 就是不同的，反之亦然。因此 Etag 能够精准地感知文件的变化。</p><p>📣📣📣注意：实际使用 ETag/Last-modified 要注意保持一致性，做负载均衡和反向代理的话可能会出现不一致的情况。计算 ETag 也是需要占用资源的，如果修改不是过于频繁，看自己的需求用 Cache-Control 是否可以满足。</p><h3 id="4、🥣Push-Cache"><a href="#4、🥣Push-Cache" class="headerlink" title="4、🥣Push Cache"></a>4、🥣Push Cache</h3><p>“推送缓存”是针对HTTP/2标准下的推送资源设定的。推送缓存是session级别的，当 session 终止时，缓存也随之释放。在以上三种缓存都没有的情况下，它才会被使用。Push Cache是HTTP2新出的特性，他也将是未来未来的趋势，push cache的特性这里简单介绍：</p><ul><li>Push Cache 是缓存的最后一道防线。浏览器只有在 Memory Cache、HTTP Cache 和 Service Worker Cache 均未命中的情况下才会去询问 Push Cache。</li><li>Push Cache 是一种存在于会话阶段的缓存，当 session 终止时，缓存也随之释放。<br>不同的页面只要共享了同一个 HTTP2 连接，那么它们就可以共享同一个 Push Cache。<br>这里发个😶😶<a href="https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/">传送门</a></li></ul><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://www.cnblogs.com/vajoy/p/5341664.html">https://www.cnblogs.com/vajoy/p/5341664.html</a><br/><br><a href="https://www.cnblogs.com/chenqf/p/6386163.html">https://www.cnblogs.com/chenqf/p/6386163.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;📚-一-浏览器缓存概览&quot;&gt;&lt;a href=&quot;#📚-一-浏览器缓存概览&quot; class=&quot;headerlink&quot; title=&quot;📚(一)浏览器缓存概览&quot;&gt;&lt;/a&gt;📚(一)浏览器缓存概览&lt;/h2&gt;&lt;p&gt;关于前端性能优化，一直是一个老生常谈的话题，在性能优化的诸多方法中，缓存可以说是性能优化中简单高效的一种优化方式了。&lt;/p&gt;
&lt;p&gt;🙄那么浏览器缓存可以在哪方面给我们带来实质性的性能优化呢？&lt;/p&gt;
&lt;p&gt;📣我们知道从我们从输入 URL 到页面加载完成，大致可以分为5个步骤&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;DNS 域名解析&lt;/li&gt;
&lt;li&gt;建立TCP 连接&lt;/li&gt;
&lt;li&gt;HTTP 请求抛出&lt;/li&gt;
&lt;li&gt;服务端处理请求，HTTP 响应返回&lt;/li&gt;
&lt;li&gt;浏览器拿到响应数据，解析响应内容，把解析的结果展示给用户&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;浏览器缓存可以帮助我们在第3和第5步骤中优化性能。利用浏览器存储机制，将一部分数据保存在客户端，从而减少对服务器的请求降低服务器的压力，提升效率。&lt;/p&gt;
&lt;p&gt;📢📢一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷👍。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>前端的单点登录👀</title>
    <link href="https://blueskyadd.github.io/2021/07/21/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"/>
    <id>https://blueskyadd.github.io/2021/07/21/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/</id>
    <published>2021-07-21T07:41:15.000Z</published>
    <updated>2022-08-02T11:57:01.315Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、什么是单点登录"><a href="#一、什么是单点登录" class="headerlink" title="一、什么是单点登录"></a>一、什么是单点登录</h3><p>单点登录（Single Sign On），简称为 SSO，是目前比较流行的企业业务整合的解决方案之一。<strong>SSO的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。</strong></p><blockquote><p>SSO一般都需要一个独立的认证中心（passport），子系统的登录均得通过passport。子系统本身将不参与登录操作，当一个系统成功登录以后，passport将会颁发一个令牌给各个子系统，子系统可以拿着令牌会获取各自的受保护资源，为了减少频繁认证，各个子系统在被passport授权以后，会建立一个局部会话，在一定时间内可以无需再次向passport发起认证。👻<br><span id="more"></span></p></blockquote><hr><h3 id="二、单点登录的实现"><a href="#二、单点登录的实现" class="headerlink" title="二、单点登录的实现"></a>二、单点登录的实现</h3><h4 id="1、同域名下的单点登录"><a href="#1、同域名下的单点登录" class="headerlink" title="1、同域名下的单点登录"></a>1、同域名下的单点登录</h4><p>一个企业一般情况下只有一个域名，通过二级域名区分不同的系统，比如说我们公司的域名a.com ，同时有两个业务系统分别为：qa.a.com和qa2.a.com。那么需要再做单点登录（SSO），需要一个登录系统，叫做：sso.a.com。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ca234a780ed47ed8ea1379c80347420~tplv-k3u1fbpfcp-watermark.awebp"/><br>可以在sso.a.com中登录，并在将cookie设置在顶级域名中,这样所有的子域应用就都可以访问到这个 Cookie 了.实现了简单的单点登录</p><h4 id="2、不同域名下的单点登录"><a href="#2、不同域名下的单点登录" class="headerlink" title="2、不同域名下的单点登录"></a>2、不同域名下的单点登录</h4><h5 id="（1）统一认证中心方案（CAS标准方案🥴）"><a href="#（1）统一认证中心方案（CAS标准方案🥴）" class="headerlink" title="（1）统一认证中心方案（CAS标准方案🥴）"></a>（1）统一认证中心方案（CAS标准方案🥴）</h5><p>看到很有意思的例子：<br>例如你去食堂吃饭，食堂打饭的阿姨<a href="www.qiandu.com">www.qiandu.com</a>告诉你，不收现金。并且告诉你，你去门口找换票的（passport.com）换小票。于是你换完票之后，再去找食堂阿姨，食堂阿姨拿着你的票，问门口换票的，这个票是真的吗？换票的说，是真的，于是给你打饭了。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/785c01cf8de946d7abb50193640742d4~tplv-k3u1fbpfcp-watermark.awebp" alt="image.png"></p><ul><li>第一步：用户访问<a href="www.qiandu.com">www.qiandu.com</a>。过滤器判断用户是否登录，没有登录，则重定向（302）到网站<a href="http://passport.com。">http://passport.com。</a></li><li>第二步：重定向到passport.com，输入用户名密码。passport.com将用户登录的信息记录到服务器的session中。</li><li>第三步：passport.com给浏览器发送一个特殊的凭证，浏览器将凭证交给<a href="www.qiandu.com">www.qiandu.com</a>，<a href="www.qiandu.com">www.qiandu.com</a>则拿着浏览器交 给他的凭证去passport.com验证凭证是否有效，从而判断用户是否登录成功。</li><li>第四步：登录成功，浏览器与网站之间进行正常的访问。</li></ul><h5 id="2-LocalStorage跨域实现"><a href="#2-LocalStorage跨域实现" class="headerlink" title="(2)LocalStorage跨域实现"></a>(2)LocalStorage跨域实现</h5><p>前端可以通过 iframe+postMessage() 方式，将同一份 Token 写入到了多个域下的 LocalStorage 中，前端每次在向后端发送请求之前，都会主动从 LocalStorage 中读取 Token 并在请求中携带，这样就实现了同一份 Token 被多个域所共享。<br>示例代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 token</span></span><br><span class="line"><span class="keyword">var</span> token = result.data.token;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态创建一个不可见的iframe，在iframe中加载一个跨域HTML</span></span><br><span class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">&quot;iframe&quot;</span>);</span><br><span class="line">iframe.src = <span class="string">&quot;http://app1.com/localstorage.html&quot;</span>;</span><br><span class="line"><span class="built_in">document</span>.body.append(iframe);</span><br><span class="line"><span class="comment">// 使用postMessage()方法将token传递给iframe</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    iframe.contentWindow.postMessage(token, <span class="string">&quot;http://app1.com&quot;</span>);</span><br><span class="line">&#125;, <span class="number">4000</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    iframe.remove();</span><br><span class="line">&#125;, <span class="number">6000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这个iframe所加载的HTML中绑定一个事件监听器，当事件被触发时，把接收到的token数据写入localStorage</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">localStorage</span>.setItem(<span class="string">&#x27;token&#x27;</span>, event.data)</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><br>系统在被passport授权以后，会建立一个局部会话，在一定时间内可以无需再次向passport发起认证。👻</p><p>参考链接<br><a href="https://blog.csdn.net/ban_tang/article/details/80015946">https://blog.csdn.net/ban_tang/article/details/80015946</a><br><a href="https://www.jianshu.com/p/75edcc05acfd">https://www.jianshu.com/p/75edcc05acfd</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、什么是单点登录&quot;&gt;&lt;a href=&quot;#一、什么是单点登录&quot; class=&quot;headerlink&quot; title=&quot;一、什么是单点登录&quot;&gt;&lt;/a&gt;一、什么是单点登录&lt;/h3&gt;&lt;p&gt;单点登录（Single Sign On），简称为 SSO，是目前比较流行的企业业务整合的解决方案之一。&lt;strong&gt;SSO的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;SSO一般都需要一个独立的认证中心（passport），子系统的登录均得通过passport。子系统本身将不参与登录操作，当一个系统成功登录以后，passport将会颁发一个令牌给各个子系统，子系统可以拿着令牌会获取各自的受保护资源，为了减少频繁认证，各个子系统在被passport授权以后，会建立一个局部会话，在一定时间内可以无需再次向passport发起认证。👻&lt;br&gt;
    
    </summary>
    
    
    
      <category term="单点登录" scheme="https://blueskyadd.github.io/tags/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>什么是单元测试，如何去写一个单元测试</title>
    <link href="https://blueskyadd.github.io/2021/06/20/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <id>https://blueskyadd.github.io/2021/06/20/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</id>
    <published>2021-06-20T02:11:17.000Z</published>
    <updated>2021-09-02T02:25:35.243Z</updated>
    
    <content type="html"><![CDATA[<p>相信单元测试是属于那种没有用过也听过的技术（<em>如果你是大佬，听过也用过，欢迎提出宝贵的意见</em>🧎‍♀️🧎‍♂️）。那么到底什么是单元测试，单元测试在实际项目开发中能给我们带来什么样的好处？我们站在前端开发的角度一起来聊一聊单元测试。</p><h3 id="📚（一）什么是单元测试"><a href="#📚（一）什么是单元测试" class="headerlink" title="📚（一）什么是单元测试"></a>📚（一）什么是单元测试</h3><h5 id="📢单元测试概念"><a href="#📢单元测试概念" class="headerlink" title="📢单元测试概念"></a>📢单元测试概念</h5><blockquote><p>单元测试是指对软件中最小可测单元进行检查和验证；c语言中单元指一个函数，java中指一个类。图形化软件中可以指一个窗口或者一个菜单。总的来说，单元就是认为规定最小的被测试模块。<br>这个便是对百度百科上对单元测试的介绍，那么对于我们前端来说单元测试是用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作。</p></blockquote><h5 id="大多数单元测试包括四个主体："><a href="#大多数单元测试包括四个主体：" class="headerlink" title="大多数单元测试包括四个主体："></a>大多数单元测试包括四个主体：</h5><ul><li>测试套件describe、</li><li>测试用例it、</li><li>判定条件expect、</li><li>断言结果toEqual。<span id="more"></span><h5 id="什么不是单元测试"><a href="#什么不是单元测试" class="headerlink" title="什么不是单元测试"></a>什么不是单元测试</h5>在了解了什么是单元测试的基础上，那么什么不是单元测试呢？在《修改代码艺术》一书上有这样的介绍：</li><li>需要访问数据库的测试不是单元测试</li><li>需要访问网络的测试不是单元测试</li><li>需要访问文件系统的测试不是单元测试</li></ul><p><em>以上便是对单元测试概念的简单介绍，那么为什么要使用单元测试,单元测试有什么优势，不考虑回报的程序员不是好的程序员。</em></p><hr><h3 id="📚（二）单元测试对我们开发程序有什么好处"><a href="#📚（二）单元测试对我们开发程序有什么好处" class="headerlink" title="📚（二）单元测试对我们开发程序有什么好处"></a>📚（二）单元测试对我们开发程序有什么好处</h3><ul><li><p><strong>首先是一个前端单元测试的根本性原由</strong>：JavaScript 是动态语言，缺少类型检查，编译期间无法定位到错误; JavaScript 宿主的兼容性问题。比如 DOM 操作在不同浏览器上的表现。</p></li><li><p><strong>正确性</strong>：测试可以验证代码的正确性，在上线前做到心里有底。</p></li><li><p><strong>自动化</strong>：当然手工也可以测试，通过console可以打印出内部信息，但是这是一次性的事情，下次测试还需要从头来过，效率不能得到保证。通过编写测试用例，可以做到一次编写，多次运行。</p></li><li><p><strong>解释性</strong>：测试用例用于测试接口、模块的重要性，那么在测试用例中就会涉及如何使用这些API。其他开发人员如果要使用这些API，那阅读测试用例是一种很好地途径，有时比文档说明更清晰。</p></li><li><p><strong>驱动开发，指导设计</strong>：代码被测试的前提是代码本身的可测试性，那么要保证代码的可测试性，就需要在开发中注意API的设计，TDD将测试前移就是起到这么一个作用。</p></li><li><p><strong>保证重构</strong>：互联网行业产品迭代速度很快，迭代后必然存在代码重构的过程，那怎么才能保证重构后代码的质量呢？有测试用例做后盾，就可以大胆的进行重构。</p></li></ul><p>我们知道 高覆盖率的单元测试，可以保证每次上线bug率大大降低，也是代码重构的基础。很多老项目，开发人员离职、新接手的人员不敢重构，慢慢称为团队负担、又不能下线，就是因为没有单元测试，改一点都怕出现不可测的bug。简单来说，也可以概括为以下几点</p><ol><li>提高代码质量</li><li>减少bug，快速定位bug</li><li>放心地修改、重构</li><li>单元测试不但会使你的工作完成得更轻松。而且会令你的设计会变得更好，甚至大大减少你花在 调试上面的时间</li></ol><hr><h3 id="📚（三）如何编写单元测试用例"><a href="#📚（三）如何编写单元测试用例" class="headerlink" title="📚（三）如何编写单元测试用例"></a>📚（三）如何编写单元测试用例</h3><p>如何编写单元测试用例，单元测试用例的原则是什么:</p><ul><li>测试代码时，只考虑测试，不考虑内部实现；</li><li>数据尽量模拟现实，越靠近现实越好，</li><li>充分考虑数据的边界条件下·</li><li>对重点、复杂、核心代码、重点测试</li><li>利用AOP（面向切面编程），减少测试代码，避免无用功能</li><li>测试、功能开发相结合，有利于设计和代码重构</li></ul><p><em>🔎插一个小知识点：那么这里提到的AOP是什么意思，AOP是Aspect Oriented Program的首字母缩写意思是面向切面编程，这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。<br/><br>📌一般而言，我们管切入到指定类指定方法的代码片段称为切面，而切入到哪些类、哪些方法则叫切入点。有了AOP，我们就可以把几个类共有的代码，抽取到一个切片中，等到需要时再切入对象中去，从而改变其原有的行为。</em></p><p> <strong>再简单了解了单元测试之后我们将其带入到我们实际项目开发中，来尝试一下</strong></p><hr><h3 id="📚（四）组件化后，组件哪部分最具测试价值？（以React为例）"><a href="#📚（四）组件化后，组件哪部分最具测试价值？（以React为例）" class="headerlink" title="📚（四）组件化后，组件哪部分最具测试价值？（以React为例）"></a>📚（四）组件化后，组件哪部分最具测试价值？（以React为例）</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8fc5d7ccad146bfa14b85dfb5c991b6~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h5 id="1-Component"><a href="#1-Component" class="headerlink" title="1. Component"></a>1. Component</h5><p>Component 应着重关注render以及副作用，同时业务逻辑的处理过程，都应该尽量提取到Hooks和Utils文件中。因此，对于Component的测试，我们完全可以将重心主要放在以下这两方面问题上：</p><ul><li>组件是否正常渲染了？</li><li>组件副作用是否正常处理了？</li></ul><h5 id="2-Hooks"><a href="#2-Hooks" class="headerlink" title="2. Hooks"></a>2. Hooks</h5><p>如何测试React Hooks，社区目前已有相对成熟的解决方案，即@testing-library/react-hooks + react-test-renderer[2]。通过这两个依赖，开发人员可以很轻松的mock出Hooks执行所依赖的环境，把store的数据当作hooks的输入，关注在hooks内的业务逻辑，即可把Hooks当作纯方法（Pure Function）来进行测试。</p><h5 id="3-Redux"><a href="#3-Redux" class="headerlink" title="3. Redux"></a>3. Redux</h5><p>对于Redux，如果项目在使用 Redux Toolkit 的话，事情会简单很多，开发人员只需要关注Dispatch的Actions即可。但如果Actions和Reducer是分开编写，则需要针对性处理</p><h5 id="4-Service"><a href="#4-Service" class="headerlink" title="4. Service"></a>4. Service</h5><p>不同项目或团队对Service的定义各不相同，这里我们要聊的主要指负责处理HTTP请求的request和response，以及相应的异常处理的数据层。Service主要的功能是对接Action，因而理想情况下Service只需要包含与API通信的代码，这种情况下，UT可有可无。但一些场景下，如果项目中没有使用BFF承担数据处理的角色，后端也没能提供完全符合前端数据结构需求的接口时，不可避免的，开发人员需要在此处完善数据处理的逻辑，以便获取清洗或聚合后的数据，因而这种情况下，UT覆盖是非常有必要的。</p><h5 id="5-Utils-Helpers"><a href="#5-Utils-Helpers" class="headerlink" title="5. Utils/Helpers"></a>5. Utils/Helpers</h5><p>Utils/Helpers主要包含以下几类类型：<br>数据结构的转化，各种convert工具函数<br>数据结构的处理，比如数据提取、合并压缩、整理工具函数<br>公共的工具函数<br>根据我们目前的项目习惯，当一段逻辑需要在Utils/Helpers中实现时，那么它一定是纯函数，其中多数情况又会包含一定程度的数据处理逻辑，所以基本都需要UT覆盖</p><p>在了解了项目组件哪些部分最具有测试价值之后，我们就要上手了，跃跃欲试中🤸‍♀️🤸‍♂️</p><hr><h3 id="📚（五）如何让我们的测试用例更易编写、维护？"><a href="#📚（五）如何让我们的测试用例更易编写、维护？" class="headerlink" title="📚（五）如何让我们的测试用例更易编写、维护？"></a>📚（五）如何让我们的测试用例更易编写、维护？</h3><p>举个例子💁‍🌰，先看代码，看不看得懂不重要🧎‍♀️，我们先来了解一下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// production code</span></span><br><span class="line"><span class="keyword">const</span> computeTotalAmount = <span class="function">(<span class="params">products</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> products.reduce(<span class="function">(<span class="params">total, product</span>) =&gt;</span> total + product.price, <span class="number">0</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// testing code</span></span><br><span class="line">it(<span class="string">&#x27;should return summed up total amount 1000 when there are three products priced 200, 300, 500&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// given - 准备数据</span></span><br><span class="line">  <span class="keyword">const</span> products = [</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&#x27;nike&#x27;</span>, <span class="attr">price</span>: <span class="number">200</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&#x27;adidas&#x27;</span>, <span class="attr">price</span>: <span class="number">300</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&#x27;lining&#x27;</span>, <span class="attr">price</span>: <span class="number">500</span> &#125;,</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line">  <span class="comment">// when - 调用被测函数</span></span><br><span class="line">  <span class="keyword">const</span> result = computeTotalAmount(products)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// then - 断言结果</span></span><br><span class="line">  expect(result).toBe(<span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>可以看到我们首先定义了一个computeTotalAmount的待测函数，it包裹了我们的测试用例。在测试用例中，首先第一步：<strong>准备数据</strong>，然后<strong>调用被测函数</strong>，最后<strong>输出断言结果</strong>。 可以看到这样的结果清晰明了。<br/><br><strong>好的单元测试应该遵循AAA的模式，AAA模式：编排（Arrange），执行（Act），断言（Assert）。可以让你写出比较清晰的测试结构，既易于阅读，也易于编写</strong></p><h5 id="编写单元有以下几个编写原则："><a href="#编写单元有以下几个编写原则：" class="headerlink" title="编写单元有以下几个编写原则："></a>编写单元有以下几个编写原则：</h5><ul><li>🎈mock数据集中管理，考虑mock数据极端情况</li><li>🎈只关注输入输出，不关注内部实现</li><li>🎈一个单元测试只测一个业务场景<ul><li>如此你才能给它一个好的描述，这个测试才能保护这个特定的业务场景，挂了的时候能给你细致到输入输出级别的  业务反馈。</li></ul></li><li>🎈表达力极强，不包含逻辑<ul><li>表达力强的测试，能在失败的时候给你非常迅速的反馈，看到测试时，你就知道它测的业务点是啥 测试挂掉时，能清楚地知道失败的业务场景、期望数据与实际输出的差异，跟写声明式的代码一样的道理，测试需要都是简单的声明：准备数据、调用函数、断言，让人一眼就明白这个测试在测什么。如果含有逻辑，你读的时候就要多花时间理解；一旦测试挂掉，你咋知道是实现挂了还是测试本身就挂了呢？</li></ul></li><li><p>🎈运行速度快</p><ul><li>可以使用mock适当隔离掉三方的依赖，将依赖、集成等耗时、依赖三方返回的地方放到更高层级的测试中，有策略性地去做</li></ul></li><li><p>🎈隔离性</p><ul><li>单元测试是对代码独立的单元进行测试，这个独立的意思不是说这个函数（单元）不会调用另外一个函数（单元），而是说我们在测试这个函数的时候如果它有调用到其它的函数我们就需要mock它们，从而将我们的测试逻辑只放在被测试函数的逻辑上，不会受到其它依赖函数的影响</li></ul></li></ul><p>最后我们带入项目实际开发一下吧</p><hr><h3 id="📚（六）react单元测试框架enzyme实际应用"><a href="#📚（六）react单元测试框架enzyme实际应用" class="headerlink" title="📚（六）react单元测试框架enzyme实际应用"></a>📚（六）react单元测试框架enzyme实际应用</h3><h5 id="1-测试工具：主要用到的测试工具是-jest-和-enzyme"><a href="#1-测试工具：主要用到的测试工具是-jest-和-enzyme" class="headerlink" title="1. 测试工具：主要用到的测试工具是 jest 和 enzyme"></a>1. 测试工具：主要用到的测试工具是 jest 和 enzyme</h5><h5 id="2-待测组件-可以添加删除的一个简单列表；"><a href="#2-待测组件-可以添加删除的一个简单列表；" class="headerlink" title="2. 待测组件:可以添加删除的一个简单列表；"></a>2. 待测组件:可以添加删除的一个简单列表；</h5><h5 id="3-我们想要测试四点："><a href="#3-我们想要测试四点：" class="headerlink" title="3. 我们想要测试四点："></a>3. 我们想要测试四点：</h5><p>1、组件渲染</p><p>2、渲染时初始待办事项的展示</p><p>3、我们可以创建一个新的待办事项然后返回三个待办事项</p><p>4、我们可以删除一个初始的待办事项并且只留下一个</p><p>上代码ing…..</p><p>上组件👩‍🌾👩‍🌾👩‍🌾<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useRef &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> Todo = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> [list, setList] = useState([</span><br><span class="line">        &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">item</span>: <span class="string">&quot;Fix bugs&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">item</span>: <span class="string">&quot;Take out the trash&quot;</span> &#125;</span><br><span class="line">    ]);</span><br><span class="line">    <span class="keyword">const</span> todoRef = useRef();</span><br><span class="line">    <span class="keyword">const</span> removeTodo = <span class="function"><span class="params">id</span> =&gt;</span> &#123;</span><br><span class="line">        setList(list.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.id !== id));</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> addList = <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> id = list.length + <span class="number">1</span>;</span><br><span class="line">        setList([</span><br><span class="line">            ...list,</span><br><span class="line">            &#123;</span><br><span class="line">                id,</span><br><span class="line">                <span class="attr">item</span>: data</span><br><span class="line">            &#125;</span><br><span class="line">        ]);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> handleNewTodo = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">        e.preventDefault();</span><br><span class="line">        <span class="keyword">const</span> item = todoRef.current;</span><br><span class="line">        addList(item.value);</span><br><span class="line">        item.value = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;col-md-6&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Add Todo<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">form</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;col-md-6&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">                        <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                            <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                            <span class="attr">autoFocus</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                            <span class="attr">ref</span>=<span class="string">&#123;todoRef&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                            <span class="attr">placeholder</span>=<span class="string">&quot;Enter a task&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                            <span class="attr">className</span>=<span class="string">&quot;form-control&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                            <span class="attr">data-testid</span>=<span class="string">&quot;input&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                        /&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;col-md-6&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">                        <span class="tag">&lt;<span class="name">button</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                            <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                            <span class="attr">onClick</span>=<span class="string">&#123;handleNewTodo&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                            <span class="attr">className</span>=<span class="string">&quot;btn btn-primary&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                        &gt;</span></span></span><br><span class="line"><span class="xml">                        Add Task</span></span><br><span class="line"><span class="xml">                        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;row todo-list&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;col-md-6&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Lists<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    &#123;!list.length ? (</span></span><br><span class="line"><span class="xml">                        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;no-task&quot;</span>&gt;</span>No task!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    ) : (</span></span><br><span class="line"><span class="xml">                        <span class="tag">&lt;<span class="name">ul</span> <span class="attr">data-testid</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">                            &#123;list.map(todo =&gt; &#123;</span></span><br><span class="line"><span class="xml">                                return (</span></span><br><span class="line"><span class="xml">                                    <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;todo.id&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">                                        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">                                            <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;todo.item&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">                                            <span class="tag">&lt;<span class="name">button</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                                                <span class="attr">className</span>=<span class="string">&quot;btn btn-danger&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                                                <span class="attr">data-testid</span>=<span class="string">&quot;delete-button&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                                                <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> removeTodo(todo.id)&#125;</span></span><br><span class="line"><span class="xml">                                            &gt;</span></span><br><span class="line"><span class="xml">                                                删除</span></span><br><span class="line"><span class="xml">                                            <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">                                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">                                    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">                                );</span></span><br><span class="line"><span class="xml">                            &#125;)&#125;</span></span><br><span class="line"><span class="xml">                        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    )&#125;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Todo;</span><br></pre></td></tr></table></figure></p><p>组件很简单，一个添加一个删除的简单功能，但是直接看代码会感觉乱七八糟的，一点也不清晰明了，那么我们来看测试用例，乌拉……<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; shallow, mount &#125; <span class="keyword">from</span> <span class="string">&quot;enzyme&quot;</span>;</span><br><span class="line"><span class="comment">//import &#x27;jsdom-global/register&#x27;;//在测试单测完成度时打开</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&quot;./App&quot;</span>;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">&quot;Todo&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//将一个组件渲染成虚拟DOM对象，但是只渲染第一层，不渲染所有子组件，所以处理速度非常快</span></span><br><span class="line">    it(<span class="string">&quot;组件渲染&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        shallow(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>);</span><br><span class="line">    &#125;) </span><br><span class="line">    it(<span class="string">&quot;查询li个数&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> wrapper = mount(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>);</span><br><span class="line">      <span class="comment">//mount可以渲染组件APP下的所有子组件</span></span><br><span class="line">      expect(wrapper.find(<span class="string">&quot;li&quot;</span>)).toHaveLength(<span class="number">2</span>);</span><br><span class="line">      <span class="comment">//我们通过find找到元素li,因为有组件中list有两条默认数据，所以元素li应该是有两个，我们直接输出断言结果。</span></span><br><span class="line">    &#125;);</span><br><span class="line">    it(<span class="string">&quot;调用addList&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> wrapper = mount(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>);</span><br><span class="line">      wrapper.find(<span class="string">&quot;input&quot;</span>).instance().value = <span class="string">&quot;新增加一个&quot;</span>;</span><br><span class="line">      <span class="comment">//这里同理找到input元素，并给其赋值“新增加一个”</span></span><br><span class="line">      expect(wrapper.find(<span class="string">&quot;input&quot;</span>).instance().value).toEqual(<span class="string">&quot;新增加一个&quot;</span>);</span><br><span class="line">      <span class="comment">//赋值完成后，我们找到对应的input元素，查询input的值，增加断言判断是否为“新增加一个”</span></span><br><span class="line">      wrapper.find(<span class="string">&#x27;[type=&quot;submit&quot;]&#x27;</span>).simulate(<span class="string">&quot;click&quot;</span>);</span><br><span class="line">      <span class="comment">//找到type为submit的button，触发click事件</span></span><br><span class="line">      expect(wrapper.find(<span class="string">&quot;li&quot;</span>)).toHaveLength(<span class="number">3</span>);</span><br><span class="line">      <span class="comment">//断言li的长度是否为3</span></span><br><span class="line">      expect(wrapper.find(<span class="string">&quot;li div span&quot;</span>).last().text()).toEqual(<span class="string">&quot;新增加一个&quot;</span>);</span><br><span class="line">      <span class="comment">//断言最后一个li(新添加的那一个)，其中子元素span的值是否为“新增加一个”</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    it(<span class="string">&quot;调用removeTodo&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> wrapper = mount(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>);</span><br><span class="line">      wrapper.find(<span class="string">&quot;li button&quot;</span>).first().simulate(<span class="string">&#x27;click&#x27;</span>);</span><br><span class="line">      <span class="comment">//找到以一个li中的button,触发click事件</span></span><br><span class="line">      expect(wrapper.find(<span class="string">&quot;li&quot;</span>)).toHaveLength(<span class="number">1</span>);</span><br><span class="line">      <span class="comment">//触发删除按钮后，查询li的长度，应该为1</span></span><br><span class="line">      expect(wrapper.find(<span class="string">&quot;li div span&quot;</span>).last().text()).toEqual(<span class="string">&quot;Take out the trash&quot;</span>);</span><br><span class="line">      <span class="comment">//最后查询第一个li的子元素span, 它的值是否为Take out the trash</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>那么我们运行一下<br><code>yarn test</code></p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c018e4b1bf1439f9f65a0a2200713ce~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>可以看到每个测试用例的运行时间</p><p>我们再来试一下单测覆盖度<br><code>jest --coverage</code></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d8fd53578804b63ba57e1f56899fd87~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>可以看到我们的覆盖率（lines）是100%的</p><blockquote><p>那么以上便是对单元测试的简单介绍，这里附上最后这个例子🌰的 📎<a href="https://github.com/blueskyadd/enzyme-action-test.git">github地址</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相信单元测试是属于那种没有用过也听过的技术（&lt;em&gt;如果你是大佬，听过也用过，欢迎提出宝贵的意见&lt;/em&gt;🧎‍♀️🧎‍♂️）。那么到底什么是单元测试，单元测试在实际项目开发中能给我们带来什么样的好处？我们站在前端开发的角度一起来聊一聊单元测试。&lt;/p&gt;
&lt;h3 id=&quot;📚（一）什么是单元测试&quot;&gt;&lt;a href=&quot;#📚（一）什么是单元测试&quot; class=&quot;headerlink&quot; title=&quot;📚（一）什么是单元测试&quot;&gt;&lt;/a&gt;📚（一）什么是单元测试&lt;/h3&gt;&lt;h5 id=&quot;📢单元测试概念&quot;&gt;&lt;a href=&quot;#📢单元测试概念&quot; class=&quot;headerlink&quot; title=&quot;📢单元测试概念&quot;&gt;&lt;/a&gt;📢单元测试概念&lt;/h5&gt;&lt;blockquote&gt;
&lt;p&gt;单元测试是指对软件中最小可测单元进行检查和验证；c语言中单元指一个函数，java中指一个类。图形化软件中可以指一个窗口或者一个菜单。总的来说，单元就是认为规定最小的被测试模块。&lt;br&gt;这个便是对百度百科上对单元测试的介绍，那么对于我们前端来说单元测试是用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;大多数单元测试包括四个主体：&quot;&gt;&lt;a href=&quot;#大多数单元测试包括四个主体：&quot; class=&quot;headerlink&quot; title=&quot;大多数单元测试包括四个主体：&quot;&gt;&lt;/a&gt;大多数单元测试包括四个主体：&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;测试套件describe、&lt;/li&gt;
&lt;li&gt;测试用例it、&lt;/li&gt;
&lt;li&gt;判定条件expect、&lt;/li&gt;
&lt;li&gt;断言结果toEqual。
    
    </summary>
    
    
    
      <category term="单元测试" scheme="https://blueskyadd.github.io/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
      <category term="react" scheme="https://blueskyadd.github.io/tags/react/"/>
    
      <category term="hooks" scheme="https://blueskyadd.github.io/tags/hooks/"/>
    
  </entry>
  
  <entry>
    <title>迭代器与生成器</title>
    <link href="https://blueskyadd.github.io/2021/04/17/%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <id>https://blueskyadd.github.io/2021/04/17/%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/</id>
    <published>2021-04-17T15:14:33.000Z</published>
    <updated>2022-08-02T11:57:38.067Z</updated>
    
    <content type="html"><![CDATA[<h5 id="（一）迭代器"><a href="#（一）迭代器" class="headerlink" title="（一）迭代器"></a>（一）迭代器</h5><blockquote><p>Iterator迭代器就是一个接口方法，它为不同的数据结构提供了一个统一的访问机制；使得数据结构的成员能够按某种次序排列，并逐个被访问。</p></blockquote><p>那么在日常开发中，如何让一个对象成为一个可迭代对象呢？即支持迭代器规范的对象（iterable）<br>可以给obj 对象添加Symbol.iterator属性，同时在返回的next方法中，添加value和done两个属性。<br><span id="more"></span><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="number">0</span>:<span class="string">&#x27;d&#x27;</span>,</span><br><span class="line">    <span class="number">1</span>:<span class="string">&#x27;dp&#x27;</span>,</span><br><span class="line">    <span class="number">2</span>:<span class="string">&#x27;f&#x27;</span>,</span><br><span class="line">    <span class="attr">length</span>:<span class="number">4</span>,</span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> next = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">value</span>:<span class="built_in">this</span>[index],</span><br><span class="line">                <span class="attr">done</span>: <span class="built_in">this</span>.length == ++index</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;next&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log([...obj])</span><br></pre></td></tr></table></figure></p><p>输出结果<br><img src="./1617636238317.png" alt="Alt text"></p><p>value属性返回当前位置的成员，done属性是一个布尔值，表示遍历是否结束，即是否还有必要再一次调用next方法；当done为true时，即遍历完成。既让它成为了一个可迭代对象可以使用扩展运算符。</p><h5 id="（二）生成器"><a href="#（二）生成器" class="headerlink" title="（二）生成器"></a>（二）生成器</h5><blockquote><p>生成器是一个极为灵活的结构，拥有在一个函数内暂停和恢复代码执行的能力。</p></blockquote><p>其实Generator函数就是一个普通函数，但是有两个特征，一是，function关键字与函数名之间有一个星号*；二是，函数内部使用yield表达式，定义不同的内部状态。</p><p>生成器函数的使用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> generatorObject = generatorFn()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(generatorObject ) <span class="comment">//generatorFn（&lt;suspended&gt;）</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObject.next())<span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><br>next()方法的返回值类似于迭代器，有一个done属性和一个value属性。函数体为空的生成器函数中间不会停留，调用一次next()就会让生成器到达done:true状态。</p><p>value 属性是生成器函数的返回值，默认undefined,可以通过生成器函数的返回值指定：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> generatorObject = generatorFn()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(generatorObject ) <span class="comment">//generatorFn（&lt;suspended&gt;）</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObject.next())<span class="comment">// &#123; value: &#x27;foo&#x27;, done: true &#125;</span></span><br></pre></td></tr></table></figure><br><strong>通过yiled中断执行</strong><br>yiled 关键字可以让生成器停止和开始执行，也是生成器最有用的地方。生成器函数在遇到yield关键字之前会正常执行，遇到这个关键字之后会停止执行，函数作用域的状态会被保留。停止执行的生成器函数只能通过在生成器对象上调用next()方法来恢复执行。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;ending&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hw = helloWorldGenerator();</span><br><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: &#x27;hello&#x27;, done: false &#125;</span></span><br><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: &#x27;world&#x27;, done: false &#125;</span></span><br><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: &#x27;ending&#x27;, done: true &#125;</span></span><br><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure></p><p>调用生成器函数会产生一个生成器对象。生成器对象一开始处于暂停执行（suspended)的状态。与迭代器相似，生成器对象也实现了iterator接口，因此具有next()方法。调用这个方法会让生成器恢复执行。</p><p><strong>生成器对象作为可迭代对象</strong><br>在生成器对象上显式调用next()方法的用处并不大。其实，如果把生成器对象当作可迭代对象，那么使用起来会很方便：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">yiled <span class="number">1</span>;</span><br><span class="line">yiled <span class="number">2</span>;</span><br><span class="line">yiled <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> x <span class="keyword">of</span> generatorFn())&#123;</span><br><span class="line"><span class="built_in">console</span>.log(x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//3</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;（一）迭代器&quot;&gt;&lt;a href=&quot;#（一）迭代器&quot; class=&quot;headerlink&quot; title=&quot;（一）迭代器&quot;&gt;&lt;/a&gt;（一）迭代器&lt;/h5&gt;&lt;blockquote&gt;
&lt;p&gt;Iterator迭代器就是一个接口方法，它为不同的数据结构提供了一个统一的访问机制；使得数据结构的成员能够按某种次序排列，并逐个被访问。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么在日常开发中，如何让一个对象成为一个可迭代对象呢？即支持迭代器规范的对象（iterable）&lt;br&gt;可以给obj 对象添加Symbol.iterator属性，同时在返回的next方法中，添加value和done两个属性。&lt;br&gt;
    
    </summary>
    
    
    
      <category term="javascript" scheme="https://blueskyadd.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>前端网络</title>
    <link href="https://blueskyadd.github.io/2021/03/12/%E5%89%8D%E7%AB%AF%E7%BD%91%E7%BB%9C/"/>
    <id>https://blueskyadd.github.io/2021/03/12/%E5%89%8D%E7%AB%AF%E7%BD%91%E7%BB%9C/</id>
    <published>2021-03-12T09:47:03.000Z</published>
    <updated>2022-08-02T11:58:30.881Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>网络相关的知识也是面试时经常会被问到的问题，面试官很有必要确认面试者是否只会使用$.ajax()方法，还是真正了解网络请求的原理。问题列表</p></blockquote><ol><li>get和post的区别</li><li>websocket是否了解</li><li>http 2.0对于http 1.x有哪些优点？</li><li>jq的ajax返回值是什么？</li><li>说一说你知道的HTTP状态码</li><li>jsonp的原理</li><li>跨域请求资源有哪几种方式？他们的优缺点是什么？</li><li>XML和JSON的区别？<span id="more"></span><h3 id="1-get和post的区别"><a href="#1-get和post的区别" class="headerlink" title="1. get和post的区别"></a><div style="padding-left: 1em; margin: 1em 0px; border-left: 4px solid rgb(211, 211, 211); letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="color: rgb(133, 144, 166);">1. get和post的区别</h3>get和post的区别这题看上很简单，你肯定能答出1个以上的区别，但是面试官往往期望你能答出更多更深层次的区别。这篇文章写的很详细了，大家可以研究一下——<a href="https://www.zhihu.com/question/28586791">https://www.zhihu.com/question/28586791</a><br/><br>我在这里在概括一下：<br><strong>初级的答案</strong><br>因为GET方法请求的参数都是放在请求的url上的，所以它与POST有以下明显的区别：</li></ol><ul><li>GET请求可以被添加到书签中，也可保存在浏览器历史记录中，POST不能</li><li>GET请求可以被浏览器缓存，POST不能</li><li>GET请求收到URL长度限制，所以数据长度也受限制，POST不会</li><li>GET请求只能传输ASCII字符，而POST不受此限制，还可以传输二进制数据</li></ul><p>在语义上两个方法也有区别：</p><ul><li>GET 代表获取指定服务器上资源</li><li>POST 代表向指定的资源提交要被处理的数据</li></ul><p><strong>高级些的答案</strong><br>GET产生一个TCP数据包；POST产生两个TCP数据包。<br>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；<br>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。<br>也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。<br/><br>但是需要多解释两句的是：</p><ul><li>据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。</li><li>并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。</li></ul><h3 id="2-websocket是否了解？"><a href="#2-websocket是否了解？" class="headerlink" title="2.websocket是否了解？"></a><div style="padding-left: 1em; margin: 1em 0px; border-left: 4px solid rgb(211, 211, 211); letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="color: rgb(133, 144, 166);">2.websocket是否了解？</h3><p>通常情况下，面试官问你是否对XX有了解，一般的回答都是要涵盖下面这些点：<br/></p><ul><li>是否知道它是什么？</li><li>是否知道它的用途是什么？</li><li>它和之前某项已有的技术相比，有哪些优缺点？</li></ul><p>webSocket和http一样，同属于应用层协议。它最重要的用途是实现了客户端与服务端之间的全双工通信，当服务端数据变化时，可以第一时间通知到客户端。除此之外，它与http协议不同的地方还有：<br/></p><ul><li>http只能由客户端发起，而webSocket是双向的。</li><li>webSocket传输的数据包相对于http而言很小，很适合移动端使用</li><li>没有同源限制，可以跨域共享资源</li></ul><p>要想了解更多详细，还是去看阮一峰的教程吧——WebSocket 教程 - 阮一峰的网络日志</p><h3 id="3-http-2-0对于http-1-x有哪些优点？"><a href="#3-http-2-0对于http-1-x有哪些优点？" class="headerlink" title="3.http 2.0对于http 1.x有哪些优点？"></a><div style="padding-left: 1em; margin: 1em 0px; border-left: 4px solid rgb(211, 211, 211); letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="color: rgb(133, 144, 166);">3.http 2.0对于http 1.x有哪些优点？</h3><p>优点（以下摘自HTTP/2.0 相比1.0有哪些重大改进？）：<br/></p><ul><li>多路复用：多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。由于http 1.x的时代中，浏览器向同一域名下发送的http请求数量是受限的，当超出数量限制时，请求会被阻塞，大大降低了用户体验。而HTTP/2 的多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。</li><li>二进制分帧：HTTP/2在应用层和传输层之间追加了一个二进制分帧层，最终使得多个数据流共用一个连接，更加高效的使用tcp连接。从而使得服务器的连接压力减轻，降低了内存的消耗，增大了网络的吞吐量。</li><li>首部压缩：HTTP/2引入了HPACK算法对头部进行压缩，大大减小了数据发送的字节数。</li></ul><h3 id="4-jQuery的ajax返回值是什么？"><a href="#4-jQuery的ajax返回值是什么？" class="headerlink" title="4.jQuery的ajax返回值是什么？"></a><div style="padding-left: 1em; margin: 1em 0px; border-left: 4px solid rgb(211, 211, 211); letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="color: rgb(133, 144, 166);">4.jQuery的ajax返回值是什么？</h3><p>很多公司，尤其是金融或数据分析的公司，他们的web app会与服务端进行大量的数据交互，所以他们的面试官通常会很看重面试者对于网络请求以及异步编程的理解程度。<br/><br>jQuery中的ajax大家很常用，以至于绝大部分人把他认为是“理所应当”，而忽略了他的底层逻辑和实现原理。$.ajax()方法返回的是一个延迟对象，即$.Deferred的实例。<br/><br>所以你可以像下面这样使用$.ajax()方法<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//利用done()和fail()方法来处理ajax请求</span><br><span class="line">$.ajax(&#123;url:&quot;http://mydomain.com/memberInfo/get&quot;,async: false&#125;).done(</span><br><span class="line">responseData =&gt; &#123;</span><br><span class="line">console.log(responseData)</span><br><span class="line">&#125;</span><br><span class="line">).fail(</span><br><span class="line">()=&gt;&#123;console.error(&#x27;出错了！&#x27;)&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//$.get()也是同样的道理，除了上面延迟对象提供的方法外，还可以使用then()回调</span><br><span class="line">$.get(&quot;http://mydomain.com/memberInfo/get&quot;).then(responseData =&gt; &#123;console.log(responseData);&#125;)</span><br></pre></td></tr></table></figure><br>如果你想让这两个请求都完成后再进行处理的话，可以用下面的操作：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var memberDef = $.get(&quot;http://mydomain.com/memberInfo/get&quot;);</span><br><span class="line"></span><br><span class="line">var orderDef = $.get(&quot;http://mydomain.com/orderInfo/get&quot;);</span><br><span class="line"></span><br><span class="line">$.when(memberDef, orderDef).then((</span><br><span class="line">[memberInfo], [orderInfo]</span><br><span class="line">)=&gt;&#123;</span><br><span class="line">//这里用到了解构赋值来取得http返回的数据</span><br><span class="line">console.log(&#x27;用户信息&#x27;,memberInfo);</span><br><span class="line">console.log(&#x27;订单信息&#x27;,orderInfo);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br>想要了解更多关于延迟对象的内容，可以访问阮一峰的博客除了上面这一个问题，还可以追问一些下面的问题，这里就不展开解答了：</p><ul><li>异步请求和同步请求的区别</li><li>ajax 请求有几种数据格式，如何设置数据格式</li><li>如何避免浏览器缓存get请求，以便达到每次get请求都能获取最新的数据</li><li>等等……</li></ul><h3 id="5-说一说你知道的HTTP状态码"><a href="#5-说一说你知道的HTTP状态码" class="headerlink" title="5.说一说你知道的HTTP状态码"></a><div style="padding-left: 1em; margin: 1em 0px; border-left: 4px solid rgb(211, 211, 211); letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="color: rgb(133, 144, 166);">5.说一说你知道的HTTP状态码</h3><p>以前遇到面试者说 HTTP状态码不应该是前端开发关心的事情。但我总觉得一个前端工程师对于http状态码的了解程度代表了他曾经踩过了多少雷，一个深入了解http状态码的工程师可以快速定位问题。</p><p>关于HTTP状态码应该有下面的基本认识：</p><ul><li>1xx ：1开头的状态码表示临时的响应</li><li>2xx ：请求成功</li><li>3xx ：请求被重定向</li><li>4xx ：请求错误，表明客户端发送的请求有问题</li><li>5xx ：服务器错误，表明服务端在处理请求时发生了错误</li></ul><p>知道上面的规律，再看到错误的时候就大概知道问题是后端的锅还是前端的锅了。再说几个常用的http状态码（如果有兴趣了解详细的话还是自己去找吧，网上很多（<a href="http://tools.jb51.net/table/http_status_code））：">http://tools.jb51.net/table/http_status_code））：</a></p><pre><code>* 301 ： Moved Permanently 客户端请求的文档在其他地方，新的URL在location头中给出* 304 ： Not Modified 客户端有缓存的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户端只想到指定日期后再更新文档）。服务器告诉客户，原来缓存的文档还可以继续使用。* 400 ： Bad Request 请求出现语法错误* 401 ： Unauthorized 访问被拒绝，客户端试图未经授权访问受密码保护的页面* 403 ： Forbidden 资源不可用。服务器理解客户的请求，但拒绝处理它。通常由于服务器文件或目录的权限设置导致。* 404 ： Not Found 无法找到指定位置的资源。* 405 ： Method Not Allowed 请求方法（GET、POST、PUT等）对指定的资源不适用，用来访问本资源的HTTP方法不被允许。* 500 ： Internal Server Error 服务器遇到了意料之外的情况，不能完成客户端的请求。* 502 ： Bad Gateway 服务器作为网管或者代理时收到了无效的响应。* 503 ： Service Unavailable 服务不可用，服务器由于维护或者负载过中未能应答。* 504 ： Gateway Timeout 网关超时， 作为代理或网关的服务器不能及时的应答。</code></pre><h3 id="6-JSONP的原理JSONP是一种跨域共享资源的方法。"><a href="#6-JSONP的原理JSONP是一种跨域共享资源的方法。" class="headerlink" title="6.JSONP的原理JSONP是一种跨域共享资源的方法。"></a><div style="padding-left: 1em; margin: 1em 0px; border-left: 4px solid rgb(211, 211, 211); letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="color: rgb(133, 144, 166);">6.JSONP的原理JSONP是一种跨域共享资源的方法。</h3><p>很多人会好奇JSONP和JSON是什么关系，JSONP是JSON with padding的缩写，即填充式JSON或参数式JSON，是被包含在函数调用中的JSON，如下面的样子：</p><p>callback({“name”: “Chong”});JSONP是通过动态<script>元素来实现的，使用时可以为src属性指定一个跨域URL。由于浏览器加载脚本是不受同源规则限制的，所以即使是跨域的URL同样可以发送请求。因为JSONP是有效的JavaScript代码，所以再请求完成后，即在JSONP响应加载到页面中以后，就会立即执行。示例代码：function handleResponse(response){alert(“您的IP地址是 “ + response.ip);}var script = document.createElement(“script”);script.src = “<a href="http://freegeoip.net/json/?callback=handleResponse&quot;;document.body.insertBefore">http://freegeoip.net/json/?callback=handleResponse&quot;;document.body.insertBefore</a>(script, document.body.firstChild);所以总结一下JSONP的实现方式：</p><pre><code>1. 向当前页面中动态插入一个&lt;script&gt;元素，src属性设置为请求地址，并在地址中指定好回调函数2. js代码中预先定义好jsonp的回调函数3. 请求完成后，会立即调用预先指定好的jsonp回调，并将数据以json的格式传递到回调中。</code></pre><p>JSONP之所以可以实现跨域，依赖的是下面的条件：</p><pre><code>1. 浏览器请求脚本是不受同源规则限制的2. &lt;script&gt;元素加载完成的脚本会立即执行</code></pre><p>需要注意的是，JSONP是需要服务端配合的，因为JSONP返回的是一段代码。7.跨域请求资源有哪几种方式？他们的优缺点是什么？常见的跨域方式如下：</p><pre><code>* JSONP* 图像Ping* CORS* Web Sockets</code></pre><p>一个一个说：JSONP优点：简单易用，浏览器支持好。缺点：</p><pre><code>1. JSONP是从其他域中加载代码并执行，所以存在很多安全隐患，如果其他服务器在响应中夹带恶意代码的话，没有办法防范。2. JSONP难以确定请求失败的情况。HTML5中给&lt;script&gt;元素增加了一个onerror事件，但是还是有浏览器不支持。3. 只能发送GET请求</code></pre><p>图像Ping这是指通过请求图片的方式来跨域发送请求。优点：简单，兼容性好，不需要服务器做针对性处理。缺点：</p><pre><code>1. 只能单向通信，即客户端发送信号给服务端，无法接收到服务端的回复2. 只能发送GET请求3. 容易被浏览器缓存请求，导致请求发送不出去。</code></pre><p>CORSCORS是Cross-Origin Resource Sharing的缩写，即跨域资源共享。CORS的基本思想就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。优点：功能强大缺点：</p><pre><code>1. 需要服务端来配合实现（其实很简单~）2. IE必须IE10以上。。。</code></pre><p>WebSocket这个貌似就不用多说了，属于没用过也应该听过的一种技术。优点：</p><pre><code>1. 双工通信，浏览器和服务器都可以发起请求2. 通信效率高，一次链接可以复用，省去反复的握手环节</code></pre><p>缺点：</p><pre><code>1. 实现上较为复杂，包括客户端和服务端2. 浏览器支持问题</code></pre><p>还有很多其他的跨域方式，在这里就不说了8.XML和JSON的区别？XML是标准通用标记语言 (SGML) 的子集，而标签语言（如HTML）的好处就是易懂。优点：上手简单，非开发人员也可以快速上手（产品经理们很喜欢）。缺点：</p><pre><code>1. XML多余的数据比较多，所以数据量大，传输时占用更多空间2. 客户端和服务端解析XML都要比较繁琐，需要大量代码</code></pre><p>JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式。重点在轻上，结构与JavaScript中的Object类似。优点：</p><pre><code>1. 数据量小，利于网络传输2. 方便解析，客户端和服务端都有基础的解析方法</code></pre><p>缺点：结构稍微有点复杂，非开发人员不容易上手（初学者需要去官网学习研究一下）</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;网络相关的知识也是面试时经常会被问到的问题，面试官很有必要确认面试者是否只会使用$.ajax()方法，还是真正了解网络请求的原理。问题列表&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;get和post的区别&lt;/li&gt;
&lt;li&gt;websocket是否了解&lt;/li&gt;
&lt;li&gt;http 2.0对于http 1.x有哪些优点？&lt;/li&gt;
&lt;li&gt;jq的ajax返回值是什么？&lt;/li&gt;
&lt;li&gt;说一说你知道的HTTP状态码&lt;/li&gt;
&lt;li&gt;jsonp的原理&lt;/li&gt;
&lt;li&gt;跨域请求资源有哪几种方式？他们的优缺点是什么？&lt;/li&gt;
&lt;li&gt;XML和JSON的区别？
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>next.js从入门到实战</title>
    <link href="https://blueskyadd.github.io/2021/01/02/next-js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/"/>
    <id>https://blueskyadd.github.io/2021/01/02/next-js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/</id>
    <published>2021-01-02T12:04:44.000Z</published>
    <updated>2022-08-02T12:10:14.317Z</updated>
    
    <content type="html"><![CDATA[<p> 官网上Next.js简介：Next.js 是一个轻量级的React服务端渲染框架</p><p>首先整理了一下各种渲染方式的优缺点</p><h3 id="一）-服务端渲染-客户端渲染-同构渲染的优缺点"><a href="#一）-服务端渲染-客户端渲染-同构渲染的优缺点" class="headerlink" title="一） 服务端渲染/客户端渲染/同构渲染的优缺点"></a>一） 服务端渲染/客户端渲染/同构渲染的优缺点</h3><h4 id="I-）为什么要使用服务端来渲染，有什么优点？"><a href="#I-）为什么要使用服务端来渲染，有什么优点？" class="headerlink" title="I ）为什么要使用服务端来渲染，有什么优点？"></a>I ）为什么要使用服务端来渲染，有什么优点？</h4><p>至于为什么要服务端渲染，我相信大家都有所闻，而且每个人都能说出几点来。</p><ul><li><p>首屏等待</p><p>在 SPA 模式下，所有的数据请求和 Dom 渲染都在浏览器端完成，所以当我们第一次访问页面的时候很可能会存在“白屏”等待，而服务端渲染所有数据请求和 html内容已在服务端处理完成，浏览器收到的是完整的 html 内容，可以更快的看到渲染内容，在服务端完成数据请求肯定是要比在浏览器端效率要高的多。<br><br/></p><span id="more"></span></li><li><p>SEO的优化</p><p>  有些网站的流量来源主要还是靠搜索引擎，所以网站的 SEO 还是很重要的，而 SPA 模式对搜索引擎不够友好，要想彻底解决这个问题只能采用服务端直出。</p></li></ul><hr><h4 id="II）服务端渲染的优缺点"><a href="#II）服务端渲染的优缺点" class="headerlink" title="II）服务端渲染的优缺点"></a>II）服务端渲染的优缺点</h4><h5 id="1）服务端渲染的优点"><a href="#1）服务端渲染的优点" class="headerlink" title="1）服务端渲染的优点"></a>1）服务端渲染的优点</h5><ul><li>前端渲染时间。因为后端拼接htm，浏览器只需直接渲染出来。</li><li>有利于SEO。服务端有完整的html页面，所以爬虫更容易获得信息，更利于seo</li><li>无需占用客户端资源，模板解析由后端完成，客户端只需解析标准的html页面，这样对客户端的资源占用更少，尤其是移动端，可以更加省电。</li><li>后端生成静态化文件。即生成缓存片段，这样就可以减少数据库查询浪费的时间了，且对于数据变化不大的页面非常高效 等。<h5 id="2）服务端渲染缺点"><a href="#2）服务端渲染缺点" class="headerlink" title="2）服务端渲染缺点"></a>2）服务端渲染缺点</h5></li><li>不利于前后端分离，开发效率很低。</li><li>占用服务器端资源。请求过多对服务器压力很大。</li><li>即使局部页面发生变化也需要重新请求整个页面，费流量等。</li></ul><hr><h4 id="III-）客户端渲染的优缺点"><a href="#III-）客户端渲染的优缺点" class="headerlink" title="III ）客户端渲染的优缺点"></a>III ）客户端渲染的优缺点</h4><h5 id="1）客户端渲染的优点"><a href="#1）客户端渲染的优点" class="headerlink" title="1）客户端渲染的优点"></a>1）客户端渲染的优点</h5><ul><li>节省后端资源</li><li>多端渲染 </li><li>前后端分离，大大提升开发效率 </li><li>局部刷新等<h5 id="2）客户端渲染的缺点"><a href="#2）客户端渲染的缺点" class="headerlink" title="2）客户端渲染的缺点"></a>2）客户端渲染的缺点</h5></li><li>首屏性能差</li><li>白屏时间过长</li><li>无法（很艰难）进行seo优化等<br><br/></li></ul><hr><h4 id="IV）Next-nust-js是完全属于服务端渲染吗？"><a href="#IV）Next-nust-js是完全属于服务端渲染吗？" class="headerlink" title="IV）Next/nust.js是完全属于服务端渲染吗？"></a>IV）Next/nust.js是完全属于服务端渲染吗？</h4><blockquote><p>对比一下就会发现一个很有意思的事，服务端渲染的优点就是客户端渲染的缺点，服务端渲染的缺点同时也是客户端渲染的优点，反之亦然。看之前不是很理解，由于服务端渲染的各种缺点我们已经告别了服务端渲染的时代，进入了前后端分离的客户端渲染时代，又为什么重新回到了服务端渲染？</p></blockquote><p>了解发现，其实把Next/nust.js成为SSR不是很准确，应该是Isomorphic render（同构渲染），那么什么是同构渲染？</p><hr><h4 id="V）什么是同构渲染"><a href="#V）什么是同构渲染" class="headerlink" title="V）什么是同构渲染"></a>V）什么是同构渲染</h4><blockquote><p>前后端同构是指在前后端维护同一份代码。它是在SPA的基础上，利用服务端渲染（SSR）直出首屏，解除单页面应用（SPA）在首屏渲染上面临的窘境。明确地说，同构是将传统的纯服务端直出的首屏优势和SPA的站内体验优势结合起来，以取得最优解的解决方案。</p></blockquote><p>同构渲染就是实现了ssr和spa两种技术的结合，同时可以最大限度的重用代码（同构），减少开发维护成本，采用 react 或者 vue 等前端框架相结合 node (ssr) 来实现。</p><hr><h3 id="二）Next初探"><a href="#二）Next初探" class="headerlink" title="二）Next初探"></a>二）Next初探</h3><h4 id="I-）next-js-的渲染流程"><a href="#I-）next-js-的渲染流程" class="headerlink" title="I ）next.js 的渲染流程"></a>I ）next.js 的渲染流程</h4><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/24/1737e63e5788e743~tplv-t2oaga2asx-image.image" alt=""></p><hr><h4 id="II）next-js的优点"><a href="#II）next-js的优点" class="headerlink" title="II）next.js的优点"></a>II）next.js的优点</h4><ul><li>完善的React项目架构，搭建轻松。</li><li>自带数据同步策略，解决服务端渲染最大难点.</li><li>配置灵活</li><li>丰富的插件帮开发人员增加各种功能。</li></ul><hr><h4 id="III）快速创建Next-js项目"><a href="#III）快速创建Next-js项目" class="headerlink" title="III）快速创建Next.js项目"></a>III）快速创建Next.js项目</h4><h5 id="1-）Setup"><a href="#1-）Setup" class="headerlink" title="1 ）Setup"></a>1 ）Setup</h5><p>要创建 Next.js 应用，请打开你的终端窗口，cd 进入您要在其中创建应用程序的目录，然后运行以下命令：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init next-app nextjs-blog --example &quot;https://github.com/vercel/next-learn-starter/tree/master/learn-starter&quot;</span><br></pre></td></tr></table></figure></p><p>其背后的工作是通过调用 create-next-app 工具完成的，该工具为你创建了一个 Next.js 应用程序。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/24/1737e649e8f660df~tplv-t2oaga2asx-image.image" alt=""></p><p>到这里项目就创建成功了</p><h5 id="2）运行开发服务"><a href="#2）运行开发服务" class="headerlink" title="2）运行开发服务"></a>2）运行开发服务</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd nextjs-blog</span><br><span class="line">yarn dev</span><br></pre></td></tr></table></figure><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/24/1737e64bf8fba573~tplv-t2oaga2asx-image.image" alt=""><br><br/>运行成功ing…..</p><hr><h4 id="III）页面间导航"><a href="#III）页面间导航" class="headerlink" title="III）页面间导航"></a>III）页面间导航</h4><p>在pages下新建一个test.js的页面，页面可以随意输入一些内容，这里按照hooks的方式编写你的函数型组件<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Text ()&#123;</span><br><span class="line">    return(</span><br><span class="line">        &lt;h3&gt;测试&lt;/h3&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">export default Text;</span><br></pre></td></tr></table></figure><br>然后在网页的地址栏中<a href="http://localhost:3000/test">http://localhost:3000/test</a> 然后我们发现，页面上已经显示test.js的页面内容了，这是因为Next框架就自动作好了路由，这个也算是Next的一个重要优点。发现Next框架真的减轻了我们大量的工作。</p><hr><h4 id="IV）引入个小组件"><a href="#IV）引入个小组件" class="headerlink" title="IV）引入个小组件"></a>IV）引入个小组件</h4><p>可以再根目录下创建一个components的文件夹，来存放我们的公用组件。<br>先来创建一个button的组件，首先在components文件夹下创建button.js文件，然后编辑页面，先按最简单的写法来创建一个按钮</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export default (&#123;children&#125;)=&gt;&lt;button&gt;&#123;children&#125;&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>小组件创建完成后，在pages下的index.js页面引入该文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import Button from &#x27;../components/button&#x27;</span><br></pre></td></tr></table></figure><p>然后在页面上引入该组件<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button&gt;按钮&lt;/Button&gt;</span><br></pre></td></tr></table></figure><br>然后发现已经在页面上渲染了，好想和react并没有什么区别。也就是说Next框架并没有给我们带来太多的学习成本，但是为我们减轻了很多配置工作。</p><hr><h4 id="V）路由-基本跳转"><a href="#V）路由-基本跳转" class="headerlink" title="V）路由-基本跳转"></a>V）路由-基本跳转</h4><h5 id="1）标签式导航-lt-Link-gt"><a href="#1）标签式导航-lt-Link-gt" class="headerlink" title="1）标签式导航&lt; Link &gt;"></a>1）标签式导航&lt; Link &gt;</h5><p>首先引入标签式导航&lt; Link &gt;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import Link from &#x27;next/link&#x27;</span><br></pre></td></tr></table></figure><p>引入之后尝试跳转刚才的test.js 页面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link href=&quot;/test&quot;&gt;Test&lt;/Link&gt;</span><br></pre></td></tr></table></figure><p>跳转成功，但是要记录一个&lt; Link &gt;的小坑，发现&lt; Link &gt;下如果不写内容，或者写多个标签都会报错<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link href=&quot;/test&quot;&gt;&lt;/Link&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link href=&quot;/test&quot;&gt;</span><br><span class="line">   &lt;span&gt;test`1&lt;/span&gt;</span><br><span class="line">   &lt;span&gt;test`2&lt;/span&gt;</span><br><span class="line"> &lt;/Link&gt;</span><br></pre></td></tr></table></figure><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/24/1737e65ac703f1b8~tplv-t2oaga2asx-image.image" alt=""><br>所以Link标签下有且只能有一个子元素</p><h5 id="2）Router模块进行编程式导航"><a href="#2）Router模块进行编程式导航" class="headerlink" title="2）Router模块进行编程式导航"></a>2）Router模块进行编程式导航</h5><p>首先也是引入Router模块<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import Router from &#x27;next/router&#x27;</span><br></pre></td></tr></table></figure><br>然后尝试跳转<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;()=&gt;&#123;Router.push(&#x27;/test&#x27;)&#125;&#125;&gt;去test页面&lt;/button&gt;</span><br></pre></td></tr></table></figure><br>两种方法都可以跳转，可以根据业务需求具体选择</p><hr><h4 id="Ⅵ）路由-query传参"><a href="#Ⅵ）路由-query传参" class="headerlink" title="Ⅵ）路由-query传参"></a>Ⅵ）路由-query传参</h4><p>首先是标签式&lt; Link &gt;传参<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link href=&quot;/test?id=123&quot;&gt;</span><br><span class="line">     &lt;span&gt;test&lt;/span&gt;</span><br><span class="line">&lt;/Link&gt;</span><br></pre></td></tr></table></figure><br>或者<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link href=&#123;&#123;pathname:&#x27;/test&#x27;,query:&#123;id:&#x27;123&#x27;&#125;&#125;&#125;&gt;</span><br><span class="line">    &lt;span&gt;test&lt;/span&gt;</span><br><span class="line">&lt;/Link&gt;</span><br></pre></td></tr></table></figure><br>然后变成是导航传参<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;()=&gt;&#123;Router.push(&#x27;/test?id=123&#x27;)&#125;&#125;&gt;去test页面&lt;/button&gt;</span><br></pre></td></tr></table></figure><br>或者<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;()=&gt;&#123;Router.push(&#123;pathname:&#x27;/test&#x27;,query:&#123;id:&#x27;123&#x27;&#125;&#125;)&#125;&#125;&gt;去test页面&lt;/button&gt;</span><br></pre></td></tr></table></figure><br>好像没啥区别…….</p><hr><h4 id="Ⅶ）路由-接收参数"><a href="#Ⅶ）路由-接收参数" class="headerlink" title="Ⅶ）路由-接收参数"></a>Ⅶ）路由-接收参数</h4><p>接收参数 需要用到withRouter  它是Next.js框架的高阶组件，用来处理路由的。<br><strong><em><a href="https://react.docschina.org/docs/higher-order-components.html">传递门之高阶组件</a></em></strong><br><br/><br>接下来重新编写test.js页面<br>首先引入withRouter<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; withRouter &#125; from &#x27;next/router&#x27;</span><br></pre></td></tr></table></figure><br>然后在页面中使用<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import &#123; withRouter &#125; from &#x27;next/router&#x27;</span><br><span class="line">import Link from &#x27;next/link&#x27;</span><br><span class="line"></span><br><span class="line">const  Test = (&#123;router&#125;) =&gt;&#123;</span><br><span class="line">    return(</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;&#123;router.query.id&#125;&lt;/p&gt;</span><br><span class="line">            &lt;Link href=&#123;&#123;pathname:&#x27;/&#x27;&#125;&#125;&gt;</span><br><span class="line">                &lt;span&gt;回首页&lt;/span&gt;</span><br><span class="line">            &lt;/Link&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">export default withRouter(Test)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>这里可以看到接收到的id值123</p><hr><h4 id="Ⅷ）路由-钩子事件"><a href="#Ⅷ）路由-钩子事件" class="headerlink" title="Ⅷ）路由-钩子事件"></a>Ⅷ）路由-钩子事件</h4><p>next.js的路由钩子一共有六个</p><blockquote><p>当路由发生变化时会触发钩子事件，这里用到Router的on方法来监听，钩子事件第二个参数为路由参数，这里来编辑index.js页面。</p></blockquote><p>可以通过Router监听路由器内部发生的不同事件<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 监听</span><br><span class="line">Router.events.on(&#x27;routeChangeStart&#x27;, handleRouteChange)</span><br><span class="line">// 关闭</span><br><span class="line">Router.events.off(&#x27;routeChangeStart&#x27;, handleRouteChange)</span><br></pre></td></tr></table></figure></p><h5 id="1）routeChangeStart"><a href="#1）routeChangeStart" class="headerlink" title="1）routeChangeStart"></a>1）routeChangeStart</h5><p>   路由开始发生变化时触发<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> Router.events.on(&#x27;routeChangeStart&#x27;,(...args)=&gt;&#123;</span><br><span class="line">   console.log(&#x27;路由开始变化&#x27;,...args)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br>   <br/></p><h5 id="2）routeChangeComplete"><a href="#2）routeChangeComplete" class="headerlink" title="2）routeChangeComplete"></a>2）routeChangeComplete</h5><p> 路由结束变化时触发<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Router.events.on(&#x27;routeChangeComplete&#x27;,(...args)=&gt;&#123;</span><br><span class="line">  console.log(&#x27;路由结束变化&#x27;,...args)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br>   <br/></p><h5 id="3）-beforeHistoryChange"><a href="#3）-beforeHistoryChange" class="headerlink" title="3） beforeHistoryChange"></a>3） beforeHistoryChange</h5><p>在改变浏览器 history之前触发<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Router.events.on(&#x27;beforeHistoryChange,(...args)=&gt;&#123;</span><br><span class="line">  console.log(&#x27;浏览器 history改变之前&#x27;,...args)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br> <br/></p><h5 id="4）-routeChangeError"><a href="#4）-routeChangeError" class="headerlink" title="4） routeChangeError"></a>4） routeChangeError</h5><p>跳转发生错误触发<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Router.events.on(&#x27;routeChangeError,(...args)=&gt;&#123;</span><br><span class="line">  console.log(&#x27;跳转发生错误&#x27;,...args)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br><br/></p><h5 id="5）-hashChangeStart"><a href="#5）-hashChangeStart" class="headerlink" title="5） hashChangeStart"></a>5） hashChangeStart</h5><p>hash模式路由改变刚开始<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Router.events.on(&#x27;hashChangeStart,(...args)=&gt;&#123;</span><br><span class="line">  console.log(&#x27;hash模式路由改变刚开始&#x27;,...args)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br> <br/></p><h5 id="6）-hashChangeComplete"><a href="#6）-hashChangeComplete" class="headerlink" title="6） hashChangeComplete"></a>6） hashChangeComplete</h5><p>hash模式路由改变结束<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Router.events.on(&#x27;hashChangeComplete,(...args)=&gt;&#123;</span><br><span class="line">  console.log(&#x27;hash模式路由改变结束&#x27;,...args)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br> <br/></p><hr><h4 id="Ⅸ）getInitialProps-获取远程数据"><a href="#Ⅸ）getInitialProps-获取远程数据" class="headerlink" title="Ⅸ）getInitialProps 获取远程数据"></a>Ⅸ）getInitialProps 获取远程数据</h4><p>我们通常需要从远程数据源获取数据.Next.js 自己有标准 API 来获取页面数据.我们通常使用异步函数 getInitialProps 来完成此操作 .这样,我们可以通过远程数据源获取数据到页面上,并将其作为 props 传递给我们的页面.getInitialProps 在服务器和客户端上均可使用.</p><p>可以使用fetch或者axios，看个人习惯</p><h5 id="1）-fetch"><a href="#1）-fetch" class="headerlink" title="1） fetch"></a>1） fetch</h5><p> 首先安装fetch<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save isomorphic-unfetch</span><br></pre></td></tr></table></figure><br> 然后再页面上使用<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  Home.getInitialProps = async function ()&#123;</span><br><span class="line">  const res = await fetch(&#x27;https://api.tvmaze.com/search/shows?q=batman&#x27;);</span><br><span class="line">  const data = await res.json();</span><br><span class="line">  console.log(data.map(entry =&gt; entry.show))</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="2）-axios"><a href="#2）-axios" class="headerlink" title="2） axios"></a>2） axios</h5><p>也可以使用axios<br>首先安装axios<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save axios</span><br></pre></td></tr></table></figure><br>然后在页面中使用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Home.getInitialProps = <span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line"><span class="keyword">const</span> promise =<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line">       axios(<span class="string">&#x27;https://api.tvmaze.com/search/shows?q=batman&#x27;</span>).then(</span><br><span class="line">           <span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">               <span class="built_in">console</span>.log(<span class="string">&#x27;远程数据结果：&#x27;</span>,res.data)</span><br><span class="line">               resolve(&#123;<span class="attr">shows</span>:res.data.map(<span class="function"><span class="params">entry</span> =&gt;</span> entry.show)&#125;)</span><br><span class="line">           &#125;</span><br><span class="line">       )</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">await</span> promise</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里拿到数据后在页面上渲染。<br>接收props参数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">      &#123;props.shows.map(<span class="function"><span class="params">show</span> =&gt;</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;show.id&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">Link</span> <span class="attr">href</span>=<span class="string">&quot;/detail/[id]&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">a</span>&gt;</span>&#123;show.name&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">      ))&#125;</span><br><span class="line"> &lt;/ul&gt;</span><br></pre></td></tr></table></figure></p><hr><h4 id="X）编写组件的样式"><a href="#X）编写组件的样式" class="headerlink" title="X）编写组件的样式"></a>X）编写组件的样式</h4><h5 id="1）框架自带的一种语法style-jsx-，来尝试一下让字体变成蓝色"><a href="#1）框架自带的一种语法style-jsx-，来尝试一下让字体变成蓝色" class="headerlink" title="1）框架自带的一种语法style jsx  ，来尝试一下让字体变成蓝色"></a>1）框架自带的一种语法style jsx  ，来尝试一下让字体变成蓝色</h5><p>  直接写在return 中，可以在页面最外层添加一个&lt;&gt;&lt;/&gt;<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;&gt;</span><br><span class="line">    &lt;div className=&quot;container&quot;&gt;</span><br><span class="line">      &lt;Test&gt;按钮&lt;/Test&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;style jsx&gt;</span><br><span class="line">      &#123;`</span><br><span class="line">          button &#123; color:blue;&#125;</span><br><span class="line">      `&#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;/&gt;</span><br></pre></td></tr></table></figure></p><p>然后运行一下即可看到 button的字体变成了蓝色。<br><br/></p><h5 id="2）-然后我们来动态改变一下组件的样式"><a href="#2）-然后我们来动态改变一下组件的样式" class="headerlink" title="2） 然后我们来动态改变一下组件的样式"></a>2） 然后我们来动态改变一下组件的样式</h5><p>首先引入react hooks中的useState<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123;useState&#125; from &#x27;react&#x27;</span><br></pre></td></tr></table></figure><br>  然后来定义color 以及setColor<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const [color,setColor] = useState(&#x27;red&#x27;)</span><br></pre></td></tr></table></figure><br> 加入点击事件<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const changeColor=()=&gt;&#123;</span><br><span class="line">    setColor(color === &#x27;blue&#x27; ?&#x27;red&#x27;:&#x27;blue&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>和按钮button<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;changeColor&#125;&gt;改变字体颜色&lt;/button&gt;</span><br></pre></td></tr></table></figure><br>最后在style中写入变量color<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">button &#123; color:$&#123;color&#125;;&#125;</span><br></pre></td></tr></table></figure><br>运行页面，点击按钮发现button的字体颜色可以动态切换，很是方便。</p><blockquote><p>f12打开控制台还会发现，加入了Style jsx代码后，Next.js会自动加入一个随机类名，这样就防止了CSS的全局污染。</p></blockquote><hr><h5 id="3）尝试引入less-和-css"><a href="#3）尝试引入less-和-css" class="headerlink" title="3）尝试引入less 和 css"></a>3）尝试引入less 和 css</h5><p>当页面比较复杂的时候，我们以jsx方式来编写样式，难免的会降低我们的开发效率，所以这里尝试一下引入less<br>首先安装less  和 css<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --save @zeit/next-less less</span><br><span class="line">npm install --save @zeit/next-css</span><br></pre></td></tr></table></figure><br>然后第二步在根目录下创建next.config.js配置文件<br>这里我们同时引入css和sass哦</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const withCss = require(&#x27;@zeit/next-css&#x27;)</span><br><span class="line"></span><br><span class="line">const withLess = require(&#x27;@zeit/next-less&#x27;)</span><br><span class="line">if(typeof require !== &#x27;undefined&#x27;)&#123;</span><br><span class="line">    require.extensions[&#x27;.css&#x27;]=file=&gt;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (typeof require !== &quot;undefined&quot;) &#123;</span><br><span class="line">   require.extensions[&quot;.withLess&quot;] = file =&gt; &#123;&#125;;</span><br><span class="line"> &#125;</span><br><span class="line">module.exports = withLess(withCss(&#123;&#125;))</span><br></pre></td></tr></table></figure><p><strong><em>小可爱这里记住这里要重启服务哦</em></strong></p><hr><h4 id="Ⅺ）引入antd"><a href="#Ⅺ）引入antd" class="headerlink" title="Ⅺ）引入antd"></a>Ⅺ）引入antd</h4><p>首先安装antd依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install antd --save</span><br></pre></td></tr></table></figure><p>然后来安装和配置babel-plugin-import 插件<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-plugin-import --save-dev</span><br></pre></td></tr></table></figure></p><p>安装完成后，在项目根目录建立.babelrc文件，然后写入如下配置文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;presets&quot;:[&quot;next/babel&quot;],  //Next.js的总配置文件，相当于继承了它本身的所有配置</span><br><span class="line">    &quot;plugins&quot;:[     //增加新的插件，这个插件就是让antd可以按需引入，包括CSS</span><br><span class="line">        [</span><br><span class="line">            &quot;import&quot;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;libraryName&quot;:&quot;antd&quot;,</span><br><span class="line">                &quot;style&quot;:&quot;css&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样配置好了以后，webpack就不会默认把整个Ant Design的包都进行打包到生产环境了，而是我们使用那个组件就打包那个组件,同样CSS也是按需打包的。</p><p><strong><em>这里记住这里要重启服务哦</em></strong><br>配置完成后我们在页面中尝试引入Button组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123;Button&#125; from &#x27;antd&#x27;</span><br></pre></td></tr></table></figure><p>然后使用<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button onClick=&#123;changeColor&#125;&gt;改变字体颜色&lt;/Button&gt;</span><br></pre></td></tr></table></figure><br>嗯哼，这里就生效了</p><hr><h4 id="Ⅻ）部署-Next-js-应用"><a href="#Ⅻ）部署-Next-js-应用" class="headerlink" title="Ⅻ）部署 Next.js 应用"></a>Ⅻ）部署 Next.js 应用</h4><p>先安装 now,一个静态资源托管服务器<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g now</span><br></pre></td></tr></table></figure></p><p>打包<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn build</span><br></pre></td></tr></table></figure><br>结果发现报错了，其实是我们在加入Ant Design的样式时产生的，这个已经在Ant Design的Github上被提出了，但目前还没有被修改，你可以改完全局引入CSS解决问题。</p><p><strong><em>解决办法</em></strong></p><p>在page目录下，新建一个_app.js文件，然后写入下面的代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import App from &#x27;next/app&#x27;</span><br><span class="line"></span><br><span class="line">import &#x27;antd/dist/antd.css&#x27;</span><br><span class="line"></span><br><span class="line">export default App</span><br></pre></td></tr></table></figure><p>再次运行yarn build<br>发现可以打包成功，最后运行<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn start</span><br></pre></td></tr></table></figure><br>可以在页面上运行<br>  </div></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 官网上Next.js简介：Next.js 是一个轻量级的React服务端渲染框架&lt;/p&gt;
&lt;p&gt;首先整理了一下各种渲染方式的优缺点&lt;/p&gt;
&lt;h3 id=&quot;一）-服务端渲染-客户端渲染-同构渲染的优缺点&quot;&gt;&lt;a href=&quot;#一）-服务端渲染-客户端渲染-同构渲染的优缺点&quot; class=&quot;headerlink&quot; title=&quot;一） 服务端渲染/客户端渲染/同构渲染的优缺点&quot;&gt;&lt;/a&gt;一） 服务端渲染/客户端渲染/同构渲染的优缺点&lt;/h3&gt;&lt;h4 id=&quot;I-）为什么要使用服务端来渲染，有什么优点？&quot;&gt;&lt;a href=&quot;#I-）为什么要使用服务端来渲染，有什么优点？&quot; class=&quot;headerlink&quot; title=&quot;I ）为什么要使用服务端来渲染，有什么优点？&quot;&gt;&lt;/a&gt;I ）为什么要使用服务端来渲染，有什么优点？&lt;/h4&gt;&lt;p&gt;至于为什么要服务端渲染，我相信大家都有所闻，而且每个人都能说出几点来。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;首屏等待&lt;/p&gt;
&lt;p&gt;在 SPA 模式下，所有的数据请求和 Dom 渲染都在浏览器端完成，所以当我们第一次访问页面的时候很可能会存在“白屏”等待，而服务端渲染所有数据请求和 html内容已在服务端处理完成，浏览器收到的是完整的 html 内容，可以更快的看到渲染内容，在服务端完成数据请求肯定是要比在浏览器端效率要高的多。&lt;br&gt;&lt;br/&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Next" scheme="https://blueskyadd.github.io/tags/Next/"/>
    
  </entry>
  
  <entry>
    <title>vue项目运行后，在IE浏览器打开，页面为空白</title>
    <link href="https://blueskyadd.github.io/2020/07/15/vue/"/>
    <id>https://blueskyadd.github.io/2020/07/15/vue/</id>
    <published>2020-07-15T05:42:15.000Z</published>
    <updated>2021-06-02T06:31:19.309Z</updated>
    
    <content type="html"><![CDATA[<p>解决方案：</p><h3>一、首先安装babel-polyfill</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save babel-polyfill</span><br></pre></td></tr></table></figure><span id="more"></span><h3>二、在main.js里引入<h3><br><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;babel-polyfill&#x27;</span><br></pre></td></tr></table></figure><br><h3>三、在首页index.html中添加</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt;</span><br></pre></td></tr></table></figure><p><h3>四、配置项目文件</h3><br>build中的webpack.base.conf.js修改如下配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">entry:&#123;</span><br><span class="line">    app:[&#x27;babel-polyfill&#x27;,&#x27;./src/main.js&#x27;]      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;解决方案：&lt;/p&gt;
&lt;h3&gt;一、首先安装babel-polyfill&lt;/h3&gt;

&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm install --save babel-polyfill&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>TS - interfaces  初探</title>
    <link href="https://blueskyadd.github.io/2020/07/15/ts-interfaces/"/>
    <id>https://blueskyadd.github.io/2020/07/15/ts-interfaces/</id>
    <published>2020-07-15T05:40:38.000Z</published>
    <updated>2021-03-17T10:46:50.270Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>interfaces英文翻译为<strong>接口</strong>，百度百科上解释为<strong>interface是面向对象编程语言中接口操作的关键字，功能是把所需成员组合起来，用来装封一定功能的集合</strong>。那么它在ts这个语言中究竟扮演怎样的角色，有什么用途。</p></blockquote><h2 id="interfaces-是什么"><a href="#interfaces-是什么" class="headerlink" title="interfaces 是什么"></a>interfaces 是什么</h2><p>理解起来 <strong>interfaces就是约定了一个编程的规范而已，它规定了要实现的一系列方法和属性</strong>。也就是说interface其实是一种描述对象或函数的东西，它是一种约束形式，比如一个对象需要有什么样的属性，函数需要什么参数或返回什么样的值，数组应该是什么样子的，一个类和继承类需要符合什么样的描述等等。</p><blockquote><p>了解了interface是什么，那么在不同的情况下我们怎么去使用interfaces呢？</p></blockquote><span id="more"></span><hr><h2 id="interfaces-怎么用"><a href="#interfaces-怎么用" class="headerlink" title="interfaces 怎么用"></a>interfaces 怎么用</h2><h4 id="对象-Interface"><a href="#对象-Interface" class="headerlink" title="对象 Interface"></a>对象 Interface</h4><ol><li>定义对象需要的属性</li><li>设置可选属性</li><li>设置只读属性</li><li>可以通过 as 或 [propName: string]: any 来定义对象属性的数据类型</li></ol><p>例子：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span>  people &#123;</span><br><span class="line">    <span class="attr">Name</span> : <span class="built_in">String</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="built_in">number</span>,</span><br><span class="line">    height?: <span class="built_in">number</span>,<span class="comment">//设置可选属性，可有可恶✅</span></span><br><span class="line">    <span class="keyword">readonly</span> gender:<span class="built_in">String</span>, <span class="comment">//设置只读属性✅</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> zhangSan:people = &#123;</span><br><span class="line">    <span class="attr">Name</span>: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="attr">gender</span>:<span class="string">&#x27;男&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">zhangSan.gender = <span class="string">&quot;女&quot;</span><span class="comment">//报错，只读属性不可修改 ❌</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h4 id="函数-Interface"><a href="#函数-Interface" class="headerlink" title="函数 Interface"></a>函数 Interface</h4><ol><li>定义函数接口</li><li>定义函数入参的类型</li><li>使用函数表达式</li><li>调用函数，写入出参</li></ol><p>例子：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Fun &#123;(</span><br><span class="line">    x:<span class="built_in">string</span>,<span class="comment">//定义函数接收的第一个必选参数为string类型✅</span></span><br><span class="line">    <span class="attr">y</span>:<span class="built_in">number</span>,<span class="comment">//定义函数接收的第二个必选参数为number类型✅</span></span><br><span class="line">    z?:<span class="built_in">boolean</span>,<span class="comment">//定义函数接收的第三个可选参数为boolean类型✅</span></span><br><span class="line">)&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add: Fun = <span class="function"><span class="keyword">function</span> (<span class="params">x:<span class="built_in">string</span>, y:<span class="built_in">number</span>, z = <span class="literal">false</span></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x, y, z)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="string">&#x27;张三&#x27;</span>,<span class="number">12</span>)</span><br></pre></td></tr></table></figure></p><h4 id="可索引的类型"><a href="#可索引的类型" class="headerlink" title="可索引的类型"></a>可索引的类型</h4><p>我们也可以描述那些能够“通过索引得到”的类型，例如arr[0]。可索引类型具有一个<strong>索引签名</strong>，它描述了对象索引的类型，还有相应的索引返回值类型。</p><ol><li>定义一个可索引类型 </li><li>设置索引类型</li><li>定义数组调用该规范</li></ol><p>例子：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> StringArray &#123;</span><br><span class="line">    <span class="keyword">readonly</span> [index: <span class="built_in">number</span>]:<span class="built_in">string</span>, <span class="comment">//❗ 需要注意的是 index 只能为 number 类型或 string 类型</span></span><br><span class="line">    <span class="attr">length</span>: <span class="built_in">number</span> <span class="comment">//指定属性👀</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr1: StringArray = [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>] </span><br><span class="line"></span><br><span class="line">arr1[<span class="number">1</span>] = <span class="string">&quot;4&quot;</span> <span class="comment">// ❌ 由于索引设置为只读属性，arr1[1]不能赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr: StringSet = [<span class="number">23</span>,<span class="number">12</span>,<span class="number">3</span>,<span class="number">21</span>] <span class="comment">// ❌ 数组应为 string 类型</span></span><br></pre></td></tr></table></figure></p><h4 id="类-Interface"><a href="#类-Interface" class="headerlink" title="类 Interface"></a>类 Interface</h4><blockquote><p>实现（implements）是面向对象中的一个重要概念。一个类只能继承自另一个类，不同类之间可以有一些共有的特性，就可以把特性提取成接口（interfaces），用 implements 关键字来实现。</p></blockquote><p>Interface 也可以用来定义一个类的规范。需要注意的是类 Interface 只会检查实例的属性，静态属性是需要额外定义一个 Interface；<br>例如：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ? PersonConstructor 是用来检查静态部分的</span></span><br><span class="line"><span class="keyword">interface</span> PersonConstructor &#123;</span><br><span class="line">    <span class="keyword">new</span> (name: <span class="built_in">string</span>, <span class="attr">age</span>: <span class="built_in">number</span>) <span class="comment">// ✔️ 这个是用来检查 constructor 的</span></span><br><span class="line">    <span class="attr">typename</span>: <span class="built_in">string</span> <span class="comment">// ✔️ 这个是用来检查静态属性 typename 的</span></span><br><span class="line">    logname(): <span class="built_in">void</span> <span class="comment">// ✔️ 这个用来检查静态方法 logname 的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ? PersonInterface 则是用来检查实例部分的</span></span><br><span class="line"><span class="keyword">interface</span> PersonInterface &#123;</span><br><span class="line">    <span class="comment">// new (name: string, age: number) // ❌ 静态方法的检查也不能写在这里 这样写是错误的</span></span><br><span class="line">    log(): <span class="built_in">void</span> <span class="comment">// : 这里定义了实例方法 log</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class Person implements PersonInterface, PersonInterface &#123; ❌ 这样写是错误的</span></span><br><span class="line"><span class="keyword">const</span> Person: PersonConstructor = <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="title">implements</span> <span class="title">PersonInterface</span> </span>&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="keyword">static</span> typename = <span class="string">&#x27;Person type&#x27;</span> <span class="comment">// 这里定义了一个名为 typename 的静态属性</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">logname</span>(<span class="params"></span>)</span> &#123; <span class="comment">// 这里定义了一个名为 logname 的静态方法</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.typename)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>)</span> &#123; <span class="comment">// constructor 也是静态方法</span></span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">        <span class="built_in">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">log</span>(<span class="params"></span>)</span> &#123; <span class="comment">// log 是实例方法</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name, <span class="built_in">this</span>.age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="接口间的继承"><a href="#接口间的继承" class="headerlink" title="接口间的继承"></a>接口间的继承</h4><ul><li>接口可以通过其他接口来扩展自己。</li><li>Typescript 允许接口继承多个接口。</li><li>继承使用关键字 extends。</li></ul><h5 id="1-单接口继承"><a href="#1-单接口继承" class="headerlink" title="1. 单接口继承"></a>1. 单接口继承</h5><p>extends 关键字后加继承的接口<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Students <span class="keyword">extends</span> Person &#123;</span><br><span class="line">  <span class="attr">gender</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> foo: Students = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;why&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">gender</span>: <span class="string">&#x27;female&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="2-多接口继承"><a href="#2-多接口继承" class="headerlink" title="2. 多接口继承"></a>2. 多接口继承</h5><p>多接口之间逗号分隔<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Sing &#123;</span><br><span class="line">  sing(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Jump &#123;</span><br><span class="line">  jump(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Rap <span class="keyword">extends</span> Sing, Jump &#123;</span><br><span class="line">  rap(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> foo: Rap = &#123;</span><br><span class="line">  <span class="function"><span class="title">sing</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">  <span class="function"><span class="title">jump</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">  <span class="function"><span class="title">rap</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="3-接口继承类"><a href="#3-接口继承类" class="headerlink" title="3. 接口继承类"></a>3. 接口继承类</h5><p>常见的面向对象语言中，接口是不能继承类的，但是在 TypeScript 中却是可行的<br>用extends关键字继承类<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">  run(): <span class="built_in">void</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> User <span class="keyword">extends</span> Person &#123;</span><br><span class="line">  <span class="attr">gender</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> foo: User = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;foo&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">gender</span>: <span class="string">&#x27;male&#x27;</span>,</span><br><span class="line">  run():<span class="built_in">void</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>友情链接：<br><a href="https://blog.csdn.net/qdmoment/article/details/82496685">es6中class类静态方法，静态属性理解，实例属性，实例方法理解</a><br><a href="https://blog.csdn.net/qq_15037231/article/details/82813140">extends和implements区别</a></p><hr><p>参考资料<br><a href="https://www.jianshu.com/p/099c5683ffb5">https://www.jianshu.com/p/099c5683ffb5</a><br><a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Interfaces.html">https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Interfaces.html</a><br><a href="https://cloud.tencent.com/developer/article/1411764">https://cloud.tencent.com/developer/article/1411764</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;interfaces英文翻译为&lt;strong&gt;接口&lt;/strong&gt;，百度百科上解释为&lt;strong&gt;interface是面向对象编程语言中接口操作的关键字，功能是把所需成员组合起来，用来装封一定功能的集合&lt;/strong&gt;。那么它在ts这个语言中究竟扮演怎样的角色，有什么用途。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;interfaces-是什么&quot;&gt;&lt;a href=&quot;#interfaces-是什么&quot; class=&quot;headerlink&quot; title=&quot;interfaces 是什么&quot;&gt;&lt;/a&gt;interfaces 是什么&lt;/h2&gt;&lt;p&gt;理解起来 &lt;strong&gt;interfaces就是约定了一个编程的规范而已，它规定了要实现的一系列方法和属性&lt;/strong&gt;。也就是说interface其实是一种描述对象或函数的东西，它是一种约束形式，比如一个对象需要有什么样的属性，函数需要什么参数或返回什么样的值，数组应该是什么样子的，一个类和继承类需要符合什么样的描述等等。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;了解了interface是什么，那么在不同的情况下我们怎么去使用interfaces呢？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="ts" scheme="https://blueskyadd.github.io/tags/ts/"/>
    
  </entry>
  
  <entry>
    <title>promise的简单理解</title>
    <link href="https://blueskyadd.github.io/2020/04/21/promise/"/>
    <id>https://blueskyadd.github.io/2020/04/21/promise/</id>
    <published>2020-04-21T07:09:08.000Z</published>
    <updated>2020-04-22T07:35:54.551Z</updated>
    
    <content type="html"><![CDATA[<h4 id="promise的基本语法"><a href="#promise的基本语法" class="headerlink" title="promise的基本语法"></a>promise的基本语法</h4><blockquote><p>新建一个promise很简单，只需要new一个promise对象即可。所以promise本质上就是一个函数，它接受一个函数作为参数，并且会返回promise对象，这就给链式调用提供了基础。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new Promise(function(resolve, reject) &#123;</span><br><span class="line"> //待处理的异步逻辑</span><br><span class="line"> //处理结束后，调用resolve或reject方法</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="promise的几种状态"><a href="#promise的几种状态" class="headerlink" title="promise的几种状态"></a>promise的几种状态</h4><p> 其实Promise函数的使命，就是构建出它的实例，并且负责帮我们管理这些实例。而这些实例有以下三种状态：</p><pre><code>1. pending: 初始状态，位履行或拒绝2. fulfilled: 意味着操作成功完成3. rejected: 意味着操作失败</code></pre><blockquote><p>pending 状态的 Promise对象可能以fulfilled状态返回了一个值，也可能被某种理由（异常信息）拒绝（reject）了。当其中任一种情况出现时，Promise 对象的then方法绑定的处理方法（handlers）就会被调用，then方法分别指定了resolve方法和reject方法的回调函数</p></blockquote><h4 id="几种状态的深入理解"><a href="#几种状态的深入理解" class="headerlink" title="几种状态的深入理解"></a>几种状态的深入理解</h4><ul><li>一个promise可能有三种状态：等待（pending）、已完成（fulfilled）、已拒绝（rejected）</li><li>一个promise的状态只可能从“等待”转到“完成”态或者“拒绝”态，不能逆向转换，同时“完成”态和“拒绝”态不能相互转换</li><li>promise必须实现then方法（可以说，then就是promise的核心），而且then必须返回一个promise，同一个promise的then可以调用多次，并且回调的执行顺序跟它们被定义时的顺序一致</li><li>then方法接受两个参数，第一个参数是成功时的回调，在promise由“等待”态转换到“完成”态时调用，另一个是失败时的回调，在promise由“等待”态转换到“拒绝”态时调用。同时，then可以接受另一个promise传入，也接受一个“类then”的对象或方法，即thenable对象。</li></ul><h4 id="promise缺点"><a href="#promise缺点" class="headerlink" title="promise缺点"></a>promise缺点</h4><ul><li>一旦新建它就会立即执行，无法中途取消</li><li>如果不设置回调函数，Promise内部抛出的错误，不会反应到外部</li><li>当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;promise的基本语法&quot;&gt;&lt;a href=&quot;#promise的基本语法&quot; class=&quot;headerlink&quot; title=&quot;promise的基本语法&quot;&gt;&lt;/a&gt;promise的基本语法&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;新建一个promise很简单，只需
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>react基础（一）</title>
    <link href="https://blueskyadd.github.io/2020/04/13/react%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://blueskyadd.github.io/2020/04/13/react%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2020-04-13T05:17:41.000Z</published>
    <updated>2021-06-02T06:22:46.040Z</updated>
    
    <content type="html"><![CDATA[<h4 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h4><blockquote><p>react 作为目前前端的主流框架，各大公司也都在使用。react是一套基于视图层的框架，核心库只关注于视图层，跟vue一致（vue参照了react）。react专注于组件化开发，使用jsx语法（javascript xml  – 类xml语法—-要求所有写的视图代码必须包含在同一个父级标签中—-vue中的template），内涵虚拟DOM（ 所有内容并不是一开始就写到了index.html中，使用jsx语法构建，最后渲染到了index.html页面中），使用diff算法（ 状态的改变，会引起视图的二次渲染，比较状态树变化的算法），会比vue更加适合团队开发模式，以至于react成了一项必备技能。我个人其实是一直在使用vue，不过为了迎合市场也开始了react的学习之路，接下来我会将<strong>react</strong>、<strong>redux</strong>、<strong>react-router</strong>一步一步来进行整理。</p></blockquote><!-- <img src="./img/backgroundImg/4.jpg" width="850" hegiht="313" align=center /> --><h3>01-构建项目</h3><h4 id="01-1-create-react-app-快速构建项目"><a href="#01-1-create-react-app-快速构建项目" class="headerlink" title="01-1 create-react-app 快速构建项目"></a>01-1 create-react-app 快速构建项目</h4><h5 id="creat-react-app优点"><a href="#creat-react-app优点" class="headerlink" title="creat-react-app优点"></a>creat-react-app优点</h5><ul><li>无需配置：官方的配置堪称完美，几乎不用你再配置任何东西，就可以上手开发项目。</li><li>高集成性：集成了对React，JSX，ES6和Flow的支持。</li><li>自带服务：集成了开发服务器，你可以实现开发预览一体化。</li><li>热更新：保存自动更新，让你的开发更简单。</li><li>全兼容性：自动处理CSS的兼容问题，无需添加-webkit前缀。</li><li>自动发布：集成好了发布成品功能，编译后直接发布，并且包含了sourcemaps功能。</li></ul><h5 id="creat-react-app的安装"><a href="#creat-react-app的安装" class="headerlink" title="creat-react-app的安装"></a>creat-react-app的安装</h5><p> windows系统下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g create-react-app</span><br></pre></td></tr></table></figure><span id="more"></span><h5 id="创建react项目"><a href="#创建react项目" class="headerlink" title="创建react项目"></a>创建react项目</h5><p>安装完成后，就可以使用create-react-app来生成react项目的项目目录– projectName：项目名称</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create-react-app projectName</span><br></pre></td></tr></table></figure><h5 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h5><p>然后进入到项目内 通过npm来安装项目依赖</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure><h4 id="01-2-generator-react-webpack-快速构建项目"><a href="#01-2-generator-react-webpack-快速构建项目" class="headerlink" title="01-2 generator-react-webpack 快速构建项目"></a>01-2 generator-react-webpack 快速构建项目</h4><p>我也是第一次使用它，各种百度后发现它其实是基于webpack构建的，只不过是进一步完善了webpack，它可以支持ES6，并且集成了Babel-Loader等。简单来说使用它之后省去了我们自己手动配置webpack,对于我这种不熟悉webpack配置的小白来说极其方便。</p><h5 id="generator-react-webpack优点"><a href="#generator-react-webpack优点" class="headerlink" title="generator-react-webpack优点"></a>generator-react-webpack优点</h5><ul><li>基于webpack构建，可以很容易的配置自己需要的webpack。</li><li>支持ES6，集成了Babel-Loader。</li><li>支持不同风格的CSS（sass，less，stylus）。</li><li>支持PostCSS转换样式。</li><li>集成了esLint功能。</li><li>可以轻松配置单元测试，比如Karma和Mocha</li><li>包含热加载</li></ul><h5 id="generator-react-webpack的安装"><a href="#generator-react-webpack的安装" class="headerlink" title="generator-react-webpack的安装"></a>generator-react-webpack的安装</h5><h5 id="在全局安装yeoman-和-generator-react-webpack"><a href="#在全局安装yeoman-和-generator-react-webpack" class="headerlink" title="在全局安装yeoman  和 generator-react-webpack"></a>在全局安装yeoman  和 generator-react-webpack</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g yo</span><br><span class="line">npm install -g generator-react-webpack</span><br></pre></td></tr></table></figure><h5 id="初始化项目目录，使用generator-react-webpack生成项目目录"><a href="#初始化项目目录，使用generator-react-webpack生成项目目录" class="headerlink" title="初始化项目目录，使用generator-react-webpack生成项目目录"></a>初始化项目目录，使用generator-react-webpack生成项目目录</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir react_demo</span><br><span class="line">cd react_deom</span><br><span class="line">yo react-webpack</span><br></pre></td></tr></table></figure><h5 id="项目运行"><a href="#项目运行" class="headerlink" title="项目运行"></a>项目运行</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure><h4 id="react项目目录介绍"><a href="#react项目目录介绍" class="headerlink" title="react项目目录介绍"></a>react项目目录介绍</h4><p><img src="<https://blueskyadd.github.io/myPicture/react/1.png" width="550" hegiht="313" align=center> </p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;写在前面的话&quot;&gt;&lt;a href=&quot;#写在前面的话&quot; class=&quot;headerlink&quot; title=&quot;写在前面的话&quot;&gt;&lt;/a&gt;写在前面的话&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;react 作为目前前端的主流框架，各大公司也都在使用。react是一套基于视图层的框架，核心库只关注于视图层，跟vue一致（vue参照了react）。react专注于组件化开发，使用jsx语法（javascript xml  – 类xml语法—-要求所有写的视图代码必须包含在同一个父级标签中—-vue中的template），内涵虚拟DOM（ 所有内容并不是一开始就写到了index.html中，使用jsx语法构建，最后渲染到了index.html页面中），使用diff算法（ 状态的改变，会引起视图的二次渲染，比较状态树变化的算法），会比vue更加适合团队开发模式，以至于react成了一项必备技能。我个人其实是一直在使用vue，不过为了迎合市场也开始了react的学习之路，接下来我会将&lt;strong&gt;react&lt;/strong&gt;、&lt;strong&gt;redux&lt;/strong&gt;、&lt;strong&gt;react-router&lt;/strong&gt;一步一步来进行整理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- &lt;img src=&quot;./img/backgroundImg/4.jpg&quot; width=&quot;850&quot; hegiht=&quot;313&quot; align=center /&gt; --&gt;
&lt;h3&gt;01-构建项目&lt;/h3&gt;

&lt;h4 id=&quot;01-1-create-react-app-快速构建项目&quot;&gt;&lt;a href=&quot;#01-1-create-react-app-快速构建项目&quot; class=&quot;headerlink&quot; title=&quot;01-1 create-react-app 快速构建项目&quot;&gt;&lt;/a&gt;01-1 create-react-app 快速构建项目&lt;/h4&gt;&lt;h5 id=&quot;creat-react-app优点&quot;&gt;&lt;a href=&quot;#creat-react-app优点&quot; class=&quot;headerlink&quot; title=&quot;creat-react-app优点&quot;&gt;&lt;/a&gt;creat-react-app优点&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;无需配置：官方的配置堪称完美，几乎不用你再配置任何东西，就可以上手开发项目。&lt;/li&gt;
&lt;li&gt;高集成性：集成了对React，JSX，ES6和Flow的支持。&lt;/li&gt;
&lt;li&gt;自带服务：集成了开发服务器，你可以实现开发预览一体化。&lt;/li&gt;
&lt;li&gt;热更新：保存自动更新，让你的开发更简单。&lt;/li&gt;
&lt;li&gt;全兼容性：自动处理CSS的兼容问题，无需添加-webkit前缀。&lt;/li&gt;
&lt;li&gt;自动发布：集成好了发布成品功能，编译后直接发布，并且包含了sourcemaps功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;creat-react-app的安装&quot;&gt;&lt;a href=&quot;#creat-react-app的安装&quot; class=&quot;headerlink&quot; title=&quot;creat-react-app的安装&quot;&gt;&lt;/a&gt;creat-react-app的安装&lt;/h5&gt;&lt;p&gt; windows系统下：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm install -g create-react-app&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
  </entry>
  
</feed>
