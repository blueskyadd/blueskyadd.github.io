{"pages":[{"title":"categories","text":"23333333333333333333333333","link":"/categories/index.html"},{"title":"","text":"heiheihei","link":"/about/index1.html"},{"title":"","text":"🎈🎈微笑墙🎈🎈 彭小苒 唐艺昕 李一桐 gakki 图片搜集于互联网，侵权请留言，马上处理😊。","link":"/album/index.html"},{"title":"","text":"个人简介 分享很喜欢的老罗的一段话： “每一个生命来到世间都注定改变世界，别无选择。要么变得好一点，要么变得坏一点。你如果走进社会为了生存为了什么不要脸的理由，变成了一个恶心的成年人社会中的一员，那你就把这个世界变得恶心了一点点。如果你一生刚正不阿，如果你一生耿直，没有做任何恶心的事情，没做对别人有害的事情，一辈子拼了老命勉强把自己身边的几个人照顾好了，没有成名没有发财，没有成就伟大的事业，然后耿着脖子一生正直，到了七八十岁耿着脖子去世了。你这一生是不是没有改变世界？你还是改变世界了，你把这个世界变得美好了一点点。因为世界上又多了一个好人。“ 善恶终有报,天道好轮回。不信抬头看,苍天饶过谁。无论何时何地，我们都要保持一颗积极乐观、善良感恩的心。但行好事莫问前程，永远年轻，永远热内盈眶，永远保持正能量。💪💪💪💪💪💪冲鸭！！！！ -&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;个人信息：计算机科学与技术专业从事JAVA后端开发码畜一枚坚信代码改变世界 博客信息 网站采用的Icarus主题 追求尽可能的简洁，清晰，易用。 在Icarus主题之上进行了部分修改。 更新日志：–2020.09.20：icarus4.0适配–2020.01.18：icarus3.0适配–2019.11.17：增加深色主题开关–2019.10.30：去图，精简卡片–2019.10.22：改版部分显示，优化速度–2019.10.16：文章列表加上评论数显示–2019.10.13：改版评论–2019.09.25：图片、资源接入CDN免费jsDelivr、文章加入置顶–2019.09.19：开源博客代码–2019.09.19：修改布局，拉伸布局，更宽的展示–2019.09.18：修改友链ui为一行三个，并适配移动端，暗黑模式文章增加评论链接，增加留言链接–2019.09.14：增加精简next主题–2019.09.14：利用中秋节放假，重做了首页的热门推荐、加个widget最新评论框、归档页加入文章贡献概览面板 本站推荐索引 博客主题相关 github Issue 作为博客微型数据库的应用 github page网站cdn优化加速 博客源码分享 博客换肤的一种实现方式思路 博客中gitalk最新评论的获取 博客图片上传picgo工具github图传使用 安装、部分配置icarus主题中文版 技术知识点 Java并发知识点 法律法规 法律法规数据库111 中华人民共和国国旗法 中华人民共和国宪法 中华人民共和国消费者权益保护法 中华人民共和国刑事诉讼法 中华人民共和国婚姻法 中华人名共和国网络安全法 中华人民共和国劳动法 其他 网易云音乐歌单分享 计划2020计划 2019.12.31 2020-GOALS 跑两三场马拉松 2019计划 2018.12.31/21:59:00-&gt;更新于2019.12.31 2019-GOALS 购买的专业书籍至少看完一遍（并发、重构、设计模式…）-&gt; 95%额外： 追了很多剧总结： 有优点有缺点，没坚持下来的还是太多，追了太多剧。以后多学习，多思考！ 时间轴记录","link":"/about/index.html"},{"title":"gallery","text":"","link":"/gallery/index.html"},{"title":"","text":"申请友链须知 原则上只和技术类博客交换，但不包括含有和色情、暴力、政治敏感的网站。 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 申请请提供：站点名称、站点链接、站点描述、logo或头像（不要设置防盗链）。 排名不分先后，刷新后重排，更新信息后请留言告知。 会定期清理很久很久不更新的、不符合要求的友链，不再另行通知。 本站不存储友链图片，如果友链图片换了无法更新。图片裂了的会替换成默认图，需要更换的请留言告知。 本站友链信息如下，申请友链前请先添加本站信息： 网站图标：https://removeif.github.io/images/avatar.jpg 网站名称：辣椒の酱 网站地址：https://removeif.github.io 网站简介：后端开发，技术分享 加载中，稍等几秒…","link":"/friend/index.html"},{"title":"","text":"&nbsp;&nbsp;听听音乐 音乐播放器由mePlayer提供，布局参照网友博客所作，感谢作者的辛勤付出。更多音乐分享请查看歌单。 &nbsp;&nbsp;看看视频 -&gt;点击以下条目开始播放视频,向下滑动查看更多&lt;-","link":"/media/index.html"},{"title":"音乐歌单收藏","text":"温馨提示：选择喜欢的音乐双击播放，由于版权原因部分不能播放。如果喜欢歌单收藏一下，去网易云都能播放哟！","link":"/music/index.html"},{"title":"","text":"来而不往非礼也畅所欲言，有留必应","link":"/message/index.html"},{"title":"node","text":"","link":"/node/index-1.html"},{"title":"node","text":"hexo new page categories","link":"/node/index.html"},{"title":"promise的简单理解","text":"promise的基本语法 新建一个promise很简单，只需要new一个promise对象即可。所以promise本质上就是一个函数，它接受一个函数作为参数，并且会返回promise对象，这就给链式调用提供了基础。1234new Promise(function(resolve, reject) { //待处理的异步逻辑 //处理结束后，调用resolve或reject方法}) promise的几种状态 其实Promise函数的使命，就是构建出它的实例，并且负责帮我们管理这些实例。而这些实例有以下三种状态： 1. pending: 初始状态，位履行或拒绝 2. fulfilled: 意味着操作成功完成 3. rejected: 意味着操作失败 pending 状态的 Promise对象可能以fulfilled状态返回了一个值，也可能被某种理由（异常信息）拒绝（reject）了。当其中任一种情况出现时，Promise 对象的then方法绑定的处理方法（handlers）就会被调用，then方法分别指定了resolve方法和reject方法的回调函数 几种状态的深入理解* 一个promise可能有三种状态：等待（pending）、已完成（fulfilled）、已拒绝（rejected） * 一个promise的状态只可能从“等待”转到“完成”态或者“拒绝”态，不能逆向转换，同时“完成”态和“拒绝”态不能相互转换 * promise必须实现then方法（可以说，then就是promise的核心），而且then必须返回一个promise，同一个promise的then可以调用多次，并且回调的执行顺序跟它们被定义时的顺序一致 * then方法接受两个参数，第一个参数是成功时的回调，在promise由“等待”态转换到“完成”态时调用，另一个是失败时的回调，在promise由“等待”态转换到“拒绝”态时调用。同时，then可以接受另一个promise传入，也接受一个“类then”的对象或方法，即thenable对象。 promise缺点* 一旦新建它就会立即执行，无法中途取消 * 如果不设置回调函数，Promise内部抛出的错误，不会反应到外部 * 当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）","link":"/promise/index.html"},{"title":"","text":"碎碎念 tips：github登录后按时间正序查看、可点赞加❤️、本插件地址..「+99次查看」 碎碎念加载中，请稍等… $.getScript(\"/js/gitalk_self.min.js\", function () { var gitalk = new Gitalk({ clientID: 'ff2be2cdbc9e2b468c06', clientSecret: 'ed81438221a18738b2c235cfc98658347e08b849', id: '666666', repo: 'issue_database', owner: 'Blog', admin: \"blueskyadd\", createIssueManually: true, distractionFreeMode: false }); gitalk.render('comment-container1'); });","link":"/self-talking/index.html"},{"title":"相遇黄山","text":"黄山北站集合 2019年 07-20 这次黄山之行已经过去很久了，今天闲来无事决定记录一下 阿静: 天娇啊我准备去婺源看看 我: 哇，等我两天呗，和你一块去没错这次路程就这样开始了，出发先前还想着报团去玩，结果呢，，，没错就是太贵了，果断放弃。自己来玩吧。各种找攻略，找了找之后决定先到黄山集合，然后转上饶，最后去婺源。 计划很完美现实很骨感，到了黄山后已经晚上了（表示本大仙下班后去的黄山）在黄山老街的一家旅社住下了，想着明天早起去逛一逛老街然后买好多好多好吃的。哈哈结果一觉睡到早上八点多，真的很意外，外面出奇的安静，诡诡异异的感觉，和想象中完全不一样好吧。 心想着罢了罢了,既来之则安之.洗漱过之后就准备在老街这边逛逛，结果呢，感觉出乎意料的好。 经过昨晚大于的洗刷之后，空气格外的清晰。稀稀疏疏的几个旅人，悠哉的走在这江南小镇上，感觉整个时间都慢了下来，在城市的喧嚣之外也有很多人过着这样的生活。不禁羡慕起来，但是吧想一想生活有动有静才是生活。拍了几张清晨老街的照片 接着准备出发爬黄山，但是呢各种临时起意后决定先去宏村。旅行嘛说走就走，怎么开心怎么来，有朋友陪着这就足够了hexo new page gallery","link":"/tags/index.html"}],"posts":[{"title":"TS入门（一）","text":"TypeScript 是一种由微软开发的自由和开源的编程语言，它是JavaScript的一个超集，扩展了JavaScript的语法。 参考资料：阮一峰大神 （https://ts.xcatliu.com/） 1、#JavaScript 与 TypeScript 的区别： TypeScript 是 JavaScript 的超集，扩展了 JavaScript 的语法，因此现有的 JavaScript 代码可与 TypeScript 一起工作无需任何修改，TypeScript 通过类型注解提供编译时的静态类型检查。TypeScript 可处理已有的 JavaScript 代码，并只对其中的 TypeScript 代码进行编译。 2、TypeScript的优缺点：优点： 增加了代码的可读性和可维护性 可以在编译阶段就发现大部分错误，这总比在运行时候出错好 增强了编辑器和 IDE 的功能，包括代码补全、接口提示、跳转到定义、重构等 包容 即使不显式的定义类型，也能够自动做出类型推论 可以定义从简单到复杂的几乎一切类型 即使 TypeScript 编译报错，也可以生成 JavaScript 文件 兼容第三方库，即使第三方库不是用 TypeScript 写的，也可以编写单独的类型文件供 TypeScript 读取 缺点 工作量大","link":"/2019/05/31/FirstNight/"},{"title":"bat文件执行 npm run dev","text":"发现每次运行项目都需要一步步进入到项目文件，然后点开cmd 执行npm run dev，确实很麻烦很多余，最近发现了bat脚本可以直接运行 npm run dev省了很多时间,下面是bat文件的代码，可以直接放在桌面上，双击既可运行项目；123456e: //项目放在E盘中cd work //E盘下面的文件夹cd woling_coach //我的项目文件夹cd wolingJL //我的项目名字set startDir=%cd% npm run dev //运行npm run dev使用时将文件目录换成自己的即可","link":"/2019/05/31/bat/"},{"title":"怎么愉快的通过线上地址访问我们的照片","text":"创建git仓库首先打开gitHub官网地址然后创建一个GIt仓库来存放我们的图片然后填写相应的项目信息 上传图片信息后打开setting 其次在创建的图片仓库的设置中找到GitHub Pages，将Source中的none设置为master branch， 随即你便可以将在你的GitHub Pages存放和查看你仓库中的文件（github上项目运行演示也是如此） 接着在地址栏中输入上图中github pages中的项目地址，在后面加上你想要的图片的图片名，便可以在线展示","link":"/2019/07/25/githubUPdataImg/"},{"title":"hexo Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/05/31/hello-world/"},{"title":"IOSAPP真机测试及上架App Store流程","text":"第一步：申请iOS苹果开发者账号首先先看一下ios不同账号的区别 这里以公司账号为例 此账号是在个人普通账号上申请的， 1、申请个人apple id 如果已经申请过apple id，跳过注册，直接看第2步申请！ 点击此处即可申请个人账号。 按照提示依次填写信息 注册跳转到这个下面这个页面说明苹果账号已经注册成功了。 2、苹果开发者中心提交申请开发者。(1)登录进去苹果开发者中心，由于未付费购买开发者账号，会看到如下内容，点击加入开发者。 (2)进入这个页面，点击注册，再点击开始你的注册。现在申请苹果开发者账号要求开启双重认证才能提交申请。如果未开启点击此教程接下来按照提示依次填写相应信息(3)付款付款成功后，会有个付款邮件反馈过来，确认收到付款，但账号不是马上可以用，快的话付款后十几分钟后就能用，一般要审核一两天，有可能发邮件给你让你上传身份证留意好邮件就行了。 如果收到这种邮件说明审核通过了。 审核成功登录上去]ios开发者中心会出现以下界面 第二步申请所需证书由于发现在IOS开发者中心申请证书需要用到ios电脑，由于条件不满足，所偶另辟新径，找到了一款强大的第三方工具Appuploader。 1、安装iOS上架辅助软件Appuploader无需安装，解压直接使用2、申请 iOS证书文件p12 （ 发布版本同理，只需将类型修改为发布版即可）(1)登录 (2)下载证书 点击右下角+ADD选择 类型：选择开发证书（开发证书打包的才能安装到手机） 输入证书名称：不要中文、随意设置 邮箱：（随意） 密码：证书的密码，不是开发者账号密码，如123这样不用很复杂，记好、打包时要用、很重要。 应用id：这里不用选！ 点击ok创建。 然后点击P12下载即可(3)申请iOS开发证书描述文件mobileprovision 在申请ios描述文件之前，先添加好两样基础信息，应用id及苹果手机设备号udid (4)点击+ ADD，对应选择发布版profile 应用id:选择对应的id（又称套装id，appid，BundleID，包名） 证书：选中全部就行 Devices：设备这里不像选开发版profile时会出现，发布版不用选。 输入名称：不要中文，随意，123之类的就行，注意不要跟之前申请过的名称一样），点击ok创建。 (5)选择刚创建的发布版描述文件（iOS Distribution这个类型的就是发布描述文件，找刚创建的输入的名称），点击Download下载，保存到电脑 (6)打开HBuilder工具，选择开发好的项目，点击发行，选择发行为原生安装包。(7)选择iOS打包，支持的设备类型（可以选择支持iPhone和支持ipad），选择使用苹果证书 AppID：跟申请证书描述.mobileprovision时选择的要一致（又称套装id，appid，BundleID，应用id，包名） profile文件：选择上传配置文件.mobileprovision 私钥证书：上传.p12文件 私钥密码：输入创建p12设置的密码。 (8)安装IPA到手机进行测试(推荐使用爱思助手安装)特别注意：ios不像安卓、不能直接把ipa文件发送到手机安装，需要通过手机助手安装，或者上传分发平台扫二维码安装，如蒲公英，fir这种分发平台。连接上手机、点击应用游戏，点击导入安装，选择刚打包的ipa包，或者直接选择ipa包右键通过爱思助手安装。(9)申请iOS发布证书同开发证书过程相同，勾选发布证书即可(10)登录iTunes Connect，点击我的APP进入创建一个APP进入点击左上角+号选择新建APP，选择平台iOS， 应用名称：APP的名称 语言：APP的语言，中文还是英文。 套装ID：（应用id、appid、包名，跟申请证书使用的要保持一致） sku：不能写中文，自己用拼音随便编一个，好识别就行，如app叫淘宝，就输入taobao。 用户访问权限：一般选完全访问权限 (11)Windows环境下上传IPA到App Store Windows环境下上传IPA到App Store 先创建一个APP专用密码，配置到Appuploader软件！ 苹果一种机制，上传ipa需要一个特定的APP专用密码，app-specific password 打开网站https://appleid.apple.com/zh_CN登录苹果开发者账号 登录进去找到安全项目，点击生成专用密码。 密码标签随便输入，123，app等之类的都行。 点击创建生成，（注意密码标签不是专用密码，是由苹果系统生成的一串密码）专用密码就是下面这个样子的密码，把这个密码复制，打开Appuploader 点击右上角，选择设置，把上传专用密码复制上去，同时勾选上保存密码，点击Save保存，然后再回去提交ipa上传就可以正常上传了。 (12)上传输入专用密码点击OK保存后，点击单个ipa按钮提交 选择刚打包测试没问题的ipa包 上传成功 (13)上传成功后到后台查看上传的版本 packages were uploaded successfully 进度条蓝色，ipa上传成功后，登录iTunes Connect https://itunesconnect.apple.com/login后台查看上传的ipa (14)设置APP各项信息提交审核 (15)选择左边第三项准备提交进入、这个页面需要设置几项信息、一步一步来。 先设置app截图！因为现在苹果规则的改变，iPhoneX刘海屏6.5的截图 (16)提交审核回到我的APP查看会提示正在等待审核，审核有时很快一两天，或要几天时间，常登陆看看审核情况，或看邮件提示。","link":"/2019/07/27/iosUpload/"},{"title":"Element-ui Cascader 级联选择器 同时返回 value 和 label","text":"给 cascader 组件赋值一个别名 ref=”cityData” 1234567&lt;el-cascader ref=&quot;cityData&quot; placeholder=&quot;请输入所属区域&quot; :options=&quot;options&quot; v-model=&quot;area&quot; &gt; &lt;/el-cascader&gt; 在 2.9.2 后官方新增了 getCheckedNodes() 方法 该方法返回选中节点的 array，如果是单选的话，使用1this.$refs.cityData.getCheckedNodes()[0].pathLabels ps: 城市JS 点击下载","link":"/2020/02/16/label/"},{"title":"node入门(一) -node的简单理解","text":"刚开始学习前端的时候接触过一点node,不过技术这种东西，一段时间不用就忘光了。现在想着重新捡起来，慢慢的从头开始看一下。打算借助node 的 Express框架来学习, 一、什么是node百度搜一下node百度百科上很清晰的写着：Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型。node.js就是把浏览器的解释器封装起来作为服务器运行平台，用类似javascript的结构语法进行编程，在node.js上运行。简而言之，Node 为我们提供了一个无需依赖浏览器、能够直接与操作系统进行交互的 JavaScript 代码运行环境！ 二、为什么要学习node其实前端要想走向全栈，必须是要接触后端语言的。那么对于前端来说，node时最合适的，虽然用node来做大型项目也是不现实的的，但是自己做一个小网站是绝对够用的。 三、node可以用来做什么可以帮助我们快速搭建站点，而且轻量级的特点。看到过一个技术文章降解的非常详细nodejs可以用来做什么 四、node的安装 (1):下载官方的下载地址点击跳转;官网有很多版本，不过并不推荐下载最新版本，可以根据需要自行下载； (2):安装步骤一:下载完成后双击安装包,显示如下页面,点击next.步骤二:勾选“I accept the terms in the License Agreement”同意许可协议，并单击Next下一步，出现如下界面：步骤三:Node.js默认安装路径为“C:\\Program Files\\nodejs\\”，你可以修改，在这里我改到了D盘，单击Next.不过最好默认路径免去一些麻烦步骤四：这里我直接默认Next下一步，准备就绪，准备安装：步骤五：确认无误后，点击Install，开始安装：步骤六：半分钟后，安装完成，点击Finish即可步骤七：最后运行node -v可查看node版本","link":"/2019/09/20/nativeEquipment/"},{"title":"node入门(二) -浅析Express开发框架","text":"如果想用node快速的搭建一个WEB站点，那么可以选择Express 框架，Express是基于 Node.js 平台，快速、开放、极简的 Web 开发框架. 一、初始化安装Express (1)全局安装Express1npm install express-generator -g 安装的时候有的可能会报错，原因是没有node的操作权限。解决此问题要以管理员身份运行cmd，执行下列代码。1set-ExecutionPolicy RemoteSigned然后选择’全是’ (2)然后运行-h就可以列出所有可用的命令行参数：1express -h (3)然后运行下面代码创建名为‘myapp’的项目1express --view=pug myapp (4)安装项目依赖并运行项目123cd myappnpm installnpm start 至此输入http://localhost:3000/#/ 项目就运行起来了","link":"/2019/10/25/nodeTwo/"},{"title":"调用手机扫描二维码功能","text":"调用Hbuilder 二维码plus模块 来实现 二维码扫描功能,二维码的状态和使用最好在vuex中赋值，以方便控制。在mounted阶段调用下面代码片段12345678910111213141516171819202122232425262728293031323334353637startRecognize(){ let that = this if (!window.plus) return // 使用vuex来创建scan二维码 that.$store.commit('changescan', new plus.barcode.Barcode('qrcode')) // 设置扫描之后的函数回调 that.$store.commit('changeonmarked',onmarked) // 开始扫描 that.$store.commit('staticScan') //设置扫描二维码页面样式，根据需求自行调整 barcode.setStyle({ background:'#8f9494', height:&quot;100%&quot; }); //成功之后的函数回调 function onmarked(type, result, file) { switch (type) { case plus.barcode.QR: type = 'QR' break case plus.barcode.EAN13: type = 'EAN13' break case plus.barcode.EAN8: type = 'EAN8' break default: type = '其它' + type break } // 获得扫描的二维码路径 result = result.replace(/\\n/g, '') //在data中设置变量codeUrl that.codeUrl = result }}在退出二维码页面时需要将二维码扫描关闭，不然会一直在页面中显示1this.$store.commit('closeScan') 下面是vuex 中的的调用 1234567891011121314151617181920212223242526const state = { scan:null }const mutations = { //创建 changescan(state, data) { state.scan = data }, //成功回调 changeonmarked(state, data){ state.scan.onmarked = data }, //开始扫描 staticScan(state){ state.scan.start(); }, //关闭二维码 closeScan(state){ state.scan.close(); }}export default { state, mutations} 另外在Android移动端需要控制物理返回键退出二维码页面,在APP.vue 的mounted阶段调用此函数 12345678910111213141516171819202122232425262728293031323334bindBack() { let vm = this; let first = null; plus.key.addEventListener(&quot;backbutton&quot;, () =&gt; { if ( this.$route.name == &quot;LabManagerIndex&quot; || this.$route.name == &quot;LogingIndex&quot;|| this.$route.name == &quot;gaugerIndex&quot;|| this.$route.name == &quot;EquipmentengineerIndex&quot; ) { //此处是需要直接退出app的页面路由 if (!first) { first = new Date().getTime(); //记录第一次按下回退键的时间 plus.nativeUI.toast(&quot;再按一次退出应用&quot;); setTimeout(function() { //1s中后清除 first = null; }, 2000); } else { if (new Date().getTime() - first &lt; 2000) { //如果两次按下的时间小于1s， plus.runtime.quit(); //那么就退出app } } }else if(this.$route.name == 'QRcodeIndex'){ //二维码页面 this.$router.back(-1) this.$store.commit('closeScan') }else{ this.$router.back(-1) } }); },","link":"/2019/08/28/qrcode/"},{"title":"promise的简单理解","text":"promise的基本语法 新建一个promise很简单，只需要new一个promise对象即可。所以promise本质上就是一个函数，它接受一个函数作为参数，并且会返回promise对象，这就给链式调用提供了基础。 1234new Promise(function(resolve, reject) { //待处理的异步逻辑 //处理结束后，调用resolve或reject方法}) promise的几种状态 其实Promise函数的使命，就是构建出它的实例，并且负责帮我们管理这些实例。而这些实例有以下三种状态： 1. pending: 初始状态，位履行或拒绝 2. fulfilled: 意味着操作成功完成 3. rejected: 意味着操作失败 pending 状态的 Promise对象可能以fulfilled状态返回了一个值，也可能被某种理由（异常信息）拒绝（reject）了。当其中任一种情况出现时，Promise 对象的then方法绑定的处理方法（handlers）就会被调用，then方法分别指定了resolve方法和reject方法的回调函数 几种状态的深入理解 一个promise可能有三种状态：等待（pending）、已完成（fulfilled）、已拒绝（rejected） 一个promise的状态只可能从“等待”转到“完成”态或者“拒绝”态，不能逆向转换，同时“完成”态和“拒绝”态不能相互转换 promise必须实现then方法（可以说，then就是promise的核心），而且then必须返回一个promise，同一个promise的then可以调用多次，并且回调的执行顺序跟它们被定义时的顺序一致 then方法接受两个参数，第一个参数是成功时的回调，在promise由“等待”态转换到“完成”态时调用，另一个是失败时的回调，在promise由“等待”态转换到“拒绝”态时调用。同时，then可以接受另一个promise传入，也接受一个“类then”的对象或方法，即thenable对象。 promise缺点 一旦新建它就会立即执行，无法中途取消 如果不设置回调函数，Promise内部抛出的错误，不会反应到外部 当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）","link":"/2020/04/21/promise/"},{"title":"react基础（一）","text":"写在前面的话 react 作为目前前端的主流框架，各大公司也都在使用。react是一套基于视图层的框架，核心库只关注于视图层，跟vue一致（vue参照了react）。react专注于组件化开发，使用jsx语法（javascript xml – 类xml语法—-要求所有写的视图代码必须包含在同一个父级标签中—-vue中的template），内涵虚拟DOM（ 所有内容并不是一开始就写到了index.html中，使用jsx语法构建，最后渲染到了index.html页面中），使用diff算法（ 状态的改变，会引起视图的二次渲染，比较状态树变化的算法），会比vue更加适合团队开发模式，以至于react成了一项必备技能。我个人其实是一直在使用vue，不过为了迎合市场也开始了react的学习之路，接下来我会将react、redux、react-router一步一步来进行整理。 01-构建项目 01-1 create-react-app 快速构建项目creat-react-app优点 无需配置：官方的配置堪称完美，几乎不用你再配置任何东西，就可以上手开发项目。 高集成性：集成了对React，JSX，ES6和Flow的支持。 自带服务：集成了开发服务器，你可以实现开发预览一体化。 热更新：保存自动更新，让你的开发更简单。 全兼容性：自动处理CSS的兼容问题，无需添加-webkit前缀。 自动发布：集成好了发布成品功能，编译后直接发布，并且包含了sourcemaps功能。 creat-react-app的安装 windows系统下： 1npm install -g create-react-app 创建react项目安装完成后，就可以使用create-react-app来生成react项目的项目目录– projectName：项目名称 1create-react-app projectName 启动项目然后进入到项目内 通过npm来安装项目依赖 1npm start 01-2 generator-react-webpack 快速构建项目我也是第一次使用它，各种百度后发现它其实是基于webpack构建的，只不过是进一步完善了webpack，它可以支持ES6，并且集成了Babel-Loader等。简单来说使用它之后省去了我们自己手动配置webpack,对于我这种不熟悉webpack配置的小白来说极其方便。 generator-react-webpack优点 基于webpack构建，可以很容易的配置自己需要的webpack。 支持ES6，集成了Babel-Loader。 支持不同风格的CSS（sass，less，stylus）。 支持PostCSS转换样式。 集成了esLint功能。 可以轻松配置单元测试，比如Karma和Mocha 包含热加载 generator-react-webpack的安装在全局安装yeoman 和 generator-react-webpack12npm install -g yonpm install -g generator-react-webpack 初始化项目目录，使用generator-react-webpack生成项目目录123mkdir react_democd react_deomyo react-webpack 项目运行1npm start react项目目录介绍","link":"/2020/04/13/react%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"如何将Android App 发布到 腾讯应用宝","text":"第一步 ：首先打开腾讯开放平台 第二步、注册信息1、打开页面后登录，如果是公司团队开发最好重新申请qq账号，避免不必要的麻烦。登录之后在首页选择应用接入，开始进行开发者申请。2、点击后选择注册类型 个人或者企业，以企业为例： 3、进入企业注册页面后首先填写公司相应的资料信息，注意上传图片的大小格式。 然后依次进行邮箱验证 最后完成注册，至此我们已经完成开发账号的创建； 第三步、创建应用1、若未在QQ互联创建过应用，直接在此页面选择“创建应用”即可，请勿选择关联QQ互联。 2、若已在QQ互联创建过应用，可在创建应用时选择关联QQ互联，输入在QQ互联创建的网页应用APPID、APPKEY即可完成关联。 3、选择应用类型，这里选择软件自己的APP类型即可 4、然后进一步完善信息 5、上传加固安装包（1）安装包等级处理 上传到应用宝、华为应用平台时出现错误：“装包的API等级(targetSdkVersion)必须等于或高于26，请重新打包上传”,加入以下字段即可。 &lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&amp;quot;minSdkVersion&amp;quot;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;14&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&amp;quot;targetSdkVersion&amp;quot;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;26&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt; （2）安装包加固 之后在上传安装包时会提示我们说“未加固应用，可能无法审核通过，应用宝将不予曝光和搜索”。 （3）安装乐谷加固为了保护我们的劳动成果和知识产权，必须对APK对加固工作，否则极易被人破解、篡改，二次打包。市面上当前做加固的有很多家，实际使用了腾讯乐固和360加固（看了网易也有易盾，但是因为只能试用，所以没试）。本文介绍腾讯乐固的使用方法。首先点击下载 乐固加固,使用微信登陆即可。 直接点击下一步即可安装,安装过完成的界面 完成后登陆时我们需要创建一个密钥，点击这里,来创建秘钥以供登录使用。 （4）加固应用登陆之后来到首页，首先创建应用，选择打包好的apk文件,注意要使用自有证书。详情请见另一片文章 上传成功后，会显示一下界面 然后点击下一步 提交完成后，会自动下载到同名文件下，我们只需将生成好的加固文件（包含签名的一个）上传到腾讯应用宝即可 6、最后提交审核 注： 可通过ps直接修改：点击图像 –》图像大小然后改为相应像素；","link":"/2019/07/25/relaseAndroid/"},{"title":"node入门(三) -如何使用node上传图像到服务器","text":"一、首先配置MongoDB，在node中连接(1):下载安装MongoDb 官方下载链接： 下载地址 下载 Windows 64-bit x64 msi 格式的，完事直接傻瓜式安装（切记记住安装位置）。 为了方便使用，可以下载一个mongodb的可视化工具，Robo 3T.(下方有下载地址) 链接：https://pan.baidu.com/s/16Jr6ezRuM0y9KM5CppUEwg 提取码：bqnh 下载完成后，先打开mongodb的安装目录,打开bin文件夹然后双击mongod.exe， 运行成功后打开浏览器，输入127.0.0.1:27017如果看到下图提示则表示","link":"/2019/12/16/threeNode/"},{"title":"app沉浸式导航栏相关处理","text":"在移动端，很多的app都需要设置沉浸式导航栏，但是手机适配又成了一个很大的问题，所以通过获取手机状态栏高度，再增加页面padding的方法应该是最好的，可以适应各种妖孽手机，首先需要在HBuilder的配置文件中设置沉浸式导航，找到manifest.json文件下的plus对象，然后贴如下面代码：123&quot;statusbar&quot;: { &quot;immersed&quot;: true/*沉浸式状态栏*/},下面代码片段是获取移动端状态栏高度的。注：此代码写在main.js中12345678910111213141516171819202122232425262728//由于plus模块需要加载，所以这里我使用了延时处理setTimeout(()=&gt;{ if(window.plus){ //首先判断当前设备是否支持沉浸式导航栏，如果不支持不做处理 var isImmersedStatusbar = plus.navigator.isImmersedStatusbar(); if (isImmersedStatusbar) { //获取当前设备状态栏高度 var StatusbarHeight = plus.navigator.getStatusbarHeight(); //当前机型如果是iPhoneX，则在原基础上增加15像素。 //获取到高度后在vue的原型上增加StatusbarHeight属性，方便后续使用 if (plus.device.model.toString() == 'iPhoneX') { Vue.prototype.$StatusbarHeight = StatusbarHeight + 15; } else { Vue.prototype.$StatusbarHeight = StatusbarHeight; } } //此处设置了状态栏文字的颜色---dark为黑色/light为白色 plus.navigator.setStatusBarStyle('dark'); //在处理结束后页面再出来，否则会出现抖动现象 new Vue({ el: '#app', router, store, components: { App }, template: '&lt;App/&gt;' }) }},100)在获取到高度后，在app.vue页面来给#app增加padding值，这里一劳永逸型，哈哈。1:style=&quot;{paddingTop:`${$StatusbarHeight}px`}&quot;如果有个别状态栏背景色不一样的，可以给#app动态添加class来解决，","link":"/2019/08/28/tablebar/"},{"title":"TS - interfaces  初探","text":"interfaces英文翻译为接口，百度百科上解释为interface是面向对象编程语言中接口操作的关键字，功能是把所需成员组合起来，用来装封一定功能的集合。那么它在ts这个语言中究竟扮演怎样的角色，有什么用途。 interfaces 是什么理解起来 interfaces就是约定了一个编程的规范而已，它规定了要实现的一系列方法和属性。也就是说interface其实是一种描述对象或函数的东西，它是一种约束形式，比如一个对象需要有什么样的属性，函数需要什么参数或返回什么样的值，数组应该是什么样子的，一个类和继承类需要符合什么样的描述等等。 了解了interface是什么，那么在不同的情况下我们怎么去使用interfaces呢？ interfaces 怎么用对象 Interface 定义对象需要的属性 设置可选属性 设置只读属性 可以通过 as 或 [propName: string]: any 来定义对象属性的数据类型 例子：12345678910111213interface people { Name : String, age:number, height?: number,//设置可选属性，可有可恶✅ readonly gender:String, //设置只读属性✅}const zhangSan:people = { Name: &quot;张三&quot;, age:1, gender:'男'}zhangSan.gender = &quot;女&quot;//报错，只读属性不可修改 ❌ 函数 Interface 定义函数接口 定义函数入参的类型 使用函数表达式 调用函数，写入出参 例子：1234567891011interface Fun {( x:string,//定义函数接收的第一个必选参数为string类型✅ y:number,//定义函数接收的第二个必选参数为number类型✅ z?:boolean,//定义函数接收的第三个可选参数为boolean类型✅)}const add: Fun = function (x:string, y:number, z = false){ console.log(x, y, z)}add('张三',12) 可索引的类型我们也可以描述那些能够“通过索引得到”的类型，例如arr[0]。可索引类型具有一个索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。 定义一个可索引类型 设置索引类型 定义数组调用该规范 例子：12345678910interface StringArray { readonly [index: number]:string, //❗ 需要注意的是 index 只能为 number 类型或 string 类型 length: number //指定属性👀}let arr1: StringArray = [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;] arr1[1] = &quot;4&quot; // ❌ 由于索引设置为只读属性，arr1[1]不能赋值let arr: StringSet = [23,12,3,21] // ❌ 数组应为 string 类型 类 Interface 实现（implements）是面向对象中的一个重要概念。一个类只能继承自另一个类，不同类之间可以有一些共有的特性，就可以把特性提取成接口（interfaces），用 implements 关键字来实现。 Interface 也可以用来定义一个类的规范。需要注意的是类 Interface 只会检查实例的属性，静态属性是需要额外定义一个 Interface；例如：12345678910111213141516171819202122232425262728// ? PersonConstructor 是用来检查静态部分的interface PersonConstructor { new (name: string, age: number) // ✔️ 这个是用来检查 constructor 的 typename: string // ✔️ 这个是用来检查静态属性 typename 的 logname(): void // ✔️ 这个用来检查静态方法 logname 的}// ? PersonInterface 则是用来检查实例部分的interface PersonInterface { // new (name: string, age: number) // ❌ 静态方法的检查也不能写在这里 这样写是错误的 log(): void // : 这里定义了实例方法 log}// class Person implements PersonInterface, PersonInterface { ❌ 这样写是错误的const Person: PersonConstructor = class Person implements PersonInterface { name: string age: number static typename = 'Person type' // 这里定义了一个名为 typename 的静态属性 static logname() { // 这里定义了一个名为 logname 的静态方法 console.log(this.typename) } constructor(name: string, age: number) { // constructor 也是静态方法 this.name = name this.age = age } log() { // log 是实例方法 console.log(this.name, this.age) }} 接口间的继承 接口可以通过其他接口来扩展自己。 Typescript 允许接口继承多个接口。 继承使用关键字 extends。 1. 单接口继承extends 关键字后加继承的接口123456789101112interface Person { name: string, age: number}interface Students extends Person { gender: string}const foo: Students = { name: 'why', age: 18, gender: 'female'} 2. 多接口继承多接口之间逗号分隔1234567891011121314interface Sing { sing(): void}interface Jump { jump(): void}interface Rap extends Sing, Jump { rap(): void}const foo: Rap = { sing(){}, jump(){}, rap(){}} 3. 接口继承类常见的面向对象语言中，接口是不能继承类的，但是在 TypeScript 中却是可行的用extends关键字继承类123456789101112131415161718class Person { name: string age: number constructor(name: string, age: number) { this.name = name this.age = age } run(): void { }}interface User extends Person { gender: string}const foo: User = { name: 'foo', age: 18, gender: 'male', run():void { }} 友情链接：es6中class类静态方法，静态属性理解，实例属性，实例方法理解extends和implements区别 参考资料https://www.jianshu.com/p/099c5683ffb5https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Interfaces.htmlhttps://cloud.tencent.com/developer/article/1411764","link":"/2020/07/15/ts-interfaces/"},{"title":"HBuilder 开发，Android自有证书生成及打包","text":"1、打开config/index.js 文件修改build 下的assetsPublicPath路径1assetsPublicPath: '/', 改为 assetsPublicPath: './',2、打开build/utils.js文件 搜索‘publicPath’ 修改为1publicPath: '../../' 第二步、生成安装包所需证书 安装包生成 可以使用DCloud 的HBuilder 或者APICloude 。双方各有其优点，这里以HBuilder 为例。 1、首先是Android的证书文件生成，首先勾选使用自有证书： 2、下一步生成证书文件 生成Android 证书的前提是安装Java的JDK到本地，JDK 安装包被集成在 Java SE 中，因此下载 Java SE 即可，具体步骤如下 (1).打开Java jdk此页面下载安装包 (2).点击Accept License Agreement，下载适合自己电脑版本的JDK.由于我的电脑是windows10 64位专业版，所以我选择的是最后一个。(3).下载完成之后安装（下一步即可）注意一下安装路径，下面要用 (4).环境配置注：这里描述可能不够详细我只做记录使用,可以点击此文章查看详细教程(I)右键电脑属性，打开高级系统设置。(II)点击高级，再点击环境变量。(III)新建系统变量JAVA_HOME，变量值输入你的安装路径(Ⅳ)找到自己系统变量里的Path,双击，找到编辑文本点击，在变量值的最后添加 %USERPROFILE%\\AppData\\Local\\Microsoft\\WindowsApps(IV)新建系统变量CLASSPATH，变量值填 .;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar（注意这个变量值前面还有一个点，代表从当前路径）(Ⅵ).测试是否安装成功，cmd打开dos系统。输入java,如果显示下面内容就表示安装成功。 (5)运行成功后进入到安装Java jdk的bin目录下，以管理员身份打开powershell窗口，运行下面代码 -alias mydemoapp –表示别名，自定义修改 -keyalg RSA –产生键的加密算法 -validity 40000 –有效期限4000天，自定义修改 -keystore myapp.keystore –表示最后生成的证书文件名，自定义修改 -sigalg SHA1WithRSA –很重要否则在打包时会提示证书不是有效的keystore文件，因为HBuilder解析不了默认的证书格式 -keysize 1024 –很重要否则在打包时会提示证书不是有效的keystore文件，因为HBuilder解析不了默认的证书格式 1keytool -genkey -alias mydemoapp -keyalg RSA -sigalg SHA1WithRSA -validity 40000 -keysize 1024 -keystore myapp.keystore 之后会出现一个填写密钥的窗口，依次输入即可在输入密码时，窗口是不显示的，输入后回车即可输入完成后会生成一个myapp.keystore的文件 如果打包出现证书无效时 需要更改一下证书类型注：自己的证书名称要对应1keytool -importkeystore -srckeystore myapp.keystore -destkeystore myapp.keystore -deststoretype JKS最后查看keystore文件1keytool -list -v -keystore myapp.keystore","link":"/2019/08/15/uploadProject/"},{"title":"TS入门（二）","text":"数据类型(1)布尔值（boolean ）1let isDone: boolean = false; 在 TypeScript 中，boolean 是 JavaScript 中的基本类型，而 Boolean 是 JavaScript 中的构造函数数值（number ） (2)模板字符串:1let sentence: string = `Hello, my name is ${myName}. I'll be ${myAge + 1} years old next month.` 编译结果: 1var sentence = &quot;Hello, my name is &quot; + myName + &quot;.\\nI'll be &quot; + (myAge + 1) + &quot; years old next month.&quot;; 其中 ` 用来定义 ES6 中的模板字符串，${expr} 用来在模板字符串中嵌入表达式。 (3)空值(Void )： JavaScript 没有空值（Void）的概念，在 TypeScript 中，可以用 void 表示没有任何返回值的函数： 声明一个 void 类型的变量没有什么用，因为你只能将它赋值为 undefined 和 null： 1let unusable: void = undefined; Null 和 Undefined： undefined 类型的变量只能被赋值为 undefined，null 类型的变量只能被赋值为 null。 (4)任意值(Any) 来表示允许赋值为任意类型 任意类型的理解：（如果是一个普通类型，在赋值过程中改变类型是不被允许的，但如果是 any 类型，则允许被赋值为任意类型。声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值。—-变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型） 类型推论（如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查：）(5)联合类型 表示取值可以为多种类型中的一种。123let myFavoriteNumber: string | number;myFavoriteNumber = 'seven';myFavoriteNumber = 7 联合类型使用 | 分隔每个类型。(6)对象的类型——接口 接口 在面向对象语言中，接口（Interfaces）是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implements）。 (7)函数的类型声明语句123function sum(x: number, y: number): number { return x + y;} 使用 declare 关键字来定义它的类型，帮助 TypeScript 判断我们传入的参数类型对不对：1declare var jQuery: (selector: string) =&gt; any; （declare 定义的类型只会用于编译时的检查，编译结果中会被删除。） 上例的编译结果是：1jQuery('#foo');","link":"/2019/05/31/typescriptTwo/"},{"title":"VUE页面后退无刷新","text":"离开当前页面时记录当前位置，使用sessionStorage存储数据（其中 wrapbox 当前滚动页面最外层的div ,ref=wrapbox）1234567891011beforeRouteLeave(to, from, next) { //记录离开时的位置__&quot;) sessionStorage.askPositon = this.$refs.wrapbox &amp;&amp; this.$refs.wrapbox.scrollTop; if(to.name=='smission' ||to.name=='buyer'){ sessionStorage.askPositon ='' }//前进时无需记录位置，可以将数据置为空 console.log(&quot;出去的位置&quot;) console.log(sessionStorage.askPositon) next();},进入页面后采用离开时的位置1234567891011121314151617181920beforeRouteEnter(to, from, next) {console.log(sessionStorage.askPositon)if (!sessionStorage.askPositon) {//当前页面刷新不需要切换位置sessionStorage.askPositon = &quot;&quot;;next();} else {next(vm =&gt; { if (vm &amp;&amp; vm.$refs.wrapbox) { console.log(&quot;进来的位置&quot;) console.log(sessionStorage.askPositon); setTimeout(function() { vm.$nextTick(() =&gt; { vm.$refs.wrapbox.scrollTop=sessionStorage.askPositon }); },80); //同步转异步操作 } });}},","link":"/2019/05/31/vueSessionStorage/"},{"title":"vue项目运行后，在IE浏览器打开，页面为空白","text":"解决方案： 一、首先安装babel-polyfill 1npm install --save babel-polyfill 二、在main.js里引入1import 'babel-polyfill'三、在首页index.html中添加 1&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt; 四、配置项目文件build中的webpack.base.conf.js修改如下配置 123entry:{ app:['babel-polyfill','./src/main.js'] }","link":"/2020/07/15/vue/"},{"title":"手机网页版微信分享以及微信授权","text":"微信分享，第一次接触会发现很多坑。网页版微信分享是不支持按钮去分享的，只能通过微信右上角的按钮去分享。通过按钮分享的目前只支持APP。其实这样一来H5的分享就简单了很多。只需要调用微信官方出的微信jssdk，加上些许配置，就可以实现h5页面在微信上的分享，点击进入官方api文档;注意：这里使用的都是微信官方最新的文档 一、首先获取配置所需要的参数 首先使用已有公众号的appid，然后根据这个appid和url向后端发起请求，拿到配置所需要的参数：timestamp( 时间戳)、noncestr(随机字符串)和signature(签名)。所有需要使用JS-SDK的页面必须先注入配置信息，否则将无法调用 二、项目引入微信jssdk 引入方式有两种，各取所需：(1)、通过导入依赖包首先通过npm 安装依赖1npm i -S weixin-js-sdk然后在页面中引入1import wx from 'weixin-js-sdk' (2)通过script标签，引入微信官网的JS-SDK文件 1&lt;script src=&quot;http://res.wx.qq.com/open/js/jweixin-1.4.0.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; 三、通过config接口注入权限验证配置1234567891011wx.config({ debug: false, // 开启调试模式 appId: data.appId, // 必填，公众号的唯一标识 timestamp: data.timestamp, // 必填，生成签名的时间戳 nonceStr: data.nonceStr, // 必填，生成签名的随机串 signature: data.signature, // 必填，签名 jsApiList: [ 'updateTimelineShareData',//自定义“分享到朋友圈”及“分享到QQ空间”按钮的分享内容（1.4.0） 'updateAppMessageShareData',//自定义“分享给朋友”及“分享到QQ”按钮的分享内容（1.4.0） ] // 必填 }) 四、分享原有的 wx.onMenuShareTimeline、wx.onMenuShareAppMessage、wx.onMenuShareQQ、wx.onMenuShareQZone 接口，即将废弃。这里只介绍最新的 wx.updateAppMessageShareData、wx.updateTimelineShareData接口。 (1)自定义“分享给朋友”及“分享到QQ”按钮的分享内容（1.4.0）12345678910wx.ready(function(){ wx.updateAppMessageShareData({ title: option.title, // 分享标题 desc: option.desc, // 分享描述 link: option.link, // 分享链接 imgUrl: option.imgUrl, // 分享图标 success: function(res){ } }) }) (2)自定义“分享到朋友圈”及“分享到QQ空间”按钮的分享内容（1.4.0）123456789101112131415wx.ready(function(){ wx.updateTimelineShareData({ title: option.title, // 分享标题 link: option.link, // 分享链接 imgUrl: option.imgUrl, // 分享图标 desc: option.desc, // 分享描述 success: function(res){ // 用户成功分享后执行的回调函数 _this.$http.post(_this.$conf.env.updateShareCount, params).then(res =&gt;{ alert('成功') }).catch(err =&gt;{ }) } }); }) 五、遇到的问题 (1)微信分享途中如果取消分享后走的成功回调,无法识别是否分享成功这个问题确实是存在的，最后发现是微信官方做出的调整，本题无解，官方也有给出解释点击查看 (2)微信JS-SDK加载尚未完成，用户就点击分享，这时分享出去的页面没有标题和内容我有尝试在加载尚未完成时去禁止用户点击右上角分享按钮，但是用户体验很差，最后无疾而终","link":"/2019/08/29/weixinSherch/"},{"title":"基于HBuilder 开发 项目之微信支付","text":"@(HBuilder)[微信支付 |vue] 此项目是基于vue开发的一款移动端app,然后基于HBuilder进行打包成apk文件。 一 、用户申请微信开放平台申请移动应用首先进入微信开放平台,如果有账号的话直接登录，没有的话则根据步骤申请一个账号 登陆注册 ：首先进入微信开放平台,如果有账号的话直接登录，没有的话则根据步骤申请一个账号 创建应用 ：可以根据提示一步一步操作 注意：申请时需要用到app的包名和应用签名。 应用包名： 是在APP项目配置文件AndroidManifest.xml中声明的package值. 应用签名： 根据项目的应用包名和编译使用的keystore. 可由签名工具生成一个32位的md5串，我们将打包好的app（配有证书文件的前提）装在手机上，记住打包时需配置appID。打包时的具体流程详细配 置这里不再一一说明，如图所示另外也支持 Java JDK 来生成MD5 签名,下载完双击安装。注意！！！此处有坑 Java JDK高版本的工具只能生成SHA1和SHA256这俩个微信支付用不了，，，所以请看清楚版本(推荐下载的版本为jdk-6u43-windows)安装完成后以管理员身份进入Java下的bin目录，1cd C:\\Program Files (x86)\\Java\\jdk1.8.0_144\\bin输入命令1keytool -genkey -v -keystore debug.keystore -alias androiddebugkey -keyalg RSA -validity 10000然后查看生成的证书文件debug.keystore 1keytool -list -v -keystore debug.keystore 到这里签名就成功了 到此为止 到此为止申请流程走通可以等待微信支付审核通过。二、调用HBuilder的 plus模块支付一共分为两步首先是获取手机的支付通道，这里的支付通道是我们在HBuilder 打包时所配置的支付模块 123456789101112131415161718192021 // 获取支付通道 plus.payment.getChannels(function(channels) { //channel就是我们获取到的支付通道信息 var txt = '支付通道信息：'; for(var i in channels) { var channel = channels[i]; if(channel.id == 'qhpay' || channel.id == 'qihoo') { // 过滤掉不支持的支付通道 continue; } } } }, function(e) { ddsd.log('获取支付通道失败：' + e.message); }); } ``` 子商户调用“服务商提供的接口”返回支付数据，在APP发起支付参数示例如下&lt;img width=400 src=&quot;https://blueskyadd.github.io/myPicture/wxpay.png&quot; &gt; 拿到参数后调取plus 模块 的支付 plus.payment.request(pays, order, function(result) { //支付成功回调}, function(e) { //支付失败回调});` 参数说明 pays 参数为上面获取到的支付通道里的对象，，， 治理再调用微信支付时进行具体判断拿到参数对象order就是我们通过后台数据拿到的订单信息，切记转为字符串格式","link":"/2019/07/20/weixinPay/"},{"title":"前端网络","text":"网络相关的知识也是面试时经常会被问到的问题，面试官很有必要确认面试者是否只会使用$.ajax()方法，还是真正了解网络请求的原理。问题列表 get和post的区别 websocket是否了解 http 2.0对于http 1.x有哪些优点？ jq的ajax返回值是什么？ 说一说你知道的HTTP状态码 jsonp的原理 跨域请求资源有哪几种方式？他们的优缺点是什么？ XML和JSON的区别？ 1. get和post的区别get和post的区别这题看上很简单，你肯定能答出1个以上的区别，但是面试官往往期望你能答出更多更深层次的区别。这篇文章写的很详细了，大家可以研究一下——https://www.zhihu.com/question/28586791我在这里在概括一下：初级的答案因为GET方法请求的参数都是放在请求的url上的，所以它与POST有以下明显的区别： GET请求可以被添加到书签中，也可保存在浏览器历史记录中，POST不能 GET请求可以被浏览器缓存，POST不能 GET请求收到URL长度限制，所以数据长度也受限制，POST不会 GET请求只能传输ASCII字符，而POST不受此限制，还可以传输二进制数据 在语义上两个方法也有区别： GET 代表获取指定服务器上资源 POST 代表向指定的资源提交要被处理的数据 高级些的答案GET产生一个TCP数据包；POST产生两个TCP数据包。对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。但是需要多解释两句的是： 据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。 并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。 2.websocket是否了解？通常情况下，面试官问你是否对XX有了解，一般的回答都是要涵盖下面这些点： 是否知道它是什么？ 是否知道它的用途是什么？ 它和之前某项已有的技术相比，有哪些优缺点？ webSocket和http一样，同属于应用层协议。它最重要的用途是实现了客户端与服务端之间的全双工通信，当服务端数据变化时，可以第一时间通知到客户端。除此之外，它与http协议不同的地方还有： http只能由客户端发起，而webSocket是双向的。 webSocket传输的数据包相对于http而言很小，很适合移动端使用 没有同源限制，可以跨域共享资源 要想了解更多详细，还是去看阮一峰的教程吧——WebSocket 教程 - 阮一峰的网络日志 3.http 2.0对于http 1.x有哪些优点？优点（以下摘自HTTP/2.0 相比1.0有哪些重大改进？）： 多路复用：多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。由于http 1.x的时代中，浏览器向同一域名下发送的http请求数量是受限的，当超出数量限制时，请求会被阻塞，大大降低了用户体验。而HTTP/2 的多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。 二进制分帧：HTTP/2在应用层和传输层之间追加了一个二进制分帧层，最终使得多个数据流共用一个连接，更加高效的使用tcp连接。从而使得服务器的连接压力减轻，降低了内存的消耗，增大了网络的吞吐量。 首部压缩：HTTP/2引入了HPACK算法对头部进行压缩，大大减小了数据发送的字节数。 4.jQuery的ajax返回值是什么？很多公司，尤其是金融或数据分析的公司，他们的web app会与服务端进行大量的数据交互，所以他们的面试官通常会很看重面试者对于网络请求以及异步编程的理解程度。jQuery中的ajax大家很常用，以至于绝大部分人把他认为是“理所应当”，而忽略了他的底层逻辑和实现原理。$.ajax()方法返回的是一个延迟对象，即$.Deferred的实例。所以你可以像下面这样使用$.ajax()方法1234567891011//利用done()和fail()方法来处理ajax请求$.ajax({url:&quot;http://mydomain.com/memberInfo/get&quot;,async: false}).done( responseData =&gt; { console.log(responseData) }).fail( ()=&gt;{console.error('出错了！')})//$.get()也是同样的道理，除了上面延迟对象提供的方法外，还可以使用then()回调$.get(&quot;http://mydomain.com/memberInfo/get&quot;).then(responseData =&gt; {console.log(responseData);})如果你想让这两个请求都完成后再进行处理的话，可以用下面的操作：1234567891011var memberDef = $.get(&quot;http://mydomain.com/memberInfo/get&quot;);var orderDef = $.get(&quot;http://mydomain.com/orderInfo/get&quot;);$.when(memberDef, orderDef).then(( [memberInfo], [orderInfo])=&gt;{ //这里用到了解构赋值来取得http返回的数据 console.log('用户信息',memberInfo); console.log('订单信息',orderInfo);})想要了解更多关于延迟对象的内容，可以访问阮一峰的博客除了上面这一个问题，还可以追问一些下面的问题，这里就不展开解答了： 异步请求和同步请求的区别 ajax 请求有几种数据格式，如何设置数据格式 如何避免浏览器缓存get请求，以便达到每次get请求都能获取最新的数据 等等…… 5.说一说你知道的HTTP状态码以前遇到面试者说 HTTP状态码不应该是前端开发关心的事情。但我总觉得一个前端工程师对于http状态码的了解程度代表了他曾经踩过了多少雷，一个深入了解http状态码的工程师可以快速定位问题。 关于HTTP状态码应该有下面的基本认识： 1xx ：1开头的状态码表示临时的响应 2xx ：请求成功 3xx ：请求被重定向 4xx ：请求错误，表明客户端发送的请求有问题 5xx ：服务器错误，表明服务端在处理请求时发生了错误 知道上面的规律，再看到错误的时候就大概知道问题是后端的锅还是前端的锅了。再说几个常用的http状态码（如果有兴趣了解详细的话还是自己去找吧，网上很多（http://tools.jb51.net/table/http_status_code））： * 301 ： Moved Permanently 客户端请求的文档在其他地方，新的URL在location头中给出 * 304 ： Not Modified 客户端有缓存的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户端只想到指定日期后再更新文档）。服务器告诉客户，原来缓存的文档还可以继续使用。 * 400 ： Bad Request 请求出现语法错误 * 401 ： Unauthorized 访问被拒绝，客户端试图未经授权访问受密码保护的页面 * 403 ： Forbidden 资源不可用。服务器理解客户的请求，但拒绝处理它。通常由于服务器文件或目录的权限设置导致。 * 404 ： Not Found 无法找到指定位置的资源。 * 405 ： Method Not Allowed 请求方法（GET、POST、PUT等）对指定的资源不适用，用来访问本资源的HTTP方法不被允许。 * 500 ： Internal Server Error 服务器遇到了意料之外的情况，不能完成客户端的请求。 * 502 ： Bad Gateway 服务器作为网管或者代理时收到了无效的响应。 * 503 ： Service Unavailable 服务不可用，服务器由于维护或者负载过中未能应答。 * 504 ： Gateway Timeout 网关超时， 作为代理或网关的服务器不能及时的应答。 6.JSONP的原理JSONP是一种跨域共享资源的方法。很多人会好奇JSONP和JSON是什么关系，JSONP是JSON with padding的缩写，即填充式JSON或参数式JSON，是被包含在函数调用中的JSON，如下面的样子： callback({“name”: “Chong”});JSONP是通过动态元素来实现的，使用时可以为src属性指定一个跨域URL。由于浏览器加载脚本是不受同源规则限制的，所以即使是跨域的URL同样可以发送请求。因为JSONP是有效的JavaScript代码，所以再请求完成后，即在JSONP响应加载到页面中以后，就会立即执行。示例代码：function handleResponse(response){alert(“您的IP地址是 “ + response.ip);}var script = document.createElement(“script”);script.src = “http://freegeoip.net/json/?callback=handleResponse&quot;;document.body.insertBefore(script, document.body.firstChild);所以总结一下JSONP的实现方式： 1. 向当前页面中动态插入一个&lt;script&gt;元素，src属性设置为请求地址，并在地址中指定好回调函数 2. js代码中预先定义好jsonp的回调函数 3. 请求完成后，会立即调用预先指定好的jsonp回调，并将数据以json的格式传递到回调中。 JSONP之所以可以实现跨域，依赖的是下面的条件： 1. 浏览器请求脚本是不受同源规则限制的 2. &lt;script&gt;元素加载完成的脚本会立即执行 需要注意的是，JSONP是需要服务端配合的，因为JSONP返回的是一段代码。7.跨域请求资源有哪几种方式？他们的优缺点是什么？常见的跨域方式如下： * JSONP * 图像Ping * CORS * Web Sockets 一个一个说：JSONP优点：简单易用，浏览器支持好。缺点： 1. JSONP是从其他域中加载代码并执行，所以存在很多安全隐患，如果其他服务器在响应中夹带恶意代码的话，没有办法防范。 2. JSONP难以确定请求失败的情况。HTML5中给&lt;script&gt;元素增加了一个onerror事件，但是还是有浏览器不支持。 3. 只能发送GET请求 图像Ping这是指通过请求图片的方式来跨域发送请求。优点：简单，兼容性好，不需要服务器做针对性处理。缺点： 1. 只能单向通信，即客户端发送信号给服务端，无法接收到服务端的回复 2. 只能发送GET请求 3. 容易被浏览器缓存请求，导致请求发送不出去。 CORSCORS是Cross-Origin Resource Sharing的缩写，即跨域资源共享。CORS的基本思想就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。优点：功能强大缺点： 1. 需要服务端来配合实现（其实很简单~） 2. IE必须IE10以上。。。 WebSocket这个貌似就不用多说了，属于没用过也应该听过的一种技术。优点： 1. 双工通信，浏览器和服务器都可以发起请求 2. 通信效率高，一次链接可以复用，省去反复的握手环节 缺点： 1. 实现上较为复杂，包括客户端和服务端 2. 浏览器支持问题 还有很多其他的跨域方式，在这里就不说了8.XML和JSON的区别？XML是标准通用标记语言 (SGML) 的子集，而标签语言（如HTML）的好处就是易懂。优点：上手简单，非开发人员也可以快速上手（产品经理们很喜欢）。缺点： 1. XML多余的数据比较多，所以数据量大，传输时占用更多空间 2. 客户端和服务端解析XML都要比较繁琐，需要大量代码 JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式。重点在轻上，结构与JavaScript中的Object类似。优点： 1. 数据量小，利于网络传输 2. 方便解析，客户端和服务端都有基础的解析方法 缺点：结构稍微有点复杂，非开发人员不容易上手（初学者需要去官网学习研究一下）","link":"/2021/01/12/%E5%89%8D%E7%AB%AF%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"Element-ui","slug":"Element-ui","link":"/tags/Element-ui/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"node","slug":"node","link":"/tags/node/"},{"name":"Express","slug":"Express","link":"/tags/Express/"},{"name":"移动端","slug":"移动端","link":"/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"mongodb","slug":"mongodb","link":"/tags/mongodb/"},{"name":"express","slug":"express","link":"/tags/express/"},{"name":"HBuilder","slug":"HBuilder","link":"/tags/HBuilder/"},{"name":"ts","slug":"ts","link":"/tags/ts/"},{"name":"微信","slug":"微信","link":"/tags/%E5%BE%AE%E4%BF%A1/"},{"name":"H5","slug":"H5","link":"/tags/H5/"}],"categories":[{"name":"tags","slug":"tags","link":"/categories/tags/"},{"name":"categories","slug":"categories","link":"/categories/categories/"}]}