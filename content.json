{"pages":[{"title":"","text":"个人简介 分享很喜欢的老罗的一段话： “每一个生命来到世间都注定改变世界，别无选择。要么变得好一点，要么变得坏一点。你如果走进社会为了生存为了什么不要脸的理由，变成了一个恶心的成年人社会中的一员，那你就把这个世界变得恶心了一点点。如果你一生刚正不阿，如果你一生耿直，没有做任何恶心的事情，没做对别人有害的事情，一辈子拼了老命勉强把自己身边的几个人照顾好了，没有成名没有发财，没有成就伟大的事业，然后耿着脖子一生正直，到了七八十岁耿着脖子去世了。你这一生是不是没有改变世界？你还是改变世界了，你把这个世界变得美好了一点点。因为世界上又多了一个好人。“ 善恶终有报,天道好轮回。不信抬头看,苍天饶过谁。无论何时何地，我们都要保持一颗积极乐观、善良感恩的心。但行好事莫问前程，永远年轻，永远热内盈眶，永远保持正能量。💪💪💪💪💪💪冲鸭！！！！ -&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;个人信息：计算机科学与技术专业从事JAVA后端开发码畜一枚坚信代码改变世界 博客信息 网站采用的Icarus主题 追求尽可能的简洁，清晰，易用。 在Icarus主题之上进行了部分修改。 更新日志：–2020.09.20：icarus4.0适配–2020.01.18：icarus3.0适配–2019.11.17：增加深色主题开关–2019.10.30：去图，精简卡片–2019.10.22：改版部分显示，优化速度–2019.10.16：文章列表加上评论数显示–2019.10.13：改版评论–2019.09.25：图片、资源接入CDN免费jsDelivr、文章加入置顶–2019.09.19：开源博客代码–2019.09.19：修改布局，拉伸布局，更宽的展示–2019.09.18：修改友链ui为一行三个，并适配移动端，暗黑模式文章增加评论链接，增加留言链接–2019.09.14：增加精简next主题–2019.09.14：利用中秋节放假，重做了首页的热门推荐、加个widget最新评论框、归档页加入文章贡献概览面板 本站推荐索引 博客主题相关 github Issue 作为博客微型数据库的应用 github page网站cdn优化加速 博客源码分享 博客换肤的一种实现方式思路 博客中gitalk最新评论的获取 博客图片上传picgo工具github图传使用 安装、部分配置icarus主题中文版 技术知识点 Java并发知识点 法律法规 法律法规数据库111 中华人民共和国国旗法 中华人民共和国宪法 中华人民共和国消费者权益保护法 中华人民共和国刑事诉讼法 中华人民共和国婚姻法 中华人名共和国网络安全法 中华人民共和国劳动法 其他 网易云音乐歌单分享 计划2020计划 2019.12.31 2020-GOALS 跑两三场马拉松 2019计划 2018.12.31/21:59:00-&gt;更新于2019.12.31 2019-GOALS 购买的专业书籍至少看完一遍（并发、重构、设计模式…）-&gt; 95%额外： 追了很多剧总结： 有优点有缺点，没坚持下来的还是太多，追了太多剧。以后多学习，多思考！ 时间轴记录","link":"/about/index.html"},{"title":"","text":"heiheihei","link":"/about/index1.html"},{"title":"","text":"申请友链须知 原则上只和技术类博客交换，但不包括含有和色情、暴力、政治敏感的网站。 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 申请请提供：站点名称、站点链接、站点描述、logo或头像（不要设置防盗链）。 排名不分先后，刷新后重排，更新信息后请留言告知。 会定期清理很久很久不更新的、不符合要求的友链，不再另行通知。 本站不存储友链图片，如果友链图片换了无法更新。图片裂了的会替换成默认图，需要更换的请留言告知。 本站友链信息如下，申请友链前请先添加本站信息： 网站图标：https://removeif.github.io/images/avatar.jpg 网站名称：辣椒の酱 网站地址：https://removeif.github.io 网站简介：后端开发，技术分享 加载中，稍等几秒…","link":"/friend/index.html"},{"title":"","text":"🎈🎈我的摄影🎈🎈 彭小苒","link":"/album/index.html"},{"title":"","text":"来而不往非礼也畅所欲言，有留必应","link":"/message/index.html"},{"title":"gallery","text":"","link":"/gallery/index.html"},{"title":"categories","text":"23333333333333333333333333","link":"/categories/index.html"},{"title":"音乐歌单收藏","text":"温馨提示：选择喜欢的音乐双击播放，由于版权原因部分不能播放。如果喜欢歌单收藏一下，去网易云都能播放哟！","link":"/music/index.html"},{"title":"","text":"&nbsp;&nbsp;听听音乐 音乐播放器由mePlayer提供，布局参照网友博客所作，感谢作者的辛勤付出。更多音乐分享请查看歌单。 &nbsp;&nbsp;看看视频 -&gt;点击以下条目开始播放视频,向下滑动查看更多&lt;-","link":"/media/index.html"},{"title":"","text":"碎碎念 tips：github登录后按时间正序查看、可点赞加❤️、本插件地址..「+99次查看」 碎碎念加载中，请稍等… $.getScript(\"https://cdn.bootcss.com/gitalk/1.5.0/gitalk.min.js\", function () { var gitalk = new Gitalk({ clientID: 'ff2be2cdbc9e2b468c06',// GitHub Application Client ID clientSecret: 'ed81438221a18738b2c235cfc98658347e08b849', // GitHub Application Client Secret id: location.pathname, // 用于标记评论是哪个页面的，确保唯一，并且长度小于50 repo: 'gitalk-comment', // 存放评论的仓库 owner: 'blueskyadd',// 仓库的创建者， admin: \"blueskyadd\", createIssueManually: true, distractionFreeMode: false }); gitalk.render('comment-container'); });","link":"/self-talking/index.html"},{"title":"node","text":"hexo new page categories","link":"/node/index.html"},{"title":"node","text":"","link":"/node/index-1.html"},{"title":"promise的简单理解","text":"promise的基本语法 新建一个promise很简单，只需要new一个promise对象即可。所以promise本质上就是一个函数，它接受一个函数作为参数，并且会返回promise对象，这就给链式调用提供了基础。1234new Promise(function(resolve, reject) { //待处理的异步逻辑 //处理结束后，调用resolve或reject方法}) promise的几种状态 其实Promise函数的使命，就是构建出它的实例，并且负责帮我们管理这些实例。而这些实例有以下三种状态： 1. pending: 初始状态，位履行或拒绝 2. fulfilled: 意味着操作成功完成 3. rejected: 意味着操作失败 pending 状态的 Promise对象可能以fulfilled状态返回了一个值，也可能被某种理由（异常信息）拒绝（reject）了。当其中任一种情况出现时，Promise 对象的then方法绑定的处理方法（handlers）就会被调用，then方法分别指定了resolve方法和reject方法的回调函数 几种状态的深入理解* 一个promise可能有三种状态：等待（pending）、已完成（fulfilled）、已拒绝（rejected） * 一个promise的状态只可能从“等待”转到“完成”态或者“拒绝”态，不能逆向转换，同时“完成”态和“拒绝”态不能相互转换 * promise必须实现then方法（可以说，then就是promise的核心），而且then必须返回一个promise，同一个promise的then可以调用多次，并且回调的执行顺序跟它们被定义时的顺序一致 * then方法接受两个参数，第一个参数是成功时的回调，在promise由“等待”态转换到“完成”态时调用，另一个是失败时的回调，在promise由“等待”态转换到“拒绝”态时调用。同时，then可以接受另一个promise传入，也接受一个“类then”的对象或方法，即thenable对象。 promise缺点* 一旦新建它就会立即执行，无法中途取消 * 如果不设置回调函数，Promise内部抛出的错误，不会反应到外部 * 当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）","link":"/promise/index.html"},{"title":"hi","text":"","link":"/travel/index1.html"},{"title":"","text":"生命好在无意义，带容得下各自赋予意义 ———— 木心 时间如此锋利，我开始真的相信记忆的脆弱性。那么多以为终生难忘的画面，就这样渐渐的模糊起来。————七堇年《灯下尘》 夜深人静的时候，从耳机中听到来自宇宙没有生命的噪声，这声音隐隐约约的，好比那些星星还永恒。有时又觉得那声音像大兴安岭的冬天里没完没了的海风，让我感到很冷，那种孤独真是没法形容。 —————— 叶文洁《三体》 难熬的一天呢","link":"/travel/index.html"},{"title":"相遇黄山","text":"黄山北站集合 2019年 07-20 这次黄山之行已经过去很久了，今天闲来无事决定记录一下 阿静: 天娇啊我准备去婺源看看 我: 哇，等我两天呗，和你一块去没错这次路程就这样开始了，出发先前还想着报团去玩，结果呢，，，没错就是太贵了，果断放弃。自己来玩吧。各种找攻略，找了找之后决定先到黄山集合，然后转上饶，最后去婺源。 计划很完美现实很骨感，到了黄山后已经晚上了（表示本大仙下班后去的黄山）在黄山老街的一家旅社住下了，想着明天早起去逛一逛老街然后买好多好多好吃的。哈哈结果一觉睡到早上八点多，真的很意外，外面出奇的安静，诡诡异异的感觉，和想象中完全不一样好吧。 心想着罢了罢了,既来之则安之.洗漱过之后就准备在老街这边逛逛，结果呢，感觉出乎意料的好。 经过昨晚大雨的洗刷之后，空气格外的清晰。稀稀疏疏的几个旅人，悠哉的走在这江南小镇上，感觉整个时间都慢了下来，在城市的喧嚣之外也有很多人过着这样的生活。不禁羡慕起来，但是吧想一想生活有动有静才是生活。拍了几张清晨老街的照片 接着准备出发爬黄山，但是呢各种临时起意后决定先去宏村。旅行嘛说走就走，怎么开心怎么来，有朋友陪着这就足够了","link":"/tags/index.html"}],"posts":[{"title":"TS入门（一）","text":"TypeScript 是一种由微软开发的自由和开源的编程语言，它是JavaScript的一个超集，扩展了JavaScript的语法。 参考资料：阮一峰大神 （https://ts.xcatliu.com/） 1、#JavaScript 与 TypeScript 的区别： TypeScript 是 JavaScript 的超集，扩展了 JavaScript 的语法，因此现有的 JavaScript 代码可与 TypeScript 一起工作无需任何修改，TypeScript 通过类型注解提供编译时的静态类型检查。TypeScript 可处理已有的 JavaScript 代码，并只对其中的 TypeScript 代码进行编译。 2、TypeScript的优缺点：优点： 增加了代码的可读性和可维护性 可以在编译阶段就发现大部分错误，这总比在运行时候出错好 增强了编辑器和 IDE 的功能，包括代码补全、接口提示、跳转到定义、重构等 包容 即使不显式的定义类型，也能够自动做出类型推论 可以定义从简单到复杂的几乎一切类型 即使 TypeScript 编译报错，也可以生成 JavaScript 文件 兼容第三方库，即使第三方库不是用 TypeScript 写的，也可以编写单独的类型文件供 TypeScript 读取 缺点 工作量大","link":"/2019/05/31/FirstNight/"},{"title":"bat文件执行 npm run dev","text":"发现每次运行项目都需要一步步进入到项目文件，然后点开cmd 执行npm run dev，确实很麻烦很多余，最近发现了bat脚本可以直接运行 npm run dev省了很多时间,下面是bat文件的代码，可以直接放在桌面上，双击既可运行项目；123456e: //项目放在E盘中cd work //E盘下面的文件夹cd woling_coach //我的项目文件夹cd wolingJL //我的项目名字set startDir=%cd% npm run dev //运行npm run dev使用时将文件目录换成自己的即可","link":"/2019/05/31/bat/"},{"title":"怎么愉快的通过线上地址访问我们的照片","text":"创建git仓库首先打开gitHub官网地址然后创建一个GIt仓库来存放我们的图片然后填写相应的项目信息 上传图片信息后打开setting 其次在创建的图片仓库的设置中找到GitHub Pages，将Source中的none设置为master branch， 随即你便可以将在你的GitHub Pages存放和查看你仓库中的文件（github上项目运行演示也是如此） 接着在地址栏中输入上图中github pages中的项目地址，在后面加上你想要的图片的图片名，便可以在线展示","link":"/2019/07/25/githubUPdataImg/"},{"title":"hexo Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/05/31/hello-world/"},{"title":"IOSAPP真机测试及上架App Store流程","text":"第一步：申请iOS苹果开发者账号首先先看一下ios不同账号的区别 这里以公司账号为例 此账号是在个人普通账号上申请的， 1、申请个人apple id 如果已经申请过apple id，跳过注册，直接看第2步申请！ 点击此处即可申请个人账号。 按照提示依次填写信息 注册跳转到这个下面这个页面说明苹果账号已经注册成功了。 2、苹果开发者中心提交申请开发者。(1)登录进去苹果开发者中心，由于未付费购买开发者账号，会看到如下内容，点击加入开发者。 (2)进入这个页面，点击注册，再点击开始你的注册。现在申请苹果开发者账号要求开启双重认证才能提交申请。如果未开启点击此教程接下来按照提示依次填写相应信息(3)付款付款成功后，会有个付款邮件反馈过来，确认收到付款，但账号不是马上可以用，快的话付款后十几分钟后就能用，一般要审核一两天，有可能发邮件给你让你上传身份证留意好邮件就行了。 如果收到这种邮件说明审核通过了。 审核成功登录上去]ios开发者中心会出现以下界面 第二步申请所需证书由于发现在IOS开发者中心申请证书需要用到ios电脑，由于条件不满足，所偶另辟新径，找到了一款强大的第三方工具Appuploader。 1、安装iOS上架辅助软件Appuploader无需安装，解压直接使用2、申请 iOS证书文件p12 （ 发布版本同理，只需将类型修改为发布版即可）(1)登录 (2)下载证书 点击右下角+ADD选择 类型：选择开发证书（开发证书打包的才能安装到手机） 输入证书名称：不要中文、随意设置 邮箱：（随意） 密码：证书的密码，不是开发者账号密码，如123这样不用很复杂，记好、打包时要用、很重要。 应用id：这里不用选！ 点击ok创建。 然后点击P12下载即可(3)申请iOS开发证书描述文件mobileprovision 在申请ios描述文件之前，先添加好两样基础信息，应用id及苹果手机设备号udid (4)点击+ ADD，对应选择发布版profile 应用id:选择对应的id（又称套装id，appid，BundleID，包名） 证书：选中全部就行 Devices：设备这里不像选开发版profile时会出现，发布版不用选。 输入名称：不要中文，随意，123之类的就行，注意不要跟之前申请过的名称一样），点击ok创建。 (5)选择刚创建的发布版描述文件（iOS Distribution这个类型的就是发布描述文件，找刚创建的输入的名称），点击Download下载，保存到电脑 (6)打开HBuilder工具，选择开发好的项目，点击发行，选择发行为原生安装包。(7)选择iOS打包，支持的设备类型（可以选择支持iPhone和支持ipad），选择使用苹果证书 AppID：跟申请证书描述.mobileprovision时选择的要一致（又称套装id，appid，BundleID，应用id，包名） profile文件：选择上传配置文件.mobileprovision 私钥证书：上传.p12文件 私钥密码：输入创建p12设置的密码。 (8)安装IPA到手机进行测试(推荐使用爱思助手安装)特别注意：ios不像安卓、不能直接把ipa文件发送到手机安装，需要通过手机助手安装，或者上传分发平台扫二维码安装，如蒲公英，fir这种分发平台。连接上手机、点击应用游戏，点击导入安装，选择刚打包的ipa包，或者直接选择ipa包右键通过爱思助手安装。(9)申请iOS发布证书同开发证书过程相同，勾选发布证书即可(10)登录iTunes Connect，点击我的APP进入创建一个APP进入点击左上角+号选择新建APP，选择平台iOS， 应用名称：APP的名称 语言：APP的语言，中文还是英文。 套装ID：（应用id、appid、包名，跟申请证书使用的要保持一致） sku：不能写中文，自己用拼音随便编一个，好识别就行，如app叫淘宝，就输入taobao。 用户访问权限：一般选完全访问权限 (11)Windows环境下上传IPA到App Store Windows环境下上传IPA到App Store 先创建一个APP专用密码，配置到Appuploader软件！ 苹果一种机制，上传ipa需要一个特定的APP专用密码，app-specific password 打开网站https://appleid.apple.com/zh_CN登录苹果开发者账号 登录进去找到安全项目，点击生成专用密码。 密码标签随便输入，123，app等之类的都行。 点击创建生成，（注意密码标签不是专用密码，是由苹果系统生成的一串密码）专用密码就是下面这个样子的密码，把这个密码复制，打开Appuploader 点击右上角，选择设置，把上传专用密码复制上去，同时勾选上保存密码，点击Save保存，然后再回去提交ipa上传就可以正常上传了。 (12)上传输入专用密码点击OK保存后，点击单个ipa按钮提交 选择刚打包测试没问题的ipa包 上传成功 (13)上传成功后到后台查看上传的版本 packages were uploaded successfully 进度条蓝色，ipa上传成功后，登录iTunes Connect https://itunesconnect.apple.com/login后台查看上传的ipa (14)设置APP各项信息提交审核 (15)选择左边第三项准备提交进入、这个页面需要设置几项信息、一步一步来。 先设置app截图！因为现在苹果规则的改变，iPhoneX刘海屏6.5的截图 (16)提交审核回到我的APP查看会提示正在等待审核，审核有时很快一两天，或要几天时间，常登陆看看审核情况，或看邮件提示。","link":"/2019/07/27/iosUpload/"},{"title":"node入门(一) -node的简单理解","text":"刚开始学习前端的时候接触过一点node,不过技术这种东西，一段时间不用就忘光了。现在想着重新捡起来，慢慢的从头开始看一下。打算借助node 的 Express框架来学习, 一、什么是node百度搜一下node百度百科上很清晰的写着：Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型。node.js就是把浏览器的解释器封装起来作为服务器运行平台，用类似javascript的结构语法进行编程，在node.js上运行。简而言之，Node 为我们提供了一个无需依赖浏览器、能够直接与操作系统进行交互的 JavaScript 代码运行环境！ 二、为什么要学习node其实前端要想走向全栈，必须是要接触后端语言的。那么对于前端来说，node时最合适的，虽然用node来做大型项目也是不现实的的，但是自己做一个小网站是绝对够用的。 三、node可以用来做什么可以帮助我们快速搭建站点，而且轻量级的特点。看到过一个技术文章降解的非常详细nodejs可以用来做什么 四、node的安装 (1):下载官方的下载地址点击跳转;官网有很多版本，不过并不推荐下载最新版本，可以根据需要自行下载； (2):安装步骤一:下载完成后双击安装包,显示如下页面,点击next.步骤二:勾选“I accept the terms in the License Agreement”同意许可协议，并单击Next下一步，出现如下界面：步骤三:Node.js默认安装路径为“C:\\Program Files\\nodejs\\”，你可以修改，在这里我改到了D盘，单击Next.不过最好默认路径免去一些麻烦步骤四：这里我直接默认Next下一步，准备就绪，准备安装：步骤五：确认无误后，点击Install，开始安装：步骤六：半分钟后，安装完成，点击Finish即可步骤七：最后运行node -v可查看node版本","link":"/2019/09/20/nativeEquipment/"},{"title":"Element-ui Cascader 级联选择器 同时返回 value 和 label","text":"给 cascader 组件赋值一个别名 ref=”cityData” 1234567&lt;el-cascader ref=&quot;cityData&quot; placeholder=&quot;请输入所属区域&quot; :options=&quot;options&quot; v-model=&quot;area&quot; &gt; &lt;/el-cascader&gt; 在 2.9.2 后官方新增了 getCheckedNodes() 方法 该方法返回选中节点的 array，如果是单选的话，使用1this.$refs.cityData.getCheckedNodes()[0].pathLabels ps: 城市JS 点击下载","link":"/2020/02/16/label/"},{"title":"react基础（一）","text":"写在前面的话 react 作为目前前端的主流框架，各大公司也都在使用。react是一套基于视图层的框架，核心库只关注于视图层，跟vue一致（vue参照了react）。react专注于组件化开发，使用jsx语法（javascript xml – 类xml语法—-要求所有写的视图代码必须包含在同一个父级标签中—-vue中的template），内涵虚拟DOM（ 所有内容并不是一开始就写到了index.html中，使用jsx语法构建，最后渲染到了index.html页面中），使用diff算法（ 状态的改变，会引起视图的二次渲染，比较状态树变化的算法），会比vue更加适合团队开发模式，以至于react成了一项必备技能。我个人其实是一直在使用vue，不过为了迎合市场也开始了react的学习之路，接下来我会将react、redux、react-router一步一步来进行整理。 01-构建项目 01-1 create-react-app 快速构建项目creat-react-app优点 无需配置：官方的配置堪称完美，几乎不用你再配置任何东西，就可以上手开发项目。 高集成性：集成了对React，JSX，ES6和Flow的支持。 自带服务：集成了开发服务器，你可以实现开发预览一体化。 热更新：保存自动更新，让你的开发更简单。 全兼容性：自动处理CSS的兼容问题，无需添加-webkit前缀。 自动发布：集成好了发布成品功能，编译后直接发布，并且包含了sourcemaps功能。 creat-react-app的安装 windows系统下： 1npm install -g create-react-app 创建react项目安装完成后，就可以使用create-react-app来生成react项目的项目目录– projectName：项目名称 1create-react-app projectName 启动项目然后进入到项目内 通过npm来安装项目依赖 1npm start 01-2 generator-react-webpack 快速构建项目我也是第一次使用它，各种百度后发现它其实是基于webpack构建的，只不过是进一步完善了webpack，它可以支持ES6，并且集成了Babel-Loader等。简单来说使用它之后省去了我们自己手动配置webpack,对于我这种不熟悉webpack配置的小白来说极其方便。 generator-react-webpack优点 基于webpack构建，可以很容易的配置自己需要的webpack。 支持ES6，集成了Babel-Loader。 支持不同风格的CSS（sass，less，stylus）。 支持PostCSS转换样式。 集成了esLint功能。 可以轻松配置单元测试，比如Karma和Mocha 包含热加载 generator-react-webpack的安装在全局安装yeoman 和 generator-react-webpack12npm install -g yonpm install -g generator-react-webpack 初始化项目目录，使用generator-react-webpack生成项目目录123mkdir react_democd react_deomyo react-webpack 项目运行1npm start react项目目录介绍","link":"/2020/04/13/react%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"如何将Android App 发布到 腾讯应用宝","text":"第一步 ：首先打开腾讯开放平台 第二步、注册信息1、打开页面后登录，如果是公司团队开发最好重新申请qq账号，避免不必要的麻烦。登录之后在首页选择应用接入，开始进行开发者申请。2、点击后选择注册类型 个人或者企业，以企业为例： 3、进入企业注册页面后首先填写公司相应的资料信息，注意上传图片的大小格式。 然后依次进行邮箱验证 最后完成注册，至此我们已经完成开发账号的创建； 第三步、创建应用1、若未在QQ互联创建过应用，直接在此页面选择“创建应用”即可，请勿选择关联QQ互联。 2、若已在QQ互联创建过应用，可在创建应用时选择关联QQ互联，输入在QQ互联创建的网页应用APPID、APPKEY即可完成关联。 3、选择应用类型，这里选择软件自己的APP类型即可 4、然后进一步完善信息 5、上传加固安装包（1）安装包等级处理 上传到应用宝、华为应用平台时出现错误：“装包的API等级(targetSdkVersion)必须等于或高于26，请重新打包上传”,加入以下字段即可。 12&quot;minSdkVersion&quot;: 14,&quot;targetSdkVersion&quot;: 26, （2）安装包加固 之后在上传安装包时会提示我们说“未加固应用，可能无法审核通过，应用宝将不予曝光和搜索”。 （3）安装乐谷加固为了保护我们的劳动成果和知识产权，必须对APK对加固工作，否则极易被人破解、篡改，二次打包。市面上当前做加固的有很多家，实际使用了腾讯乐固和360加固（看了网易也有易盾，但是因为只能试用，所以没试）。本文介绍腾讯乐固的使用方法。首先点击下载 乐固加固,使用微信登陆即可。 直接点击下一步即可安装,安装过完成的界面 完成后登陆时我们需要创建一个密钥，点击这里,来创建秘钥以供登录使用。 （4）加固应用登陆之后来到首页，首先创建应用，选择打包好的apk文件,注意要使用自有证书。详情请见另一片文章 上传成功后，会显示一下界面 然后点击下一步 提交完成后，会自动下载到同名文件下，我们只需将生成好的加固文件（包含签名的一个）上传到腾讯应用宝即可 6、最后提交审核 注： 可通过ps直接修改：点击图像 –》图像大小然后改为相应像素；","link":"/2019/07/25/relaseAndroid/"},{"title":"node入门(二) -浅析Express开发框架","text":"如果想用node快速的搭建一个WEB站点，那么可以选择Express 框架，Express是基于 Node.js 平台，快速、开放、极简的 Web 开发框架. 一、初始化安装Express (1)全局安装Express1npm install express-generator -g 安装的时候有的可能会报错，原因是没有node的操作权限。解决此问题要以管理员身份运行cmd，执行下列代码。1set-ExecutionPolicy RemoteSigned然后选择’全是’ (2)然后运行-h就可以列出所有可用的命令行参数：1express -h (3)然后运行下面代码创建名为‘myapp’的项目1express --view=pug myapp (4)安装项目依赖并运行项目123cd myappnpm installnpm start 至此输入http://localhost:3000/#/ 项目就运行起来了","link":"/2019/10/25/nodeTwo/"},{"title":"app沉浸式导航栏相关处理","text":"在移动端，很多的app都需要设置沉浸式导航栏，但是手机适配又成了一个很大的问题，所以通过获取手机状态栏高度，再增加页面padding的方法应该是最好的，可以适应各种妖孽手机，首先需要在HBuilder的配置文件中设置沉浸式导航，找到manifest.json文件下的plus对象，然后贴如下面代码：123&quot;statusbar&quot;: { &quot;immersed&quot;: true/*沉浸式状态栏*/},下面代码片段是获取移动端状态栏高度的。注：此代码写在main.js中12345678910111213141516171819202122232425262728//由于plus模块需要加载，所以这里我使用了延时处理setTimeout(()=&gt;{ if(window.plus){ //首先判断当前设备是否支持沉浸式导航栏，如果不支持不做处理 var isImmersedStatusbar = plus.navigator.isImmersedStatusbar(); if (isImmersedStatusbar) { //获取当前设备状态栏高度 var StatusbarHeight = plus.navigator.getStatusbarHeight(); //当前机型如果是iPhoneX，则在原基础上增加15像素。 //获取到高度后在vue的原型上增加StatusbarHeight属性，方便后续使用 if (plus.device.model.toString() == 'iPhoneX') { Vue.prototype.$StatusbarHeight = StatusbarHeight + 15; } else { Vue.prototype.$StatusbarHeight = StatusbarHeight; } } //此处设置了状态栏文字的颜色---dark为黑色/light为白色 plus.navigator.setStatusBarStyle('dark'); //在处理结束后页面再出来，否则会出现抖动现象 new Vue({ el: '#app', router, store, components: { App }, template: '&lt;App/&gt;' }) }},100)在获取到高度后，在app.vue页面来给#app增加padding值，这里一劳永逸型，哈哈。1:style=&quot;{paddingTop:`${$StatusbarHeight}px`}&quot;如果有个别状态栏背景色不一样的，可以给#app动态添加class来解决，","link":"/2019/08/28/tablebar/"},{"title":"node入门(三) -如何使用node上传图像到服务器","text":"一、首先配置MongoDB，在node中连接(1):下载安装MongoDb 官方下载链接： 下载地址 下载 Windows 64-bit x64 msi 格式的，完事直接傻瓜式安装（切记记住安装位置）。 为了方便使用，可以下载一个mongodb的可视化工具，Robo 3T.(下方有下载地址) 链接：https://pan.baidu.com/s/16Jr6ezRuM0y9KM5CppUEwg 提取码：bqnh 下载完成后，先打开mongodb的安装目录,打开bin文件夹然后双击mongod.exe， 运行成功后打开浏览器，输入127.0.0.1:27017如果看到下图提示则表示","link":"/2019/12/16/threeNode/"},{"title":"promise的简单理解","text":"promise的基本语法 新建一个promise很简单，只需要new一个promise对象即可。所以promise本质上就是一个函数，它接受一个函数作为参数，并且会返回promise对象，这就给链式调用提供了基础。 1234new Promise(function(resolve, reject) { //待处理的异步逻辑 //处理结束后，调用resolve或reject方法}) promise的几种状态 其实Promise函数的使命，就是构建出它的实例，并且负责帮我们管理这些实例。而这些实例有以下三种状态： 1. pending: 初始状态，位履行或拒绝 2. fulfilled: 意味着操作成功完成 3. rejected: 意味着操作失败 pending 状态的 Promise对象可能以fulfilled状态返回了一个值，也可能被某种理由（异常信息）拒绝（reject）了。当其中任一种情况出现时，Promise 对象的then方法绑定的处理方法（handlers）就会被调用，then方法分别指定了resolve方法和reject方法的回调函数 几种状态的深入理解 一个promise可能有三种状态：等待（pending）、已完成（fulfilled）、已拒绝（rejected） 一个promise的状态只可能从“等待”转到“完成”态或者“拒绝”态，不能逆向转换，同时“完成”态和“拒绝”态不能相互转换 promise必须实现then方法（可以说，then就是promise的核心），而且then必须返回一个promise，同一个promise的then可以调用多次，并且回调的执行顺序跟它们被定义时的顺序一致 then方法接受两个参数，第一个参数是成功时的回调，在promise由“等待”态转换到“完成”态时调用，另一个是失败时的回调，在promise由“等待”态转换到“拒绝”态时调用。同时，then可以接受另一个promise传入，也接受一个“类then”的对象或方法，即thenable对象。 promise缺点 一旦新建它就会立即执行，无法中途取消 如果不设置回调函数，Promise内部抛出的错误，不会反应到外部 当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）","link":"/2020/04/21/promise/"},{"title":"TS入门（二）","text":"数据类型(1)布尔值（boolean ）1let isDone: boolean = false; 在 TypeScript 中，boolean 是 JavaScript 中的基本类型，而 Boolean 是 JavaScript 中的构造函数数值（number ） (2)模板字符串:1let sentence: string = `Hello, my name is ${myName}. I'll be ${myAge + 1} years old next month.` 编译结果: 1var sentence = &quot;Hello, my name is &quot; + myName + &quot;.\\nI'll be &quot; + (myAge + 1) + &quot; years old next month.&quot;; 其中 ` 用来定义 ES6 中的模板字符串，${expr} 用来在模板字符串中嵌入表达式。 (3)空值(Void )： JavaScript 没有空值（Void）的概念，在 TypeScript 中，可以用 void 表示没有任何返回值的函数： 声明一个 void 类型的变量没有什么用，因为你只能将它赋值为 undefined 和 null： 1let unusable: void = undefined; Null 和 Undefined： undefined 类型的变量只能被赋值为 undefined，null 类型的变量只能被赋值为 null。 (4)任意值(Any) 来表示允许赋值为任意类型 任意类型的理解：（如果是一个普通类型，在赋值过程中改变类型是不被允许的，但如果是 any 类型，则允许被赋值为任意类型。声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值。—-变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型） 类型推论（如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查：）(5)联合类型 表示取值可以为多种类型中的一种。123let myFavoriteNumber: string | number;myFavoriteNumber = 'seven';myFavoriteNumber = 7 联合类型使用 | 分隔每个类型。(6)对象的类型——接口 接口 在面向对象语言中，接口（Interfaces）是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implements）。 (7)函数的类型声明语句123function sum(x: number, y: number): number { return x + y;} 使用 declare 关键字来定义它的类型，帮助 TypeScript 判断我们传入的参数类型对不对：1declare var jQuery: (selector: string) =&gt; any; （declare 定义的类型只会用于编译时的检查，编译结果中会被删除。） 上例的编译结果是：1jQuery('#foo');","link":"/2019/05/31/typescriptTwo/"},{"title":"TS - interfaces  初探","text":"interfaces英文翻译为接口，百度百科上解释为interface是面向对象编程语言中接口操作的关键字，功能是把所需成员组合起来，用来装封一定功能的集合。那么它在ts这个语言中究竟扮演怎样的角色，有什么用途。 interfaces 是什么理解起来 interfaces就是约定了一个编程的规范而已，它规定了要实现的一系列方法和属性。也就是说interface其实是一种描述对象或函数的东西，它是一种约束形式，比如一个对象需要有什么样的属性，函数需要什么参数或返回什么样的值，数组应该是什么样子的，一个类和继承类需要符合什么样的描述等等。 了解了interface是什么，那么在不同的情况下我们怎么去使用interfaces呢？ interfaces 怎么用对象 Interface 定义对象需要的属性 设置可选属性 设置只读属性 可以通过 as 或 [propName: string]: any 来定义对象属性的数据类型 例子：12345678910111213interface people { Name : String, age:number, height?: number,//设置可选属性，可有可恶✅ readonly gender:String, //设置只读属性✅}const zhangSan:people = { Name: &quot;张三&quot;, age:1, gender:'男'}zhangSan.gender = &quot;女&quot;//报错，只读属性不可修改 ❌ 函数 Interface 定义函数接口 定义函数入参的类型 使用函数表达式 调用函数，写入出参 例子：1234567891011interface Fun {( x:string,//定义函数接收的第一个必选参数为string类型✅ y:number,//定义函数接收的第二个必选参数为number类型✅ z?:boolean,//定义函数接收的第三个可选参数为boolean类型✅)}const add: Fun = function (x:string, y:number, z = false){ console.log(x, y, z)}add('张三',12) 可索引的类型我们也可以描述那些能够“通过索引得到”的类型，例如arr[0]。可索引类型具有一个索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。 定义一个可索引类型 设置索引类型 定义数组调用该规范 例子：12345678910interface StringArray { readonly [index: number]:string, //❗ 需要注意的是 index 只能为 number 类型或 string 类型 length: number //指定属性👀}let arr1: StringArray = [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;] arr1[1] = &quot;4&quot; // ❌ 由于索引设置为只读属性，arr1[1]不能赋值let arr: StringSet = [23,12,3,21] // ❌ 数组应为 string 类型 类 Interface 实现（implements）是面向对象中的一个重要概念。一个类只能继承自另一个类，不同类之间可以有一些共有的特性，就可以把特性提取成接口（interfaces），用 implements 关键字来实现。 Interface 也可以用来定义一个类的规范。需要注意的是类 Interface 只会检查实例的属性，静态属性是需要额外定义一个 Interface；例如：12345678910111213141516171819202122232425262728// ? PersonConstructor 是用来检查静态部分的interface PersonConstructor { new (name: string, age: number) // ✔️ 这个是用来检查 constructor 的 typename: string // ✔️ 这个是用来检查静态属性 typename 的 logname(): void // ✔️ 这个用来检查静态方法 logname 的}// ? PersonInterface 则是用来检查实例部分的interface PersonInterface { // new (name: string, age: number) // ❌ 静态方法的检查也不能写在这里 这样写是错误的 log(): void // : 这里定义了实例方法 log}// class Person implements PersonInterface, PersonInterface { ❌ 这样写是错误的const Person: PersonConstructor = class Person implements PersonInterface { name: string age: number static typename = 'Person type' // 这里定义了一个名为 typename 的静态属性 static logname() { // 这里定义了一个名为 logname 的静态方法 console.log(this.typename) } constructor(name: string, age: number) { // constructor 也是静态方法 this.name = name this.age = age } log() { // log 是实例方法 console.log(this.name, this.age) }} 接口间的继承 接口可以通过其他接口来扩展自己。 Typescript 允许接口继承多个接口。 继承使用关键字 extends。 1. 单接口继承extends 关键字后加继承的接口123456789101112interface Person { name: string, age: number}interface Students extends Person { gender: string}const foo: Students = { name: 'why', age: 18, gender: 'female'} 2. 多接口继承多接口之间逗号分隔1234567891011121314interface Sing { sing(): void}interface Jump { jump(): void}interface Rap extends Sing, Jump { rap(): void}const foo: Rap = { sing(){}, jump(){}, rap(){}} 3. 接口继承类常见的面向对象语言中，接口是不能继承类的，但是在 TypeScript 中却是可行的用extends关键字继承类123456789101112131415161718class Person { name: string age: number constructor(name: string, age: number) { this.name = name this.age = age } run(): void { }}interface User extends Person { gender: string}const foo: User = { name: 'foo', age: 18, gender: 'male', run():void { }} 友情链接：es6中class类静态方法，静态属性理解，实例属性，实例方法理解extends和implements区别 参考资料https://www.jianshu.com/p/099c5683ffb5https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Interfaces.htmlhttps://cloud.tencent.com/developer/article/1411764","link":"/2020/07/15/ts-interfaces/"},{"title":"HBuilder 开发，Android自有证书生成及打包","text":"1、打开config/index.js 文件修改build 下的assetsPublicPath路径1assetsPublicPath: '/', 改为 assetsPublicPath: './',2、打开build/utils.js文件 搜索‘publicPath’ 修改为1publicPath: '../../' 第二步、生成安装包所需证书 安装包生成 可以使用DCloud 的HBuilder 或者APICloude 。双方各有其优点，这里以HBuilder 为例。 1、首先是Android的证书文件生成，首先勾选使用自有证书： 2、下一步生成证书文件 生成Android 证书的前提是安装Java的JDK到本地，JDK 安装包被集成在 Java SE 中，因此下载 Java SE 即可，具体步骤如下 (1).打开Java jdk此页面下载安装包 (2).点击Accept License Agreement，下载适合自己电脑版本的JDK.由于我的电脑是windows10 64位专业版，所以我选择的是最后一个。(3).下载完成之后安装（下一步即可）注意一下安装路径，下面要用 (4).环境配置注：这里描述可能不够详细我只做记录使用,可以点击此文章查看详细教程(I)右键电脑属性，打开高级系统设置。(II)点击高级，再点击环境变量。(III)新建系统变量JAVA_HOME，变量值输入你的安装路径(Ⅳ)找到自己系统变量里的Path,双击，找到编辑文本点击，在变量值的最后添加 %USERPROFILE%\\AppData\\Local\\Microsoft\\WindowsApps(IV)新建系统变量CLASSPATH，变量值填 .;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar（注意这个变量值前面还有一个点，代表从当前路径）(Ⅵ).测试是否安装成功，cmd打开dos系统。输入java,如果显示下面内容就表示安装成功。 (5)运行成功后进入到安装Java jdk的bin目录下，以管理员身份打开powershell窗口，运行下面代码 -alias mydemoapp –表示别名，自定义修改 -keyalg RSA –产生键的加密算法 -validity 40000 –有效期限4000天，自定义修改 -keystore myapp.keystore –表示最后生成的证书文件名，自定义修改 -sigalg SHA1WithRSA –很重要否则在打包时会提示证书不是有效的keystore文件，因为HBuilder解析不了默认的证书格式 -keysize 1024 –很重要否则在打包时会提示证书不是有效的keystore文件，因为HBuilder解析不了默认的证书格式 1keytool -genkey -alias mydemoapp -keyalg RSA -sigalg SHA1WithRSA -validity 40000 -keysize 1024 -keystore myapp.keystore 之后会出现一个填写密钥的窗口，依次输入即可在输入密码时，窗口是不显示的，输入后回车即可输入完成后会生成一个myapp.keystore的文件 如果打包出现证书无效时 需要更改一下证书类型注：自己的证书名称要对应1keytool -importkeystore -srckeystore myapp.keystore -destkeystore myapp.keystore -deststoretype JKS最后查看keystore文件1keytool -list -v -keystore myapp.keystore","link":"/2019/08/15/uploadProject/"},{"title":"调用手机扫描二维码功能","text":"调用Hbuilder 二维码plus模块 来实现 二维码扫描功能,二维码的状态和使用最好在vuex中赋值，以方便控制。在mounted阶段调用下面代码片段12345678910111213141516171819202122232425262728293031323334353637startRecognize(){ let that = this if (!window.plus) return // 使用vuex来创建scan二维码 that.$store.commit('changescan', new plus.barcode.Barcode('qrcode')) // 设置扫描之后的函数回调 that.$store.commit('changeonmarked',onmarked) // 开始扫描 that.$store.commit('staticScan') //设置扫描二维码页面样式，根据需求自行调整 barcode.setStyle({ background:'#8f9494', height:&quot;100%&quot; }); //成功之后的函数回调 function onmarked(type, result, file) { switch (type) { case plus.barcode.QR: type = 'QR' break case plus.barcode.EAN13: type = 'EAN13' break case plus.barcode.EAN8: type = 'EAN8' break default: type = '其它' + type break } // 获得扫描的二维码路径 result = result.replace(/\\n/g, '') //在data中设置变量codeUrl that.codeUrl = result }}在退出二维码页面时需要将二维码扫描关闭，不然会一直在页面中显示1this.$store.commit('closeScan') 下面是vuex 中的的调用 1234567891011121314151617181920212223242526const state = { scan:null }const mutations = { //创建 changescan(state, data) { state.scan = data }, //成功回调 changeonmarked(state, data){ state.scan.onmarked = data }, //开始扫描 staticScan(state){ state.scan.start(); }, //关闭二维码 closeScan(state){ state.scan.close(); }}export default { state, mutations} 另外在Android移动端需要控制物理返回键退出二维码页面,在APP.vue 的mounted阶段调用此函数 12345678910111213141516171819202122232425262728293031323334bindBack() { let vm = this; let first = null; plus.key.addEventListener(&quot;backbutton&quot;, () =&gt; { if ( this.$route.name == &quot;LabManagerIndex&quot; || this.$route.name == &quot;LogingIndex&quot;|| this.$route.name == &quot;gaugerIndex&quot;|| this.$route.name == &quot;EquipmentengineerIndex&quot; ) { //此处是需要直接退出app的页面路由 if (!first) { first = new Date().getTime(); //记录第一次按下回退键的时间 plus.nativeUI.toast(&quot;再按一次退出应用&quot;); setTimeout(function() { //1s中后清除 first = null; }, 2000); } else { if (new Date().getTime() - first &lt; 2000) { //如果两次按下的时间小于1s， plus.runtime.quit(); //那么就退出app } } }else if(this.$route.name == 'QRcodeIndex'){ //二维码页面 this.$router.back(-1) this.$store.commit('closeScan') }else{ this.$router.back(-1) } }); },","link":"/2019/08/28/qrcode/"},{"title":"vue项目运行后，在IE浏览器打开，页面为空白","text":"解决方案： 一、首先安装babel-polyfill 1npm install --save babel-polyfill 二、在main.js里引入1import 'babel-polyfill'三、在首页index.html中添加 1&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt; 四、配置项目文件build中的webpack.base.conf.js修改如下配置 123entry:{ app:['babel-polyfill','./src/main.js'] }","link":"/2020/07/15/vue/"},{"title":"基于HBuilder 开发 项目之微信支付","text":"@(HBuilder)[微信支付 |vue] 此项目是基于vue开发的一款移动端app,然后基于HBuilder进行打包成apk文件。 一 、用户申请微信开放平台申请移动应用首先进入微信开放平台,如果有账号的话直接登录，没有的话则根据步骤申请一个账号 登陆注册 ：首先进入微信开放平台,如果有账号的话直接登录，没有的话则根据步骤申请一个账号 创建应用 ：可以根据提示一步一步操作 注意：申请时需要用到app的包名和应用签名。 应用包名： 是在APP项目配置文件AndroidManifest.xml中声明的package值. 应用签名： 根据项目的应用包名和编译使用的keystore. 可由签名工具生成一个32位的md5串，我们将打包好的app（配有证书文件的前提）装在手机上，记住打包时需配置appID。打包时的具体流程详细配 置这里不再一一说明，如图所示另外也支持 Java JDK 来生成MD5 签名,下载完双击安装。注意！！！此处有坑 Java JDK高版本的工具只能生成SHA1和SHA256这俩个微信支付用不了，，，所以请看清楚版本(推荐下载的版本为jdk-6u43-windows)安装完成后以管理员身份进入Java下的bin目录，1cd C:\\Program Files (x86)\\Java\\jdk1.8.0_144\\bin输入命令1keytool -genkey -v -keystore debug.keystore -alias androiddebugkey -keyalg RSA -validity 10000然后查看生成的证书文件debug.keystore 1keytool -list -v -keystore debug.keystore 到这里签名就成功了 到此为止 到此为止申请流程走通可以等待微信支付审核通过。二、调用HBuilder的 plus模块支付一共分为两步首先是获取手机的支付通道，这里的支付通道是我们在HBuilder 打包时所配置的支付模块 123456789101112131415 // 获取支付通道 plus.payment.getChannels(function(channels) { //channel就是我们获取到的支付通道信息 var txt = '支付通道信息：'; for(var i in channels) { var channel = channels[i]; if(channel.id == 'qhpay' || channel.id == 'qihoo') { // 过滤掉不支持的支付通道 continue; } } } }, function(e) { ddsd.log('获取支付通道失败：' + e.message); }); } 子商户调用“服务商提供的接口”返回支付数据，在APP发起支付 参数示例如下 拿到参数后调取plus 模块 的支付12345plus.payment.request(pays, order, function(result) { //支付成功回调 }, function(e) { //支付失败回调}); 参数说明 pays 参数为上面获取到的支付通道里的对象，，， 治理再调用微信支付时进行具体判断拿到参数对象order就是我们通过后台数据拿到的订单信息，切记转为字符串格式","link":"/2019/07/20/weixinPay/"},{"title":"VUE页面后退无刷新","text":"离开当前页面时记录当前位置，使用sessionStorage存储数据（其中 wrapbox 当前滚动页面最外层的div ,ref=wrapbox）1234567891011beforeRouteLeave(to, from, next) { //记录离开时的位置__&quot;) sessionStorage.askPositon = this.$refs.wrapbox &amp;&amp; this.$refs.wrapbox.scrollTop; if(to.name=='smission' ||to.name=='buyer'){ sessionStorage.askPositon ='' }//前进时无需记录位置，可以将数据置为空 console.log(&quot;出去的位置&quot;) console.log(sessionStorage.askPositon) next();},进入页面后采用离开时的位置1234567891011121314151617181920beforeRouteEnter(to, from, next) {console.log(sessionStorage.askPositon)if (!sessionStorage.askPositon) {//当前页面刷新不需要切换位置sessionStorage.askPositon = &quot;&quot;;next();} else {next(vm =&gt; { if (vm &amp;&amp; vm.$refs.wrapbox) { console.log(&quot;进来的位置&quot;) console.log(sessionStorage.askPositon); setTimeout(function() { vm.$nextTick(() =&gt; { vm.$refs.wrapbox.scrollTop=sessionStorage.askPositon }); },80); //同步转异步操作 } });}},","link":"/2019/05/31/vueSessionStorage/"},{"title":"手机网页版微信分享以及微信授权","text":"微信分享，第一次接触会发现很多坑。网页版微信分享是不支持按钮去分享的，只能通过微信右上角的按钮去分享。通过按钮分享的目前只支持APP。其实这样一来H5的分享就简单了很多。只需要调用微信官方出的微信jssdk，加上些许配置，就可以实现h5页面在微信上的分享，点击进入官方api文档;注意：这里使用的都是微信官方最新的文档 一、首先获取配置所需要的参数 首先使用已有公众号的appid，然后根据这个appid和url向后端发起请求，拿到配置所需要的参数：timestamp( 时间戳)、noncestr(随机字符串)和signature(签名)。所有需要使用JS-SDK的页面必须先注入配置信息，否则将无法调用 二、项目引入微信jssdk 引入方式有两种，各取所需：(1)、通过导入依赖包首先通过npm 安装依赖1npm i -S weixin-js-sdk然后在页面中引入1import wx from 'weixin-js-sdk' (2)通过script标签，引入微信官网的JS-SDK文件 1&lt;script src=&quot;http://res.wx.qq.com/open/js/jweixin-1.4.0.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; 三、通过config接口注入权限验证配置1234567891011wx.config({ debug: false, // 开启调试模式 appId: data.appId, // 必填，公众号的唯一标识 timestamp: data.timestamp, // 必填，生成签名的时间戳 nonceStr: data.nonceStr, // 必填，生成签名的随机串 signature: data.signature, // 必填，签名 jsApiList: [ 'updateTimelineShareData',//自定义“分享到朋友圈”及“分享到QQ空间”按钮的分享内容（1.4.0） 'updateAppMessageShareData',//自定义“分享给朋友”及“分享到QQ”按钮的分享内容（1.4.0） ] // 必填 }) 四、分享原有的 wx.onMenuShareTimeline、wx.onMenuShareAppMessage、wx.onMenuShareQQ、wx.onMenuShareQZone 接口，即将废弃。这里只介绍最新的 wx.updateAppMessageShareData、wx.updateTimelineShareData接口。 (1)自定义“分享给朋友”及“分享到QQ”按钮的分享内容（1.4.0）12345678910wx.ready(function(){ wx.updateAppMessageShareData({ title: option.title, // 分享标题 desc: option.desc, // 分享描述 link: option.link, // 分享链接 imgUrl: option.imgUrl, // 分享图标 success: function(res){ } }) }) (2)自定义“分享到朋友圈”及“分享到QQ空间”按钮的分享内容（1.4.0）123456789101112131415wx.ready(function(){ wx.updateTimelineShareData({ title: option.title, // 分享标题 link: option.link, // 分享链接 imgUrl: option.imgUrl, // 分享图标 desc: option.desc, // 分享描述 success: function(res){ // 用户成功分享后执行的回调函数 _this.$http.post(_this.$conf.env.updateShareCount, params).then(res =&gt;{ alert('成功') }).catch(err =&gt;{ }) } }); }) 五、遇到的问题 (1)微信分享途中如果取消分享后走的成功回调,无法识别是否分享成功这个问题确实是存在的，最后发现是微信官方做出的调整，本题无解，官方也有给出解释点击查看 (2)微信JS-SDK加载尚未完成，用户就点击分享，这时分享出去的页面没有标题和内容我有尝试在加载尚未完成时去禁止用户点击右上角分享按钮，但是用户体验很差，最后无疾而终","link":"/2019/08/29/weixinSherch/"},{"title":"前端网络","text":"网络相关的知识也是面试时经常会被问到的问题，面试官很有必要确认面试者是否只会使用$.ajax()方法，还是真正了解网络请求的原理。问题列表 get和post的区别 websocket是否了解 http 2.0对于http 1.x有哪些优点？ jq的ajax返回值是什么？ 说一说你知道的HTTP状态码 jsonp的原理 跨域请求资源有哪几种方式？他们的优缺点是什么？ XML和JSON的区别？ 1. get和post的区别get和post的区别这题看上很简单，你肯定能答出1个以上的区别，但是面试官往往期望你能答出更多更深层次的区别。这篇文章写的很详细了，大家可以研究一下——https://www.zhihu.com/question/28586791我在这里在概括一下：初级的答案因为GET方法请求的参数都是放在请求的url上的，所以它与POST有以下明显的区别： GET请求可以被添加到书签中，也可保存在浏览器历史记录中，POST不能 GET请求可以被浏览器缓存，POST不能 GET请求收到URL长度限制，所以数据长度也受限制，POST不会 GET请求只能传输ASCII字符，而POST不受此限制，还可以传输二进制数据 在语义上两个方法也有区别： GET 代表获取指定服务器上资源 POST 代表向指定的资源提交要被处理的数据 高级些的答案GET产生一个TCP数据包；POST产生两个TCP数据包。对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。但是需要多解释两句的是： 据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。 并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。 2.websocket是否了解？通常情况下，面试官问你是否对XX有了解，一般的回答都是要涵盖下面这些点： 是否知道它是什么？ 是否知道它的用途是什么？ 它和之前某项已有的技术相比，有哪些优缺点？ webSocket和http一样，同属于应用层协议。它最重要的用途是实现了客户端与服务端之间的全双工通信，当服务端数据变化时，可以第一时间通知到客户端。除此之外，它与http协议不同的地方还有： http只能由客户端发起，而webSocket是双向的。 webSocket传输的数据包相对于http而言很小，很适合移动端使用 没有同源限制，可以跨域共享资源 要想了解更多详细，还是去看阮一峰的教程吧——WebSocket 教程 - 阮一峰的网络日志 3.http 2.0对于http 1.x有哪些优点？优点（以下摘自HTTP/2.0 相比1.0有哪些重大改进？）： 多路复用：多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。由于http 1.x的时代中，浏览器向同一域名下发送的http请求数量是受限的，当超出数量限制时，请求会被阻塞，大大降低了用户体验。而HTTP/2 的多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。 二进制分帧：HTTP/2在应用层和传输层之间追加了一个二进制分帧层，最终使得多个数据流共用一个连接，更加高效的使用tcp连接。从而使得服务器的连接压力减轻，降低了内存的消耗，增大了网络的吞吐量。 首部压缩：HTTP/2引入了HPACK算法对头部进行压缩，大大减小了数据发送的字节数。 4.jQuery的ajax返回值是什么？很多公司，尤其是金融或数据分析的公司，他们的web app会与服务端进行大量的数据交互，所以他们的面试官通常会很看重面试者对于网络请求以及异步编程的理解程度。jQuery中的ajax大家很常用，以至于绝大部分人把他认为是“理所应当”，而忽略了他的底层逻辑和实现原理。$.ajax()方法返回的是一个延迟对象，即$.Deferred的实例。所以你可以像下面这样使用$.ajax()方法1234567891011//利用done()和fail()方法来处理ajax请求$.ajax({url:&quot;http://mydomain.com/memberInfo/get&quot;,async: false}).done( responseData =&gt; { console.log(responseData) }).fail( ()=&gt;{console.error('出错了！')})//$.get()也是同样的道理，除了上面延迟对象提供的方法外，还可以使用then()回调$.get(&quot;http://mydomain.com/memberInfo/get&quot;).then(responseData =&gt; {console.log(responseData);})如果你想让这两个请求都完成后再进行处理的话，可以用下面的操作：1234567891011var memberDef = $.get(&quot;http://mydomain.com/memberInfo/get&quot;);var orderDef = $.get(&quot;http://mydomain.com/orderInfo/get&quot;);$.when(memberDef, orderDef).then(( [memberInfo], [orderInfo])=&gt;{ //这里用到了解构赋值来取得http返回的数据 console.log('用户信息',memberInfo); console.log('订单信息',orderInfo);})想要了解更多关于延迟对象的内容，可以访问阮一峰的博客除了上面这一个问题，还可以追问一些下面的问题，这里就不展开解答了： 异步请求和同步请求的区别 ajax 请求有几种数据格式，如何设置数据格式 如何避免浏览器缓存get请求，以便达到每次get请求都能获取最新的数据 等等…… 5.说一说你知道的HTTP状态码以前遇到面试者说 HTTP状态码不应该是前端开发关心的事情。但我总觉得一个前端工程师对于http状态码的了解程度代表了他曾经踩过了多少雷，一个深入了解http状态码的工程师可以快速定位问题。 关于HTTP状态码应该有下面的基本认识： 1xx ：1开头的状态码表示临时的响应 2xx ：请求成功 3xx ：请求被重定向 4xx ：请求错误，表明客户端发送的请求有问题 5xx ：服务器错误，表明服务端在处理请求时发生了错误 知道上面的规律，再看到错误的时候就大概知道问题是后端的锅还是前端的锅了。再说几个常用的http状态码（如果有兴趣了解详细的话还是自己去找吧，网上很多（http://tools.jb51.net/table/http_status_code））： * 301 ： Moved Permanently 客户端请求的文档在其他地方，新的URL在location头中给出 * 304 ： Not Modified 客户端有缓存的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户端只想到指定日期后再更新文档）。服务器告诉客户，原来缓存的文档还可以继续使用。 * 400 ： Bad Request 请求出现语法错误 * 401 ： Unauthorized 访问被拒绝，客户端试图未经授权访问受密码保护的页面 * 403 ： Forbidden 资源不可用。服务器理解客户的请求，但拒绝处理它。通常由于服务器文件或目录的权限设置导致。 * 404 ： Not Found 无法找到指定位置的资源。 * 405 ： Method Not Allowed 请求方法（GET、POST、PUT等）对指定的资源不适用，用来访问本资源的HTTP方法不被允许。 * 500 ： Internal Server Error 服务器遇到了意料之外的情况，不能完成客户端的请求。 * 502 ： Bad Gateway 服务器作为网管或者代理时收到了无效的响应。 * 503 ： Service Unavailable 服务不可用，服务器由于维护或者负载过中未能应答。 * 504 ： Gateway Timeout 网关超时， 作为代理或网关的服务器不能及时的应答。 6.JSONP的原理JSONP是一种跨域共享资源的方法。很多人会好奇JSONP和JSON是什么关系，JSONP是JSON with padding的缩写，即填充式JSON或参数式JSON，是被包含在函数调用中的JSON，如下面的样子： callback({“name”: “Chong”});JSONP是通过动态元素来实现的，使用时可以为src属性指定一个跨域URL。由于浏览器加载脚本是不受同源规则限制的，所以即使是跨域的URL同样可以发送请求。因为JSONP是有效的JavaScript代码，所以再请求完成后，即在JSONP响应加载到页面中以后，就会立即执行。示例代码：function handleResponse(response){alert(“您的IP地址是 “ + response.ip);}var script = document.createElement(“script”);script.src = “http://freegeoip.net/json/?callback=handleResponse&quot;;document.body.insertBefore(script, document.body.firstChild);所以总结一下JSONP的实现方式： 1. 向当前页面中动态插入一个&lt;script&gt;元素，src属性设置为请求地址，并在地址中指定好回调函数 2. js代码中预先定义好jsonp的回调函数 3. 请求完成后，会立即调用预先指定好的jsonp回调，并将数据以json的格式传递到回调中。 JSONP之所以可以实现跨域，依赖的是下面的条件： 1. 浏览器请求脚本是不受同源规则限制的 2. &lt;script&gt;元素加载完成的脚本会立即执行 需要注意的是，JSONP是需要服务端配合的，因为JSONP返回的是一段代码。7.跨域请求资源有哪几种方式？他们的优缺点是什么？常见的跨域方式如下： * JSONP * 图像Ping * CORS * Web Sockets 一个一个说：JSONP优点：简单易用，浏览器支持好。缺点： 1. JSONP是从其他域中加载代码并执行，所以存在很多安全隐患，如果其他服务器在响应中夹带恶意代码的话，没有办法防范。 2. JSONP难以确定请求失败的情况。HTML5中给&lt;script&gt;元素增加了一个onerror事件，但是还是有浏览器不支持。 3. 只能发送GET请求 图像Ping这是指通过请求图片的方式来跨域发送请求。优点：简单，兼容性好，不需要服务器做针对性处理。缺点： 1. 只能单向通信，即客户端发送信号给服务端，无法接收到服务端的回复 2. 只能发送GET请求 3. 容易被浏览器缓存请求，导致请求发送不出去。 CORSCORS是Cross-Origin Resource Sharing的缩写，即跨域资源共享。CORS的基本思想就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。优点：功能强大缺点： 1. 需要服务端来配合实现（其实很简单~） 2. IE必须IE10以上。。。 WebSocket这个貌似就不用多说了，属于没用过也应该听过的一种技术。优点： 1. 双工通信，浏览器和服务器都可以发起请求 2. 通信效率高，一次链接可以复用，省去反复的握手环节 缺点： 1. 实现上较为复杂，包括客户端和服务端 2. 浏览器支持问题 还有很多其他的跨域方式，在这里就不说了8.XML和JSON的区别？XML是标准通用标记语言 (SGML) 的子集，而标签语言（如HTML）的好处就是易懂。优点：上手简单，非开发人员也可以快速上手（产品经理们很喜欢）。缺点： 1. XML多余的数据比较多，所以数据量大，传输时占用更多空间 2. 客户端和服务端解析XML都要比较繁琐，需要大量代码 JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式。重点在轻上，结构与JavaScript中的Object类似。优点： 1. 数据量小，利于网络传输 2. 方便解析，客户端和服务端都有基础的解析方法 缺点：结构稍微有点复杂，非开发人员不容易上手（初学者需要去官网学习研究一下）","link":"/2021/03/12/%E5%89%8D%E7%AB%AF%E7%BD%91%E7%BB%9C/"},{"title":"迭代器与生成器","text":"（一）迭代器 Iterator迭代器就是一个接口方法，它为不同的数据结构提供了一个统一的访问机制；使得数据结构的成员能够按某种次序排列，并逐个被访问。 那么在日常开发中，如何让一个对象成为一个可迭代对象呢？即支持迭代器规范的对象（iterable）可以给obj 对象添加Symbol.iterator属性，同时在返回的next方法中，添加value和done两个属性。1234567891011121314151617let obj = { 0:'d', 1:'dp', 2:'f', length:4, [Symbol.iterator]: function(){ let index = 0; let next = () =&gt; { return { value:this[index], done: this.length == ++index } } return {next} }}console.log([...obj]) 输出结果 value属性返回当前位置的成员，done属性是一个布尔值，表示遍历是否结束，即是否还有必要再一次调用next方法；当done为true时，即遍历完成。既让它成为了一个可迭代对象可以使用扩展运算符。 （二）生成器 生成器是一个极为灵活的结构，拥有在一个函数内暂停和恢复代码执行的能力。 其实Generator函数就是一个普通函数，但是有两个特征，一是，function关键字与函数名之间有一个星号*；二是，函数内部使用yield表达式，定义不同的内部状态。 生成器函数的使用123456function* generatorFn(){}const generatorObject = generatorFn()console.log(generatorObject ) //generatorFn（&lt;suspended&gt;）console.log(generatorObject.next())// { value: undefined, done: true }next()方法的返回值类似于迭代器，有一个done属性和一个value属性。函数体为空的生成器函数中间不会停留，调用一次next()就会让生成器到达done:true状态。 value 属性是生成器函数的返回值，默认undefined,可以通过生成器函数的返回值指定：12345678function* generatorFn(){ return 'foo'}const generatorObject = generatorFn()console.log(generatorObject ) //generatorFn（&lt;suspended&gt;）console.log(generatorObject.next())// { value: 'foo', done: true }通过yiled中断执行yiled 关键字可以让生成器停止和开始执行，也是生成器最有用的地方。生成器函数在遇到yield关键字之前会正常执行，遇到这个关键字之后会停止执行，函数作用域的状态会被保留。停止执行的生成器函数只能通过在生成器对象上调用next()方法来恢复执行。123456789101112131415function* helloWorldGenerator() { yield 'hello'; yield 'world'; return 'ending';}var hw = helloWorldGenerator();hw.next()// { value: 'hello', done: false }hw.next()// { value: 'world', done: false }hw.next()// { value: 'ending', done: true }hw.next()// { value: undefined, done: true } 调用生成器函数会产生一个生成器对象。生成器对象一开始处于暂停执行（suspended)的状态。与迭代器相似，生成器对象也实现了iterator接口，因此具有next()方法。调用这个方法会让生成器恢复执行。 生成器对象作为可迭代对象在生成器对象上显式调用next()方法的用处并不大。其实，如果把生成器对象当作可迭代对象，那么使用起来会很方便：1234567891011function* generatorFn(){ yiled 1; yiled 2; yiled 3;}for(const x of generatorFn()){console.log(x)}//1//2//3","link":"/2021/04/17/%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/"},{"title":"什么是单元测试，如何去写一个单元测试","text":"相信单元测试是属于那种没有用过也听过的技术（如果你是大佬，听过也用过，欢迎提出宝贵的意见🧎‍♀️🧎‍♂️）。那么到底什么是单元测试，单元测试在实际项目开发中能给我们带来什么样的好处？我们站在前端开发的角度一起来聊一聊单元测试。 📚（一）什么是单元测试📢单元测试概念 单元测试是指对软件中最小可测单元进行检查和验证；c语言中单元指一个函数，java中指一个类。图形化软件中可以指一个窗口或者一个菜单。总的来说，单元就是认为规定最小的被测试模块。这个便是对百度百科上对单元测试的介绍，那么对于我们前端来说单元测试是用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作。 大多数单元测试包括四个主体： 测试套件describe、 测试用例it、 判定条件expect、 断言结果toEqual。 什么不是单元测试在了解了什么是单元测试的基础上，那么什么不是单元测试呢？在《修改代码艺术》一书上有这样的介绍： 需要访问数据库的测试不是单元测试 需要访问网络的测试不是单元测试 需要访问文件系统的测试不是单元测试 以上便是对单元测试概念的简单介绍，那么为什么要使用单元测试,单元测试有什么优势，不考虑回报的程序员不是好的程序员。 📚（二）单元测试对我们开发程序有什么好处 首先是一个前端单元测试的根本性原由：JavaScript 是动态语言，缺少类型检查，编译期间无法定位到错误; JavaScript 宿主的兼容性问题。比如 DOM 操作在不同浏览器上的表现。 正确性：测试可以验证代码的正确性，在上线前做到心里有底。 自动化：当然手工也可以测试，通过console可以打印出内部信息，但是这是一次性的事情，下次测试还需要从头来过，效率不能得到保证。通过编写测试用例，可以做到一次编写，多次运行。 解释性：测试用例用于测试接口、模块的重要性，那么在测试用例中就会涉及如何使用这些API。其他开发人员如果要使用这些API，那阅读测试用例是一种很好地途径，有时比文档说明更清晰。 驱动开发，指导设计：代码被测试的前提是代码本身的可测试性，那么要保证代码的可测试性，就需要在开发中注意API的设计，TDD将测试前移就是起到这么一个作用。 保证重构：互联网行业产品迭代速度很快，迭代后必然存在代码重构的过程，那怎么才能保证重构后代码的质量呢？有测试用例做后盾，就可以大胆的进行重构。 我们知道 高覆盖率的单元测试，可以保证每次上线bug率大大降低，也是代码重构的基础。很多老项目，开发人员离职、新接手的人员不敢重构，慢慢称为团队负担、又不能下线，就是因为没有单元测试，改一点都怕出现不可测的bug。简单来说，也可以概括为以下几点 提高代码质量 减少bug，快速定位bug 放心地修改、重构 单元测试不但会使你的工作完成得更轻松。而且会令你的设计会变得更好，甚至大大减少你花在 调试上面的时间 📚（三）如何编写单元测试用例如何编写单元测试用例，单元测试用例的原则是什么: 测试代码时，只考虑测试，不考虑内部实现； 数据尽量模拟现实，越靠近现实越好， 充分考虑数据的边界条件下· 对重点、复杂、核心代码、重点测试 利用AOP（面向切面编程），减少测试代码，避免无用功能 测试、功能开发相结合，有利于设计和代码重构 🔎插一个小知识点：那么这里提到的AOP是什么意思，AOP是Aspect Oriented Program的首字母缩写意思是面向切面编程，这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。📌一般而言，我们管切入到指定类指定方法的代码片段称为切面，而切入到哪些类、哪些方法则叫切入点。有了AOP，我们就可以把几个类共有的代码，抽取到一个切片中，等到需要时再切入对象中去，从而改变其原有的行为。 再简单了解了单元测试之后我们将其带入到我们实际项目开发中，来尝试一下 📚（四）组件化后，组件哪部分最具测试价值？（以React为例） 1. ComponentComponent 应着重关注render以及副作用，同时业务逻辑的处理过程，都应该尽量提取到Hooks和Utils文件中。因此，对于Component的测试，我们完全可以将重心主要放在以下这两方面问题上： 组件是否正常渲染了？ 组件副作用是否正常处理了？ 2. Hooks如何测试React Hooks，社区目前已有相对成熟的解决方案，即@testing-library/react-hooks + react-test-renderer[2]。通过这两个依赖，开发人员可以很轻松的mock出Hooks执行所依赖的环境，把store的数据当作hooks的输入，关注在hooks内的业务逻辑，即可把Hooks当作纯方法（Pure Function）来进行测试。 3. Redux对于Redux，如果项目在使用 Redux Toolkit 的话，事情会简单很多，开发人员只需要关注Dispatch的Actions即可。但如果Actions和Reducer是分开编写，则需要针对性处理 4. Service不同项目或团队对Service的定义各不相同，这里我们要聊的主要指负责处理HTTP请求的request和response，以及相应的异常处理的数据层。Service主要的功能是对接Action，因而理想情况下Service只需要包含与API通信的代码，这种情况下，UT可有可无。但一些场景下，如果项目中没有使用BFF承担数据处理的角色，后端也没能提供完全符合前端数据结构需求的接口时，不可避免的，开发人员需要在此处完善数据处理的逻辑，以便获取清洗或聚合后的数据，因而这种情况下，UT覆盖是非常有必要的。 5. Utils/HelpersUtils/Helpers主要包含以下几类类型：数据结构的转化，各种convert工具函数数据结构的处理，比如数据提取、合并压缩、整理工具函数公共的工具函数根据我们目前的项目习惯，当一段逻辑需要在Utils/Helpers中实现时，那么它一定是纯函数，其中多数情况又会包含一定程度的数据处理逻辑，所以基本都需要UT覆盖 在了解了项目组件哪些部分最具有测试价值之后，我们就要上手了，跃跃欲试中🤸‍♀️🤸‍♂️ 📚（五）如何让我们的测试用例更易编写、维护？举个例子💁‍🌰，先看代码，看不看得懂不重要🧎‍♀️，我们先来了解一下 1234567891011121314151617181920// production codeconst computeTotalAmount = (products) =&gt; { return products.reduce((total, product) =&gt; total + product.price, 0); }// testing codeit('should return summed up total amount 1000 when there are three products priced 200, 300, 500', () =&gt; { // given - 准备数据 const products = [ { name: 'nike', price: 200 }, { name: 'adidas', price: 300 }, { name: 'lining', price: 500 }, ] // when - 调用被测函数 const result = computeTotalAmount(products) // then - 断言结果 expect(result).toBe(1000)}) 可以看到我们首先定义了一个computeTotalAmount的待测函数，it包裹了我们的测试用例。在测试用例中，首先第一步：准备数据，然后调用被测函数，最后输出断言结果。 可以看到这样的结果清晰明了。好的单元测试应该遵循AAA的模式，AAA模式：编排（Arrange），执行（Act），断言（Assert）。可以让你写出比较清晰的测试结构，既易于阅读，也易于编写 编写单元有以下几个编写原则： 🎈mock数据集中管理，考虑mock数据极端情况 🎈只关注输入输出，不关注内部实现 🎈一个单元测试只测一个业务场景 如此你才能给它一个好的描述，这个测试才能保护这个特定的业务场景，挂了的时候能给你细致到输入输出级别的 业务反馈。 🎈表达力极强，不包含逻辑 表达力强的测试，能在失败的时候给你非常迅速的反馈，看到测试时，你就知道它测的业务点是啥 测试挂掉时，能清楚地知道失败的业务场景、期望数据与实际输出的差异，跟写声明式的代码一样的道理，测试需要都是简单的声明：准备数据、调用函数、断言，让人一眼就明白这个测试在测什么。如果含有逻辑，你读的时候就要多花时间理解；一旦测试挂掉，你咋知道是实现挂了还是测试本身就挂了呢？ 🎈运行速度快 可以使用mock适当隔离掉三方的依赖，将依赖、集成等耗时、依赖三方返回的地方放到更高层级的测试中，有策略性地去做 🎈隔离性 单元测试是对代码独立的单元进行测试，这个独立的意思不是说这个函数（单元）不会调用另外一个函数（单元），而是说我们在测试这个函数的时候如果它有调用到其它的函数我们就需要mock它们，从而将我们的测试逻辑只放在被测试函数的逻辑上，不会受到其它依赖函数的影响 最后我们带入项目实际开发一下吧 📚（六）react单元测试框架enzyme实际应用1. 测试工具：主要用到的测试工具是 jest 和 enzyme2. 待测组件:可以添加删除的一个简单列表；3. 我们想要测试四点：1、组件渲染 2、渲染时初始待办事项的展示 3、我们可以创建一个新的待办事项然后返回三个待办事项 4、我们可以删除一个初始的待办事项并且只留下一个 上代码ing….. 上组件👩‍🌾👩‍🌾👩‍🌾1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889import React, { useState, useRef } from &quot;react&quot;;const Todo = () =&gt; { const [list, setList] = useState([ { id: 1, item: &quot;Fix bugs&quot; }, { id: 2, item: &quot;Take out the trash&quot; } ]); const todoRef = useRef(); const removeTodo = id =&gt; { setList(list.filter(todo =&gt; todo.id !== id)); }; const addList = data =&gt; { let id = list.length + 1; setList([ ...list, { id, item: data } ]); }; const handleNewTodo = e =&gt; { e.preventDefault(); const item = todoRef.current; addList(item.value); item.value = &quot;&quot;; }; return ( &lt;div className=&quot;container&quot;&gt; &lt;div className=&quot;row&quot;&gt; &lt;div className=&quot;col-md-6&quot;&gt; &lt;h2&gt;Add Todo&lt;/h2&gt; &lt;/div&gt; &lt;/div&gt; &lt;form&gt; &lt;div className=&quot;row&quot;&gt; &lt;div className=&quot;col-md-6&quot;&gt; &lt;input type=&quot;text&quot; autoFocus ref={todoRef} placeholder=&quot;Enter a task&quot; className=&quot;form-control&quot; data-testid=&quot;input&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div className=&quot;row&quot;&gt; &lt;div className=&quot;col-md-6&quot;&gt; &lt;button type=&quot;submit&quot; onClick={handleNewTodo} className=&quot;btn btn-primary&quot; &gt; Add Task &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;div className=&quot;row todo-list&quot;&gt; &lt;div className=&quot;col-md-6&quot;&gt; &lt;h3&gt;Lists&lt;/h3&gt; {!list.length ? ( &lt;div className=&quot;no-task&quot;&gt;No task!&lt;/div&gt; ) : ( &lt;ul data-testid=&quot;list&quot;&gt; {list.map(todo =&gt; { return ( &lt;li key={todo.id}&gt; &lt;div&gt; &lt;span&gt;{todo.item}&lt;/span&gt; &lt;button className=&quot;btn btn-danger&quot; data-testid=&quot;delete-button&quot; onClick={() =&gt; removeTodo(todo.id)} &gt; 删除 &lt;/button&gt; &lt;/div&gt; &lt;/li&gt; ); })} &lt;/ul&gt; )} &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; );};export default Todo; 组件很简单，一个添加一个删除的简单功能，但是直接看代码会感觉乱七八糟的，一点也不清晰明了，那么我们来看测试用例，乌拉……12345678910111213141516171819202122232425262728293031323334353637383940import React from &quot;react&quot;;import { shallow, mount } from &quot;enzyme&quot;;//import 'jsdom-global/register';//在测试单测完成度时打开import App from &quot;./App&quot;;describe(&quot;Todo&quot;, () =&gt; { //将一个组件渲染成虚拟DOM对象，但是只渲染第一层，不渲染所有子组件，所以处理速度非常快 it(&quot;组件渲染&quot;, () =&gt; { shallow(&lt;App /&gt;); }) it(&quot;查询li个数&quot;, () =&gt; { const wrapper = mount(&lt;App /&gt;); //mount可以渲染组件APP下的所有子组件 expect(wrapper.find(&quot;li&quot;)).toHaveLength(2); //我们通过find找到元素li,因为有组件中list有两条默认数据，所以元素li应该是有两个，我们直接输出断言结果。 }); it(&quot;调用addList&quot;, () =&gt; { const wrapper = mount(&lt;App /&gt;); wrapper.find(&quot;input&quot;).instance().value = &quot;新增加一个&quot;; //这里同理找到input元素，并给其赋值“新增加一个” expect(wrapper.find(&quot;input&quot;).instance().value).toEqual(&quot;新增加一个&quot;); //赋值完成后，我们找到对应的input元素，查询input的值，增加断言判断是否为“新增加一个” wrapper.find('[type=&quot;submit&quot;]').simulate(&quot;click&quot;); //找到type为submit的button，触发click事件 expect(wrapper.find(&quot;li&quot;)).toHaveLength(3); //断言li的长度是否为3 expect(wrapper.find(&quot;li div span&quot;).last().text()).toEqual(&quot;新增加一个&quot;); //断言最后一个li(新添加的那一个)，其中子元素span的值是否为“新增加一个” }); it(&quot;调用removeTodo&quot;, () =&gt; { const wrapper = mount(&lt;App /&gt;); wrapper.find(&quot;li button&quot;).first().simulate('click'); //找到以一个li中的button,触发click事件 expect(wrapper.find(&quot;li&quot;)).toHaveLength(1); //触发删除按钮后，查询li的长度，应该为1 expect(wrapper.find(&quot;li div span&quot;).last().text()).toEqual(&quot;Take out the trash&quot;); //最后查询第一个li的子元素span, 它的值是否为Take out the trash })}); 那么我们运行一下yarn test 可以看到每个测试用例的运行时间 我们再来试一下单测覆盖度jest --coverage 可以看到我们的覆盖率（lines）是100%的 那么以上便是对单元测试的简单介绍，这里附上最后这个例子🌰的 📎github地址","link":"/2021/06/20/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"},{"title":"前端的单点登录👀","text":"一、什么是单点登录单点登录（Single Sign On），简称为 SSO，是目前比较流行的企业业务整合的解决方案之一。SSO的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。 SSO一般都需要一个独立的认证中心（passport），子系统的登录均得通过passport。子系统本身将不参与登录操作，当一个系统成功登录以后，passport将会颁发一个令牌给各个子系统，子系统可以拿着令牌会获取各自的受保护资源，为了减少频繁认证，各个子系统在被passport授权以后，会建立一个局部会话，在一定时间内可以无需再次向passport发起认证。👻 二、单点登录的实现1、同域名下的单点登录一个企业一般情况下只有一个域名，通过二级域名区分不同的系统，比如说我们公司的域名a.com ，同时有两个业务系统分别为：qa.a.com和qa2.a.com。那么需要再做单点登录（SSO），需要一个登录系统，叫做：sso.a.com。 可以在sso.a.com中登录，并在将cookie设置在顶级域名中,这样所有的子域应用就都可以访问到这个 Cookie 了.实现了简单的单点登录 2、不同域名下的单点登录（1）统一认证中心方案（CAS标准方案🥴）看到很有意思的例子：例如你去食堂吃饭，食堂打饭的阿姨www.qiandu.com告诉你，不收现金。并且告诉你，你去门口找换票的（passport.com）换小票。于是你换完票之后，再去找食堂阿姨，食堂阿姨拿着你的票，问门口换票的，这个票是真的吗？换票的说，是真的，于是给你打饭了。 第一步：用户访问www.qiandu.com。过滤器判断用户是否登录，没有登录，则重定向（302）到网站http://passport.com。 第二步：重定向到passport.com，输入用户名密码。passport.com将用户登录的信息记录到服务器的session中。 第三步：passport.com给浏览器发送一个特殊的凭证，浏览器将凭证交给www.qiandu.com，www.qiandu.com则拿着浏览器交 给他的凭证去passport.com验证凭证是否有效，从而判断用户是否登录成功。 第四步：登录成功，浏览器与网站之间进行正常的访问。 (2)LocalStorage跨域实现前端可以通过 iframe+postMessage() 方式，将同一份 Token 写入到了多个域下的 LocalStorage 中，前端每次在向后端发送请求之前，都会主动从 LocalStorage 中读取 Token 并在请求中携带，这样就实现了同一份 Token 被多个域所共享。示例代码12345678910111213141516171819// 获取 tokenvar token = result.data.token;// 动态创建一个不可见的iframe，在iframe中加载一个跨域HTMLvar iframe = document.createElement(&quot;iframe&quot;);iframe.src = &quot;http://app1.com/localstorage.html&quot;;document.body.append(iframe);// 使用postMessage()方法将token传递给iframesetTimeout(function () { iframe.contentWindow.postMessage(token, &quot;http://app1.com&quot;);}, 4000);setTimeout(function () { iframe.remove();}, 6000);// 在这个iframe所加载的HTML中绑定一个事件监听器，当事件被触发时，把接收到的token数据写入localStoragewindow.addEventListener('message', function (event) { localStorage.setItem('token', event.data)}, false);系统在被passport授权以后，会建立一个局部会话，在一定时间内可以无需再次向passport发起认证。👻 参考链接https://blog.csdn.net/ban_tang/article/details/80015946https://www.jianshu.com/p/75edcc05acfd","link":"/2021/07/21/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"},{"title":"React SSR 的实现","text":"再看react ssr 之前，我们先来看一个使用react ssr 实现的应用，感受一下它飞一般的渲染速度 https://m.xin.com/ 看过之后我们再来看文章。 📚导读关于服务端渲染（SSR）、客户端渲染（CSR）和 同构渲染，我在next.js从入门到实战这篇文章中开头有详细的介绍，还不了解这三种渲染方式的可以简单了解一下。 但只实现 SSR 没什么意义，技术上没有任何改进，否则 SPA 技术就不会出现😀。但是单纯的 SPA 又不够完美，所以最好的方案就是这两种技术和体验的结合。但是要实现两种技术的结合，同时可以最大限度的重用代码（同构），减少开发维护成本，那就需要采用 react 或者 vue 等前端框架和node(ssr)相结合的方式来实现。 如果我们使用react ssr 来实际开发项目，我们就需要一个完整的开发框架，next.js其实就是这种框架，类似的还有nuxt.js。那这种框架的实现原理是什么呢？ 📚react ssr 实现原理在了解react ssr 我们先来看两个概念。 📒虚拟domreact ssr其中的SSR指的是在服务端渲染组件。而组件可以在服务端渲染的根本原因就是虚拟 DOM，我们一般使用jsx来编写react组件，但其实jsx是一个语法糖，其实我们编写的组件都可以解析为一个个对象。这个对象包含 🎈tag：节点标签名 🎈props：DOM的属性，用一个对象存储键值对 🎈children： 该节点的子节点我们有了这个对象，我们就可以轻松的将其转换为我们需要的格式，比如html格式，当然这个转换不需要我们来完成，这个转换react已经帮我们完成了，其本身提供内置方法支持服务端渲染；我们先来具体了解一下同构的概念； 📒同构同构是将传统的纯服务端直出的首屏优势和SPA的站内体验优势结合起来，以取得最优解的解决方案。 就是服务端把首屏的内容直出，让用户更快的看到页面，然后后面的数据采用js来异步请求和加载。貌似不用react一样可以做到的呀，那为什么还一定要使用react或者vue这种框架来结合ssr呢？ 我们知道同构就是指前后端公用一套代码，比如我们的组件可以在服务端渲染也可以在客户端渲染，但都是同一个组件。这也是react本身的优势。我们使用react来写，可以减少我们的代码量，基于react来实现更加方便，高效，因为我们可以使用react + node 来构造 📒结语其实到这里我们也明白了什么是react ssr , react ssr 就是react 利用自身虚拟dom 的优势，然后通过同构渲染来实现的。react ssr 的核心就是同构，没有同构的 ssr 是没有意义的。 📚react ssr 是如何实现的我们了解了什么是react ssr ，那么react ssr 是怎么实现的呢，是怎么实现的服务端渲染，html的转换？ 为了实现服务端渲染，打造同构应用，react内部实现了相关的API，可以将组件转换为html，可以一起来看一下这ReactDOMServer 这个 api 📒ReactDOMServerReactDOMServer 类可以帮我们在服务端渲染组件 - 得到组件的 html 字符串。 该模块有两个方法renderToString 和 renderToStaticMarkup，两个方法都是将组件转换为html格式的，它们的使用方式也是相同的，不同的是renderToStaticMarkup不需要计算，所以性能能高，速度更快。 📚react ssr 如何解决seo tdk支持对于这个问题，其实有现成的轮子可以使用。它就是react-helmet;const helmet = Helmet.renderStatic();)。 📒简介React Helmet是一个HTML文档head管理工具，管理对文档头的所有更改。 📒特点 支持所有有效的head标签: title、 base、 meta、 link、 script、 noscript、 和style。 支持body、 html 和 title 的属性 支持服务端渲染 嵌套组件覆盖重复的head标签更改。 在同一组件中定义时，将保留重复的head标签更改。(支持如”apple-touch-icon”的标签). 支持跟踪DOM更改的回调 📒安装Npm 1npm i react-helmet Yarn 1yarn add react-helmet 📒💁‍♀️🌰简单示例1234567891011121314151617import React from &quot;react&quot;;import {Helmet} from &quot;react-helmet&quot;;class Application extends React.Component { render () { return ( &lt;div className=&quot;application&quot;&gt; &lt;Helmet&gt; &lt;meta charSet=&quot;utf-8&quot; /&gt; &lt;title&gt;My Title&lt;/title&gt; &lt;link rel=&quot;canonical&quot; href=&quot;http://mysite.com/example&quot; /&gt; &lt;/Helmet&gt; ... &lt;/div&gt; ); }};","link":"/2021/11/10/React%20SSR%20%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"title":"javascript设计模式","text":"设计模式是我们在 解决问题的时候针对特定问题给出的简洁而优化的处理方案，这里我跟大家简单聊一下前端中常用的三个设计模式 每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动。 —— Christopher Alexander 设计模式的核心思想 设计模式出现的背景，是软件设计的复杂度日益飙升。软件设计越来越复杂的“罪魁祸首”，就是变化。比如我们写一个应用，这个应用以后完全不会发生迭代和优化，那么我们可以随便写，反正实现功能就行了，根本不用去考虑它的维护和升级。 但在实际开发中，不发生变化的代码可以说是不存在的。我们能做的只有将这个变化造成的影响最小化 —— 将变与不变分离，确保变化的部分灵活、不变的部分稳定。 这个过程，就叫“封装变化”；这样的代码，就是我们所谓的“健壮”的代码，它可以经得起变化的考验。而设计模式出现的意义，就是帮我们写出这样的代码。 设计模式的分类设计模式的分类其实是非常多的，在《设计模式：可复用面向对象软件的基础》这本书中根据“创建型”、“行为型”和“结构型”将设计模式分为23种。 设计模式会有很多，但是实际项目开发中并没有那么多，本片我们先简单来看一下项目中经常用到的单例和组合模式。 📚单例模式概念 保证一个类仅有一个实例，并提供一个访问它的全局访问点，这样的模式就叫做单例模式。这种模式其实挺常见，其中应用最广泛的要数 Redux 和 Vuex。无论是 Redux 和 Vuex，它们都实现了一个全局的 Store 用于存储应用的所有状态。这个 Store 的实现，正是单例模式的典型应用。 简单实现12345678910111213141516171819202122232425// 准备一个构造函数// 将来要 new 的function Person() {}// 准备一个单例模式函数// 这个单例模式函数要把 Person 做成一个单例模式// 将来再想要 new Person 的时候只要执行这个 singleton 函数就可以了function singleton () { let instance if (!instance) { // 如果 instance 没有内容 // 来到这里，证明 instance 没有内容 // 给他赋值为 new Person instance = new Person() } // 返回的永远都是第一次 new Person 的实例 // 也就是永远都是一个实例 return instance}const p1 = singleton()const p2 = singleton()console.log(p1 === p2) // true单例模式的核心代码很简单,其实就是判断一下，他曾经有没有 new 出来过对象,如果有，就还继续使用之前的那个对象，如果没有，那么就给你 new 一个. 📚组合模式概念 将对象以树形结构组织起来，以达成“部分－整体”的层次结构，使得客户端对单个对象和组合对象的使用具有一致性123456789101112131415161718192021class GetHome { init () { console.log('到家了') }}class OpenComputer { init () { console.log('打开电脑') }}class LookTv { init () { console.log('看夏目友人帐') }} 上面几个构造函数的创造的实例化对象的 启动方式 都一致，那么我们就可以把这几个函数以组合模式的情况书写，然后统一启动 1234567891011121314151617class Compose { constructor () { this.compose = [] } // 添加任务的方法 add (task) { this.compose.push(task) } // 一个执行任务的方法 execute () { this.compose.forEach(item =&gt; { item.init() }) }} 我们就用我们的组合模式构造函数来吧前面的几个功能组合起来 12345678910const c = new Compose()// 把所有要完成的任务都放在队列里面c.add(new GetHome())c.add(new OpenComputer)c.add(new PlayGame)// 直接器动任务队列c.execute()// 就会按照顺序执行三个对象中的 init 函数","link":"/2021/10/02/javascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"title":"next.js从入门到实战","text":"官网上Next.js简介：Next.js 是一个轻量级的React服务端渲染框架 首先整理了一下各种渲染方式的优缺点 一） 服务端渲染/客户端渲染/同构渲染的优缺点I ）为什么要使用服务端来渲染，有什么优点？至于为什么要服务端渲染，我相信大家都有所闻，而且每个人都能说出几点来。 首屏等待 在 SPA 模式下，所有的数据请求和 Dom 渲染都在浏览器端完成，所以当我们第一次访问页面的时候很可能会存在“白屏”等待，而服务端渲染所有数据请求和 html内容已在服务端处理完成，浏览器收到的是完整的 html 内容，可以更快的看到渲染内容，在服务端完成数据请求肯定是要比在浏览器端效率要高的多。 SEO的优化 有些网站的流量来源主要还是靠搜索引擎，所以网站的 SEO 还是很重要的，而 SPA 模式对搜索引擎不够友好，要想彻底解决这个问题只能采用服务端直出。 II）服务端渲染的优缺点1）服务端渲染的优点 前端渲染时间。因为后端拼接htm，浏览器只需直接渲染出来。 有利于SEO。服务端有完整的html页面，所以爬虫更容易获得信息，更利于seo 无需占用客户端资源，模板解析由后端完成，客户端只需解析标准的html页面，这样对客户端的资源占用更少，尤其是移动端，可以更加省电。 后端生成静态化文件。即生成缓存片段，这样就可以减少数据库查询浪费的时间了，且对于数据变化不大的页面非常高效 等。2）服务端渲染缺点 不利于前后端分离，开发效率很低。 占用服务器端资源。请求过多对服务器压力很大。 即使局部页面发生变化也需要重新请求整个页面，费流量等。 III ）客户端渲染的优缺点1）客户端渲染的优点 节省后端资源 多端渲染 前后端分离，大大提升开发效率 局部刷新等2）客户端渲染的缺点 首屏性能差 白屏时间过长 无法（很艰难）进行seo优化等 IV）Next/nust.js是完全属于服务端渲染吗？ 对比一下就会发现一个很有意思的事，服务端渲染的优点就是客户端渲染的缺点，服务端渲染的缺点同时也是客户端渲染的优点，反之亦然。看之前不是很理解，由于服务端渲染的各种缺点我们已经告别了服务端渲染的时代，进入了前后端分离的客户端渲染时代，又为什么重新回到了服务端渲染？ 了解发现，其实把Next/nust.js成为SSR不是很准确，应该是Isomorphic render（同构渲染），那么什么是同构渲染？ V）什么是同构渲染 前后端同构是指在前后端维护同一份代码。它是在SPA的基础上，利用服务端渲染（SSR）直出首屏，解除单页面应用（SPA）在首屏渲染上面临的窘境。明确地说，同构是将传统的纯服务端直出的首屏优势和SPA的站内体验优势结合起来，以取得最优解的解决方案。 同构渲染就是实现了ssr和spa两种技术的结合，同时可以最大限度的重用代码（同构），减少开发维护成本，采用 react 或者 vue 等前端框架相结合 node (ssr) 来实现。 二）Next初探I ）next.js 的渲染流程 II）next.js的优点 完善的React项目架构，搭建轻松。 自带数据同步策略，解决服务端渲染最大难点. 配置灵活 丰富的插件帮开发人员增加各种功能。 III）快速创建Next.js项目1 ）Setup要创建 Next.js 应用，请打开你的终端窗口，cd 进入您要在其中创建应用程序的目录，然后运行以下命令：1npm init next-app nextjs-blog --example &quot;https://github.com/vercel/next-learn-starter/tree/master/learn-starter&quot; 其背后的工作是通过调用 create-next-app 工具完成的，该工具为你创建了一个 Next.js 应用程序。 到这里项目就创建成功了 2）运行开发服务12cd nextjs-blogyarn dev 运行成功ing….. III）页面间导航在pages下新建一个test.js的页面，页面可以随意输入一些内容，这里按照hooks的方式编写你的函数型组件123456function Text (){ return( &lt;h3&gt;测试&lt;/h3&gt; )}export default Text;然后在网页的地址栏中http://localhost:3000/test 然后我们发现，页面上已经显示test.js的页面内容了，这是因为Next框架就自动作好了路由，这个也算是Next的一个重要优点。发现Next框架真的减轻了我们大量的工作。 IV）引入个小组件可以再根目录下创建一个components的文件夹，来存放我们的公用组件。先来创建一个button的组件，首先在components文件夹下创建button.js文件，然后编辑页面，先按最简单的写法来创建一个按钮 1export default ({children})=&gt;&lt;button&gt;{children}&lt;/button&gt; 小组件创建完成后，在pages下的index.js页面引入该文件 1import Button from '../components/button' 然后在页面上引入该组件1&lt;Button&gt;按钮&lt;/Button&gt;然后发现已经在页面上渲染了，好想和react并没有什么区别。也就是说Next框架并没有给我们带来太多的学习成本，但是为我们减轻了很多配置工作。 V）路由-基本跳转1）标签式导航&lt; Link &gt;首先引入标签式导航&lt; Link &gt; 1import Link from 'next/link' 引入之后尝试跳转刚才的test.js 页面 1&lt;Link href=&quot;/test&quot;&gt;Test&lt;/Link&gt; 跳转成功，但是要记录一个&lt; Link &gt;的小坑，发现&lt; Link &gt;下如果不写内容，或者写多个标签都会报错1&lt;Link href=&quot;/test&quot;&gt;&lt;/Link&gt; 1234&lt;Link href=&quot;/test&quot;&gt; &lt;span&gt;test`1&lt;/span&gt; &lt;span&gt;test`2&lt;/span&gt; &lt;/Link&gt; 所以Link标签下有且只能有一个子元素 2）Router模块进行编程式导航首先也是引入Router模块1import Router from 'next/router'然后尝试跳转1&lt;button onClick={()=&gt;{Router.push('/test')}}&gt;去test页面&lt;/button&gt;两种方法都可以跳转，可以根据业务需求具体选择 Ⅵ）路由-query传参首先是标签式&lt; Link &gt;传参123&lt;Link href=&quot;/test?id=123&quot;&gt; &lt;span&gt;test&lt;/span&gt;&lt;/Link&gt;或者123&lt;Link href={{pathname:'/test',query:{id:'123'}}}&gt; &lt;span&gt;test&lt;/span&gt;&lt;/Link&gt;然后变成是导航传参1&lt;button onClick={()=&gt;{Router.push('/test?id=123')}}&gt;去test页面&lt;/button&gt;或者1&lt;button onClick={()=&gt;{Router.push({pathname:'/test',query:{id:'123'}})}}&gt;去test页面&lt;/button&gt;好像没啥区别……. Ⅶ）路由-接收参数接收参数 需要用到withRouter 它是Next.js框架的高阶组件，用来处理路由的。传递门之高阶组件接下来重新编写test.js页面首先引入withRouter1import { withRouter } from 'next/router'然后在页面中使用123456789101112131415import { withRouter } from 'next/router'import Link from 'next/link'const Test = ({router}) =&gt;{ return( &lt;div&gt; &lt;p&gt;{router.query.id}&lt;/p&gt; &lt;Link href={{pathname:'/'}}&gt; &lt;span&gt;回首页&lt;/span&gt; &lt;/Link&gt; &lt;/div&gt; )}export default withRouter(Test) 这里可以看到接收到的id值123 Ⅷ）路由-钩子事件next.js的路由钩子一共有六个 当路由发生变化时会触发钩子事件，这里用到Router的on方法来监听，钩子事件第二个参数为路由参数，这里来编辑index.js页面。 可以通过Router监听路由器内部发生的不同事件1234// 监听Router.events.on('routeChangeStart', handleRouteChange)// 关闭Router.events.off('routeChangeStart', handleRouteChange) 1）routeChangeStart 路由开始发生变化时触发123 Router.events.on('routeChangeStart',(...args)=&gt;{ console.log('路由开始变化',...args)}) 2）routeChangeComplete 路由结束变化时触发123Router.events.on('routeChangeComplete',(...args)=&gt;{ console.log('路由结束变化',...args)}) 3） beforeHistoryChange在改变浏览器 history之前触发123Router.events.on('beforeHistoryChange,(...args)=&gt;{ console.log('浏览器 history改变之前',...args)}) 4） routeChangeError跳转发生错误触发123Router.events.on('routeChangeError,(...args)=&gt;{ console.log('跳转发生错误',...args)}) 5） hashChangeStarthash模式路由改变刚开始123Router.events.on('hashChangeStart,(...args)=&gt;{ console.log('hash模式路由改变刚开始',...args)}) 6） hashChangeCompletehash模式路由改变结束123Router.events.on('hashChangeComplete,(...args)=&gt;{ console.log('hash模式路由改变结束',...args)}) Ⅸ）getInitialProps 获取远程数据我们通常需要从远程数据源获取数据.Next.js 自己有标准 API 来获取页面数据.我们通常使用异步函数 getInitialProps 来完成此操作 .这样,我们可以通过远程数据源获取数据到页面上,并将其作为 props 传递给我们的页面.getInitialProps 在服务器和客户端上均可使用. 可以使用fetch或者axios，看个人习惯 1） fetch 首先安装fetch 1npm install --save isomorphic-unfetch 然后再页面上使用 123456 Home.getInitialProps = async function (){ const res = await fetch('https://api.tvmaze.com/search/shows?q=batman'); const data = await res.json(); console.log(data.map(entry =&gt; entry.show)) } 2） axios也可以使用axios首先安装axios1npm install --save axios然后在页面中使用1234567891011Home.getInitialProps = async ()=&gt;{const promise =new Promise((resolve)=&gt;{ axios('https://api.tvmaze.com/search/shows?q=batman').then( (res)=&gt;{ console.log('远程数据结果：',res.data) resolve({shows:res.data.map(entry =&gt; entry.show)}) } )})return await promise}这里拿到数据后在页面上渲染。接收props参数123456789&lt;ul&gt; {props.shows.map(show =&gt; ( &lt;li key={show.id}&gt; &lt;Link href=&quot;/detail/[id]&quot;&gt; &lt;a&gt;{show.name}&lt;/a&gt; &lt;/Link&gt; &lt;/li&gt; ))} &lt;/ul&gt; X）编写组件的样式1）框架自带的一种语法style jsx ，来尝试一下让字体变成蓝色 直接写在return 中，可以在页面最外层添加一个&lt;&gt;&lt;/&gt;12345678910&lt;&gt; &lt;div className=&quot;container&quot;&gt; &lt;Test&gt;按钮&lt;/Test&gt; &lt;/div&gt; &lt;style jsx&gt; {` button { color:blue;} `} &lt;/style&gt; &lt;/&gt; 然后运行一下即可看到 button的字体变成了蓝色。 2） 然后我们来动态改变一下组件的样式首先引入react hooks中的useState1import React, {useState} from 'react' 然后来定义color 以及setColor1const [color,setColor] = useState('red') 加入点击事件123const changeColor=()=&gt;{ setColor(color === 'blue' ?'red':'blue')}和按钮button1&lt;button onClick={changeColor}&gt;改变字体颜色&lt;/button&gt;最后在style中写入变量color1button { color:${color};}运行页面，点击按钮发现button的字体颜色可以动态切换，很是方便。 f12打开控制台还会发现，加入了Style jsx代码后，Next.js会自动加入一个随机类名，这样就防止了CSS的全局污染。 3）尝试引入less 和 css当页面比较复杂的时候，我们以jsx方式来编写样式，难免的会降低我们的开发效率，所以这里尝试一下引入less首先安装less 和 css12npm install --save @zeit/next-less lessnpm install --save @zeit/next-css然后第二步在根目录下创建next.config.js配置文件这里我们同时引入css和sass哦 123456789101112const withCss = require('@zeit/next-css')const withLess = require('@zeit/next-less')if(typeof require !== 'undefined'){ require.extensions['.css']=file=&gt;{}}if (typeof require !== &quot;undefined&quot;) { require.extensions[&quot;.withLess&quot;] = file =&gt; {}; }module.exports = withLess(withCss({})) 小可爱这里记住这里要重启服务哦 Ⅺ）引入antd首先安装antd依赖 1npm install antd --save 然后来安装和配置babel-plugin-import 插件1npm install babel-plugin-import --save-dev 安装完成后，在项目根目录建立.babelrc文件，然后写入如下配置文件。 123456789101112{ &quot;presets&quot;:[&quot;next/babel&quot;], //Next.js的总配置文件，相当于继承了它本身的所有配置 &quot;plugins&quot;:[ //增加新的插件，这个插件就是让antd可以按需引入，包括CSS [ &quot;import&quot;, { &quot;libraryName&quot;:&quot;antd&quot;, &quot;style&quot;:&quot;css&quot; } ] ]} 这样配置好了以后，webpack就不会默认把整个Ant Design的包都进行打包到生产环境了，而是我们使用那个组件就打包那个组件,同样CSS也是按需打包的。 这里记住这里要重启服务哦配置完成后我们在页面中尝试引入Button组件 1import {Button} from 'antd' 然后使用1&lt;Button onClick={changeColor}&gt;改变字体颜色&lt;/Button&gt;嗯哼，这里就生效了 Ⅻ）部署 Next.js 应用先安装 now,一个静态资源托管服务器1npm i -g now 打包1yarn build结果发现报错了，其实是我们在加入Ant Design的样式时产生的，这个已经在Ant Design的Github上被提出了，但目前还没有被修改，你可以改完全局引入CSS解决问题。 解决办法 在page目录下，新建一个_app.js文件，然后写入下面的代码。 12345import App from 'next/app'import 'antd/dist/antd.css'export default App 再次运行yarn build发现可以打包成功，最后运行1yarn start可以在页面上运行","link":"/2021/01/02/next-js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/"},{"title":"前端性能优化——浏览器缓存机制","text":"📚(一)浏览器缓存概览关于前端性能优化，一直是一个老生常谈的话题，在性能优化的诸多方法中，缓存可以说是性能优化中简单高效的一种优化方式了。 🙄那么浏览器缓存可以在哪方面给我们带来实质性的性能优化呢？ 📣我们知道从我们从输入 URL 到页面加载完成，大致可以分为5个步骤 DNS 域名解析 建立TCP 连接 HTTP 请求抛出 服务端处理请求，HTTP 响应返回 浏览器拿到响应数据，解析响应内容，把解析的结果展示给用户 浏览器缓存可以帮助我们在第3和第5步骤中优化性能。利用浏览器存储机制，将一部分数据保存在客户端，从而减少对服务器的请求降低服务器的压力，提升效率。 📢📢一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷👍。 📚(二)浏览器缓存的具体使用对于我这种菜鸡而言，对于浏览器缓存机制的理解就是HTTP 缓存🥴，但查阅资料发现浏览器缓存可以分为4种，而且它们按照获取资源时请求的优先级依次排列如下😳： Memory Cache Service Worker Cache HTTP Cache Push Cache 我们依次来看一下吧，乌拉~ 1、🍜Memory CacheMemory Cache 也就是内存中的缓存，主要包含的是当前中页面中已经抓取到的资源,例如页面上已经下载的样式、脚本、图片等，从效率上来说，它是响应速度最快的一种缓存。 那我们是否可以无限制的使用Memory Cache呢？答案是否定的，因为我们电脑的内存是很有限的。一般情况下Base64 格式的图片或者小一点的js文件会放在Memory Cache中，大一点的文件我们一般放在磁盘中，比如这张图： 图中这些文件都是使用缓存中的数据 2、 🍣Service Worker CacheService Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。这是网上对它的介绍，后发现使用 Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。它可以帮我们实现离线缓存、消息推送和网络代理等功能。 Service Worker 的生命周期包括 install、active、working 三个阶段。一旦 Service Worker 被 install，它将始终存在，只会在 active 与 working 之间切换，除非我们主动终止它。这是它可以用来实现离线存储的重要先决条件。 📢📢发现一个很不错的Service Worker实践文章，有兴趣的小伙伴可以看一下借助Service Worker和cacheStorage缓存及离线开发👍 3、🍤HTTP CacheHTTP 缓存是我们日常开发中最为熟悉的一种缓存机制，也是最主要、最具有代表性的缓存策略。HTTP缓存有多种规则，根据是否需要重新向服务器发起请求来分类，它可以分为强缓存和协商缓存。 强制缓存如果生效，不需要再和服务器发生交互，而对比缓存不管是否生效，都需要与服务端发生交互。两类缓存规则可以同时存在，强制缓存优先级高于对比缓存，也就是说，当执行强制缓存的规则时，如果缓存生效，直接使用缓存，不再执行对比缓存规则。 📙（1）强缓存可以理解为无须验证的缓存策略，强制缓存。对强缓存来说，响应头中有两个字段 Expires/Cache-Control 来表明规则。ExpiresExpires用来设置过期时间，超过这个时间点就表示资源过期。但是会有一个问题，由于这个时间使用时间戳表示，客户端和服务端可能会存在差别，这可能造成缓存生命周期出错。在HTTP/1.1中加入了Cache-Control，并且两个同时存在时也是 Cache-Control 的优先级更高。Cache-ControlCache-Control 有几个值： 🎈1. private: 客户端可以缓存，表明响应只能被单个用户（可能是操作系统用户、浏览器用户）缓存，是非共享的，不能被代理服务器缓存。 🎈2. public: 客户端和代理服务器都可缓存 🎈3. max-age=xxx: 缓存的内容将在 xxx 秒后失效 🎈4. no-cache: 需要使用对比缓存来验证缓存数据 🎈5. no-store: 禁止缓存，每次请求都要向服务器重新获取数据 🎈6. s-maxage 但仅适用于共享缓存 📙（2） 协商缓存📌浏览器与服务器合作之下的缓存策略 缓存的资源到期了，并不意味着资源内容发生了改变，如果和服务器上的资源没有差异，实际上没有必要再次请求。客户端和服务器端通过某种验证机制验证当前请求资源是否可以使用缓存。 如果服务端提示缓存资源未改动（Not Modified），资源会被重定向到浏览器缓存，这种情况下网络请求对应的状态码是 304。反之返回 200 就相当于重新请求了一遍资源并替换旧资源。 我们具体来看一下协商缓存时的请求头Last-modified/If-Modified-Since 和 Etag/If-None-Match； I、🎈Last-modified/If-Modified-SinceLast-Modified 是一个时间戳，它表示服务器端资源的最后修改时间。 如果我们启用了协商缓存，它会在首次请求时随着 Response Headers 返回。第一次请求之后，浏览器记录这个时间，再次请求时，请求头部带上 If-Modified-Since 即为之前记录下的时间。服务器端收到带 If-Modified-Since 的请求后会去和资源的最后修改时间对比。若修改过就返回最新资源，状态码 200，若没有修改过则返回 304; 📣📣但其实使用Last-modified会有弊端存在，由于这个时间是浏览器自己记录的。🍒由于Last-modified 只能精确到秒，如果我们修改文件的速度过快（100ms)那么，浏览器旧纪录不到这个时间，导致文件没有实时更新。🍒或者我们编辑了文件，但是没有修改内容再次提交时更新了Last-Modified ，这就导致服务器会有一次完整的响应请求 那么怎么解决这个问题呢？Etag 作为 Last-Modified 的补充出现了 II、🎈EtagEtag 是由服务器为每个资源生成的唯一的hash字符串，这个标识字符串是基于文件内容编码的，只要文件内容不同，它们对应的 Etag 就是不同的，反之亦然。因此 Etag 能够精准地感知文件的变化。 📣📣📣注意：实际使用 ETag/Last-modified 要注意保持一致性，做负载均衡和反向代理的话可能会出现不一致的情况。计算 ETag 也是需要占用资源的，如果修改不是过于频繁，看自己的需求用 Cache-Control 是否可以满足。 4、🥣Push Cache“推送缓存”是针对HTTP/2标准下的推送资源设定的。推送缓存是session级别的，当 session 终止时，缓存也随之释放。在以上三种缓存都没有的情况下，它才会被使用。Push Cache是HTTP2新出的特性，他也将是未来未来的趋势，push cache的特性这里简单介绍： Push Cache 是缓存的最后一道防线。浏览器只有在 Memory Cache、HTTP Cache 和 Service Worker Cache 均未命中的情况下才会去询问 Push Cache。 Push Cache 是一种存在于会话阶段的缓存，当 session 终止时，缓存也随之释放。不同的页面只要共享了同一个 HTTP2 连接，那么它们就可以共享同一个 Push Cache。这里发个😶😶传送门 参考链接https://www.cnblogs.com/vajoy/p/5341664.htmlhttps://www.cnblogs.com/chenqf/p/6386163.html","link":"/2021/09/02/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"},{"title":"HTTP报文是什么","text":"📢📢如果说http是因特网的信使，那么http报文就是他用来送信的包裹了 (1)📚什么是报文在度娘的介绍中 📣报文(message)是网络中交换与传输的数据单元，即站点一次性要发送的数据块。报文包含了将要发送的完整的数据信息，其长短很不一致，长度不限且可变。 也就是说http报文是在http应用程序之间发送的数据块，，它包裹着我们进行请求数据交换的信息✔。 (2)📚报文的组成部分📃2.1 报文基本结构http报文是简单的格式化数据块，它有三个部分组成。对报文进行描述的起始行（start line）、包含属性的首部（header）、以及可选的包含数据的主体（body）部分，主体部分可以包含文本或二进制数据也可以为空。 举个栗子🌰，如图所示，这里列举了一个服务端响应的报文 📊在这张图中，首部给出了一些与主体信息有关的信息。Content-Type行说明了主体是纯文本文档text/plain，Content-Length行说明了当前主体的大小16个字节。 📃2.2 报文的分类所有的HTTP报文都可以分为两类，请求报文（request message）和响应报文（response message）。请求报文由客户端向服务器发出，响应报文由服务器响应客户端返回响应结果。虽然有区别，但是两种报文的结构是相同的，都是由起始行、首部、主体三部分组成。 📒请求报文的格式123&lt;method&gt; &lt;request-URL&gt; &lt;versin&gt;&lt;header&gt;&lt;entity-body&gt;📒响应报文的格式（只有起始行是不同的）123&lt;versin&gt; &lt;status&gt; &lt;reason-phrase&gt;&lt;header&gt;&lt;entity-body&gt; 请求方法（method）\\ 客户端对服务端发起请求的方式，比如get、post、put等 请求URL（request-URL）\\ 请求服务器资源的url路径 版本（versin）\\ 报文所使用的http的版本 状态码（status-code)\\ 这三位数字描述了请求过程中所发生的情况。 原因短语（reason-phrase）\\ 数字状态码的可读版本，比如上面例子中的OK 首部（header）\\ 可以有零个或者多个首部，每个首部都包含一个名字。 实体的主体部分（entity-body）\\ 包含一个由任意数据组成的数据块 (3)📚请求报文支持的各种方法请求的起始行以方法作为开始，方法使用来告知服务器要做些什么。但值得注意的是并不是每个服务器都实现了所有方法，这些限制通常都是在服务器的配置中进行设置的，因此会随着站点和服务器的不同而有所不同。 此图来自菜鸟驿站 📃3.1 GET请求主要用于向指定的URL（URI）请求资源（资源文件或是数据均可）， 可以带参数也可以不带参数， 带参数时，参数是明文传递，你可以在浏览器的地址栏中看到参数名及参数值，get安全性不高，所以常用于安全性要求低的场合， 比如登录后请求数据。 📃3.2 HEAD请求HEAD 请求和 GET请求很类似，都是从服务器获取资源，但是服务器在响应中并不会返回主体，只返回首部。服务器开发者必须确保返回的首部和GET请求返回的首部是完全相同的。 HEAD请求常常被忽略，但是能提供很多有用的信息，特别是在有限的速度和带宽下，使用HEAD请求，可以： 1、只请求资源的首部； 2、检查超链接的有效性、以及最近是否更新； 3、通过查看首部，检查网页是否被修改； 4、多用于自动搜索机器人获取网页的标志信息，获取rss种子信息，或者传递安全认证信息等 📃3.3 POST请求在Http请求里post是其中比较常用的提交数据的请求方式, POST方法起初是用来向服务器输入数据的。实际上，我们通常会用它来提交form表单。 📃3.4 PUT请求PUT请求是向服务器端发送数据的，从而改变信息，该请求就像数据库的update操作一样，用来修改数据的内容，但是不会增加数据的种类等，也就是说无论进行多少次PUT操作，其结果并没有不同。 📃3.5 DELETE请求DELETE请求顾名思义，就是用来删除某一个资源的，该请求就像数据库的delete操作。 📃3.6 CONNECT请求connect在网页开发中不会使用到， connect的作用就是将服务器作为代理，让服务器代替用户去访问其他网页（说白了，就是翻墙），之后将数据返回给用户。 📃3.7 OPTIONS请求OPTIONS请求web服务器告知其支持的各种功能。可以询问服务器支持哪些方法，或者对某些特殊资源支持哪些方法，这就为客户端提供了一种手段，使其不用访问那些资源就可以知道访问这种资源最优的方式，仅作查询使用。简而言之，OPTIONS请求方法的主要用途有两个： 获取服务器支持的HTTP请求方法； 用来检查服务器的性能。 🙄其实在实际开发中我们可能经常有见到OPTIONS请求，因为在某些情况下，普通的get或者post请求回首先自动发起一次options请求，当options请求成功返回后，真正的ajax请求才会再次发起。那么是哪些情况会发起OPTIONS请求呢? 跨域请求，非跨域请求不会出现options请求 自定义请求头 请求头中的content-type是application/x-www-form-urlencoded，multipart/form-data，text/plain之外的格式📃3.8 TRACE请求 TRACE方法允许客户端在最终将请求发送给服务器时看一看它变成什么样子了，因为当客户端发送一个请求时，这个请求可能要穿过防火墙、代理、网关或者其他的应用程序，每个中间节点都有可能修改原始的http请求。 TRACE方法主要用来诊断，当然他也有缺点，TRACE方法是HTTP（超文本传输）协议定义的一种协议调试方法，该方法使得服务器原样返回任何客户端请求的内容（可能会附加路由中间的代理服务器的信息），由于该方法原样返回客户端提交的任意数据，因此，可用来进行跨站脚本（XSS）攻击，这种攻击方式又称为跨站跟踪攻击（XST）。 📃3.9 PATCH请求HTTP中为了提高交互操作性与防止错误，确实需要一种新的修改方法，而PUT方法已经被定义为用一个请求体去修改一个完整的资源。并且不能重复做部分更改，否则代理和缓存、甚至服务器或者客户端都会得到有问题的操作结果。 至此，PATCH方法有了被完全定义的必要。 PATCH在请求中定义了一个描述修改的实体集合，如果被请求修改的资源不存在，服务器可能会创建一个新的资源。","link":"/2022/01/22/HTTP%E6%8A%A5%E6%96%87%E6%98%AF%E4%BB%80%E4%B9%88/"},{"title":"JS模块化","text":"📚一. 什么是模块化 📣模块化是指解决一个复杂问题时自顶向下逐层把系统划分成若干模块的过程，有多种属性，分别反映其内部特性。 ——维基百科 这是维基百科对模块化的介绍，简单理解就是： 将代码拆分成独立的块，然后把这些块连接起来可以通过模块模式来实现。 块的内部数据与实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信 📚二. js模块化发展历程在JS设计之初，本身就是为了满足简单的页面设计： 页面动画 + 表单提交，并无模块化 or 命名空间的概念。但随着CPU、浏览器性能得到了极大的提升，页面的复杂程度也显著提高，JS的模块化需求也日益增加。 js模块化的发展一共经历了以下几个阶段： ✏️2.1 幼年期：无模块化在发展之初，没有模块化的概念，但随着业务逻辑的复杂度增加，我们也遇到了一些需求，比如： 开始需要在页面中加载不同的JS：动画、组件、格式化 多种js文件会被分在不同的文件中 不同的文件又被同一个模板所引用 🎈作用：将不同的业务逻辑（js文件），引入到同一个页面上去这种文件分离拆分是最基础的模块化（第一步） ✒️2.2 成长期：模块化前夜 - IIFE(语法侧的优化) IIFE: 立即调用函数表达式 📒编码: 将数据和行为封装到一个函数内部, 通过给window添加属性来向外暴露接口🎈作用: 数据是私有的, 外部只能通过暴露的方法操作为按照模块模式提供必要的封装，ES6之前的模块会使用函数作用域和IIFE将模块定义封装在匿名闭包中。 例子：12345let count = 0;const increase = () =&gt; ++count;const reset = () =&gt; { count = 0;} 利用函数的块级作用域 - 隔离区 1234(() =&gt; { let count = 0; // …… })(); 🐛问题： 独立模块本身的额外依赖，如何优化？方案： 依赖其他模块的传参型 123456789const iifeModule = ((dependencyModule1, dependencyModule2) =&gt; { let count = 0; const increase = () =&gt; ++count; const reset = () =&gt; { count = 0; } console.log(count); increase(); })(dependencyModule1, dependencyModule2); 将依赖作为参数，传入到独立模块。 2.3 🪡成熟期：CJS - Commonjs2.3.1 🌭说明：CommonJS规范概述了同步声明依赖的模块定义。CommonJS模块语法不能直接在浏览器中直接运行。 2.3.2 基本语法 暴露模块： 12module.exports = valueexports.xxx = value 引入模块: 1require(xxx) CommonJS 模块定义需要使用require（）指定依赖 ❗无论一个模块在require（）中被引用多少次，模块永远是单例。模块第一次加载后会被缓存，后续加载会取得缓存的模块。 每个模块内部，module对象代表当前模块，它的exports属性（即module.exports）是对外的接口(暴露出去)。加载某个模块，其实是加载该模块的module.exports属性。 2.3.3 加载机制 CommonJS 用于 node 端，是同步加载的，也就是说，只有加载完成，才能执行后面的操作。 输入的是被输出的值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。 2.3.4 优点CommonJs率先在服务端实现了，从框架层面解决了依赖、全局变量污染的问题 2.3.5 缺点针对了服务端的解决方案。异步拉取依赖处理不是很完美 2.3.6 面试问题🐛exports 与 module.exports 为了方便，Node为每个模块提供一个exports变量，指向module.exports。这等同在每个模块头部，有一行这样的命令。1var exports = module.exports; exports其实是module.exports的引用 ，可以直接在exports对象上添加相关的方法。 2.4 💁‍ AMD规范CommonJS以服务端为目标环境，能够一次性把所有模块都加载到内存中，而异步模块定义（AMD）的模块定义系统则以浏览器为目标执行环境，只需要考虑网络延迟的问题。 经典实现框架：require.js 2.4.1 🌭说明：AMD规范是非同步加载模块，允许指定回调函数。 2.4.2 基本语法1. 定义暴露模块:1define([module-name?], [array-of-dependencies?], [module-factory-or-object]); 其中： module-name: 模块标识，可以省略。 array-of-dependencies: 所依赖的模块，可以省略。 module-factory-or-object: 模块的实现，或者一个JavaScript对象。 2. 引入使用模块:1234require(['module1', 'module2'], function(m1, m2){ //使用m1/m2}) 2.4.3 模块的加载机制AMD 依赖于 requirejs,是异步加载的，是提前加载，立即加载 2.4.4 优点适合在浏览器中加载异步模块的方案 2.4.5 缺点引入成本 2.5 💁‍ CMD规范CMD是SeaJS 在推广过程中对模块定义的规范化产出, CMD规范专门用于浏览器端，模块的加载是异步的，模块使用时才会加载执行。CMD规范整合了CommonJS和AMD规范的特点。 2.5.1 🥯基本语法定义暴露模块:123456//定义没有依赖的模块define(function(require, exports, module){ exports.xxx = value module.exports = value}) 1234567891011//定义有依赖的模块define(function(require, exports, dom){ //引入依赖模块(同步) var dom2 = require('./dom2') //引入依赖模块(异步) require.async('./dom3', function (m3) { }) //暴露模块 exports.xxx = value}) 引入使用模块:1234567define(function (require) { var m1 = require('./module1') var m4 = require('./module4') m1.show() m4.show()}) 2.5.2 🥨模块的加载机制CMD 依赖于 seajs ,是异步加载，延后加载，就近加载，用时加载 2.5.3 🥐优点按需加载，依赖就近 2.5.4 🥗缺点依赖打包，加载逻辑存在于每个模块中，扩大了模块体积，同时功能上依赖编译 2.5.5 🐛问题AMD 和 CMD 的区别有哪些? 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible. CMD 推崇依赖就近，AMD 推崇依赖前置。 AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一. 2.6 ✒️ES6模块化2.6.1 🍡基本语法1. 导出 export命令1export const obj = {name: 'E1e'}； 默认导出 export default命令123export default {name: 'E1e'}; 2. 引入12// 引入普通导出import { obj } from './test.js'; 12// 引入默认导出 import obj from './test.js'; 2.6.2 🍭模块的加载机制 模块支持异步加载 同一个模块如果加载多次，将只执行一次。 既可以通过浏览器原生加载，也可以与第三方加载器和构建工具一起加载 2.6.3 🍬优点通过一种最终统一各端的形态，整合了js模块化的通用方案 2.6.4 🍫局限性本质上还是运行时的依赖分析","link":"/2022/03/05/JS%E6%A8%A1%E5%9D%97%E5%8C%96/"},{"title":"深入理解URL","text":"📢📢📢url就是因特资源网的标准化名称。URL指向一条电子信息片段，告诉你它们位于何处，以及如何与之进行交互 ——《http权威指南》 📚 1、URL和URI说起URL,我们不得不提起URI。URI是一类更通用的资源标识符，URL实际上是它的一个子集。URI包含URL和URN，URL是通过资源位置来标识资源的，而URN是通过名字来识别资源的。那么这三者的关系，就类似我我们身份证上的身份证号、家庭住址、姓名。 虽然规范的做法是URI作为统一资源标识符，但是在http中只处理了URL，那么我们就来看看我们熟悉的URL 📚 2、url的组成每天上网的我们，几乎每天都会打开几十个网页，这些网页都会有一个唯一的URL地址。我们可以通过这个地址来找到网页，那么这个地址中都包含哪些信息呢？它是如何与浏览器、客户端、服务器以及服务器文件系统中位置进行关联的🤸‍♂️ \\举个例子🌰 \\比如 我们要看阮大大的文章🥴https://www.bookstack.cn/read/html-tutorial/docs-url.md 那么这个URL就分为以下三个部分。 URL的第一部分（https）是URL的方案（scheme）。方案可以告知Web客户端怎样访问资源。在这个例子中，URL说明要使用https协议。 URL的第二个部分（www.bookstack.cn） 指的是服务器的位置。这部分告知Web客户端资源位于何处。 URL的第三个部分（/read/html-tutorial/docs-url.md）是资源路径。历经说明了请求的是服务器上的哪个特定的本地资源。 其实URL最主要的组成也就是这三部分方案（scheme）、主机（host）、路径（path）。但其实URL是由于9部分组成的，我们一起来看下面这个表格 组件 描述 scheme 方法描述了请求资源时用了什么协议，用“:”与url其它部分隔开； password 密码描述了用户名后面可能跟的密码，用“:”跟用户名隔开； host 主机描述了网站主机名或ip地址，如果前面有用户名和密码，用@分开； post 服务器当前正在监听的端口，http默认为80，https默认为443; path 路劲描述了资源在服务器上的位置，用‘/’跟前面部分隔开； params 参数描述了请求需要附加的参数，用“;”与其他部分隔开； query 查询是用来激活服务器程序去执行某些操作，比如查询数据库等，用“?”与其余部分隔开； frag 片段只在客户端使用，不发送到服务器端 那么接下来我们来看几个我们实际开发常用的几个组件 📕 2.1 方案方案实际上是规定如何访问指定资源的主要标识，它会负责解析URL的应用程序应该是用什么协议，我们比较常见的就是HTTP、HTTPS。一共有如下几种方案 http https mailto ftp rtsp、rtspu 📗 2.2 主机和端口我们想要从因特网上获取资源，就必须要知道是哪台机器，以及在那台机器的什么地方可以找到能对目标资源进行访问的服务器。URL的主机和端口就提供了这个信息。\\我们可以通过主机名或者IP地址来访问， 其实在前端使用框架开发的话，由于本地启动的服务，那其实我们访问的就是本机的IP地址。 📘 2.3 路径URL的路径组件说明了资源位于服务器的什么地方。路径通常很像一个分级的文件系统路径。🌰比如： https://www.bookstack.cn/read/html-tutorial/docs-url.md🤸‍这个URL中的路径为/html-tutorial/docs-url.md，很像UNIX文件系统中的文件系统路径。路径是服务器定位资源时所需的信息。📙 2.4 参数对很多方案来说，只有简单的主机名和到达对象的路径是不够的。除了服务器正在监听的端口，以及是否能够通过用户名和密码访问资源外，很多协议都还需要更多的信息才能工作。为了向应用程序提供它们所需的输入参数，以便正确地与服务器进行交互，URL中有一个参数组件。这个组件就是URL中的名值对列表，由字符“; ”将其与URL的其余部分（以及各名值对）分隔开来。它们为应用程序提供了访问资源所需的所有附加信息。📒 2.5 查找字符串查找字符串，我们在日常开发中有经常使用。比如说我们从商品列表跳转商品详情时，会将商品ID传递到商品详情页面，然后通过商品ID来获取商品详情。\\🌰举个例子：https://search.bilibili.com/all?keyword=哈利波特&amp;from_source=webtop_search&amp;spm_id_from=333.851 🤸‍我们在哔哩哔哩上搜索哈利波特，按下回车我们会的到上面的URL，这个URL的大部分都与我们见过的其他URL类似。只有问号（?）右边的内容是新出现的。这部分被称为查询（query）组件。URL的查询组件和标识网关资源的URL路径组件一起被发送给网关资源。上个链接中，我们获取到三个参数，keyword、from_source、spm_id_from,按照常规，很多网关都希望查询字符串以一系列“名/值”对的形式出现，名值对之间用字符“&amp;”分隔 📗 2.6 片段为了引用部分资源或资源的一个片段，URL支持使用片段（frag）组件来表示一个资源内部的片段。\\在日常开发中，我们也称之为锚点（anchor） ，它是网页内部的定位点，使用#加上锚点名称，放在网址的最后，比如#anchor。浏览器加载页面以后，会自动滚动到锚点所在的位置。 HTTP服务器通常只处理整个对象，而不是对象的片段，客户端不能将片段传送给服务器。浏览器从服务器获得了整个资源之后，会根据片段来显示你感兴趣的那部分资源。 📚 3 、url编码📙 3.1什么时URL编码为了避开安全字符集表示法带来的限制，人们设计了一种编码机制，用来在URL中表示各种不安全的字符。这种编码机制就是通过一种“转义”表示法来表示不安全字符的，这种转义表示法包含一个百分号（%），后面跟着两个表示字符ASCII码的十六进制数。 📘 3.2 为什么要对URL进行编码通常如果一样东西需要编码，说明这样东西并不适合传输。原因多种多样，如Size过大，包含隐私数据，对于Url来说，之所以要进行编码，是因为以下两种原因： http协议规定请求头与请求行必须是ascii编码，这也就是说你不能在Url中包含任何非ASCII字符，例如中文。这一部分的编解码任务encodeURI、decodeURL就能完成，而事实上浏览器跟web服务器一般都帮我们做了。 url中部分内容包含不安全字符，比如，Url参数字符串中使用key=value键值对这样的形式来传参，键值对之间以&amp;符号分隔，如/s?q=abc&amp;ie=utf-8。如果你的value字符串中包含了=或者&amp;，那么势必会造成接收Url的服务器解析错误，因此必须将引起歧义的&amp;和=符号进行转义，也就是对其进行编码。这一部分可以用encodeURIComponent完成，解码后台服务器自动完成 但是服务器并不会对url进行编码，服务器不可能对错综复杂的编码结果进行处理，所以，需要使用Javascript先对URL编码，然后再向服务器提交，不给浏览器插手的机会。 📗 3.3 js对url进行编码和解码以下三种函数都可以对URL进行编码，区别主要在于不编码的字符不同，具体使用详见各自的使用场景： 📃 1.escape 和 unescape 对除ASCII字母、数字、标点符号 @ * _ + - . / 以外的其他字符进行编码。 📄 2. encodeURI 和 decodeURI 返回编码为有效的统一资源标识符 (URI) 的字符串，不会被编码的字符：! @ # $ &amp; * ( ) = : / ; ? + &apos; encodeURI()是Javascript中真正用来对URL编码的函数。 📑 3. encodeURIComponent 和 decodeURIComponent 对URL的组成部分进行个别编码，而不用于对整个URL进行编码","link":"/2022/02/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3URL/"},{"title":"jwt鉴权机制","text":"1、摘要 JSON Web Token（缩写 JWT）是目前最流行的跨域认证解决方案，本质就是一个字符串书写规范，作用是用来在用户和服务器之间传递安全可靠的信息。 2. JWT是什么根据维基百科的定义，JSON WEB Token（JWT，读作 [/dʒɒt/]），是一种基于JSON的、用于在网络上声明某种主张的令牌（token）。JWT通常由三部分组成: 头信息（header）, 消息体（payload）和签名（signature）。 在目前前后端分离的开发过程中，使用token鉴权机制用于身份验证是最常见的方案，流程如下 假设用户要登录一个APP，用户就需要输入用户名和密码，然后发送给APP的服务器 服务器验证过用户发来的用户名和密码后，就会生成一个token， 服务端返回JWT信息给用户，JWT中 用户发送请求的时候一般会在HTTP头部加上这个Token 服务器收到Token后，对Token进行核实，Token验证通过，且没有过期 用户直接登录，不需要再次输入用户名密码，服务器只需识别头部的Token就可以确认用户身份 这里生成的Token就用的JWT这种数据结构 ✒️Token的携带token可以放在Cookie，Authorization，或者Body里面 什么情况下使用JWT比较适合？3. JWT 的数据结构Token，分成了三部分，头部（Header）、载荷（Payload）、签名（Signature），并以.进行拼接。其中头部和载荷都是以JSON格式存放数据，只是进行了base64 编码(secret 部分是否进行 base64 编码是可选的，header 和 payload 则是必须进行 base64 编码)，由于编码过程是可逆的，如果得知编码方式后，那么整个 jwt 串便是明文了，所以pyaload中一定不能放密码等重要信息。 header头部主要是用来指明签名的算法，避免消息被篡改，jwt 中常用的签名算法是 HS256，常见的还有md5,sha 等，签名算法是不可逆的。声明算法的字段名为alg，同时还有一个typ的字段，默认JWT即可。以下示例中算法为HS256,1{&quot;alg&quot;: HS256, &quot;typ&quot;: &quot;JWT&quot;} pyaload负载主要是用来存放数据，一般可以存放相应用户数据来生成不同的JWT123456789 &quot;payload&quot;: { &quot;data&quot;: [ { &quot;tooltt&quot;: &quot;https://tooltt.com&quot; } ], &quot;iat&quot;: 1650451633, &quot;exp&quot;: 1650556799} JWT规定了7个官方字段，供选用 iss (issuer)：签发人 exp (expiration time)：过期时间 sub (subject)：主题 aud (audience)：受众 nbf (Not Before)：生效时间 iat (Issued At)：签发时间 jti (JWT ID)：编号 除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。 123456{ &quot;sub&quot;: &quot;1234567890&quot;, &quot;name&quot;: &quot;John Doe&quot;, &quot;admin&quot;: true } 由于编码的可逆性，不要把秘密信息放在这个部分。 Signature签名是对头部和负载两个部分进行签名，防止数据篡改。签名里面有个核心就是要定义一个密钥，这个密钥只有服务器能知道，然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。公式如下： 12Signature = HMACSHA256(base64Url(header)+.+base64Url(payload),secretKey) 一旦前面两部分数据被篡改，只要服务器加密用的密钥没有泄露，得到的签名肯定和之前的签名不一致 4. 鉴权机制时如何实现的相关代码已上传github https://github.com/blueskyadd/JWT 基础服务器的搭建首先初始化项目1npm init -y 第二步 安装 express jsonwebtoken依赖1npm i express jsonwebtoken -D 第三步，调整配置文件为了方便我们本地调试代码，安装nodemon nodemon用来监视node.js应用程序中的任何更改并自动重启服务,非常适合用在开发环境中 1npm i nodemon -D 打开pakage.json文件调整scripts，调试命令 然后创建app.js文件 监听3000端口，运行npm run egg启动服务 登录生成JWT借助第三方库jsonwebtoken，通过jsonwebtoken 的 sign 方法生成一个 token 第一个参数指的是 Payload 第二个是秘钥，服务端特有 第三个参数是 option，可以定义 token 过期时间 此处的密钥，使用crypto来生成30位的随机字符串 然后来尝试调用接口，我这里使用的是REST Client 插件，可以直接安装，然后创建一个以http结尾的文件 然后点击send Request 发送请求，请求成功后，可以看到返回的信息 校验token使用jwt.verify（token，secretOrPublicKey，[options，callback]）来验证token的合法性； 同理发送get请求，将登录返回的token, 复制到请求头的authorization字段上，拼接Bearer 空格 token 这是遵守OAuth2.0规则的 然后点击发送，返回认证成功的信息 5. JWT的优缺点优点 json具有通用性，所以可以跨语言组成简单， 字节占用小，便于传输服务端无需保存会话信息， 很容易进行水平扩展一处生成，多处使用， 可以在分布式系统中， 解决单点登录问题可防护CSRF攻击 缺点 payload部分仅仅是进行简单编码，所以只能用于存储逻辑必需的非敏感信息 需要保护好加密密钥，一旦泄露后果不堪设想 为避免token被劫持，最好使用https协议 6. 推荐阅读JWT介绍及其安全性分析","link":"/2022/03/27/jwt%E9%89%B4%E6%9D%83%E6%9C%BA%E5%88%B6/"},{"title":"浏览器渲染流程","text":"由于渲染机制过于复杂，所以渲染模块在执行过程中会被划分为很多子阶段，输入的 HTML 经过这些子阶段，最后输出像素。我们把这样的一个处理流程叫做渲染流水线，其大致流程如下图所示： 🐼按照渲染的时间顺序，流水线可分为如下几个子阶段： 构建 DOM 树 样式计算 布局阶段 分层 绘制 分块 光栅化 合成。 我们可以把渲染流水线当作一个车间流水线，我们只关注输入输出，中间的处理当作黑盒即可；不去关注过程 构建 DOM 树 由于浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM 树。 HTML解析器：接收到HTML字节流时，首先要经过渲染引擎的HTML解析器，将HTML字节流转换成DOM树结构。 构建 DOM 树的输入内容是一个非常简单的 HTML 文件，然后经由 HTML 解析器解析，最终输出树状结构的 DOM。 可以看到，DOM 和 HTML 内容几乎是一样的，但是和 HTML 不同的是，DOM 是保存在内存中树状结构，可以通过 JavaScript 来查询或修改其内容。 样式计算（Recalculate Style）已经生成 DOM 树了，但是 DOM 节点的样式我们依然不知道，要让 DOM 节点拥有正确的样式，这就需要样式计算了。 样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式，这个阶段大体可分为三步来完成。 1. 把 CSS 转换为浏览器能够理解的结构和 HTML 文件一样，浏览器也是无法直接理解这些纯文本的 CSS 样式，所以当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets。 在控制台中输入 document.styleSheets，然后就看到如下图所示的结构： 渲染引擎会把获取到的 CSS 文本全部转换为 styleSheets 结构中的数据，并且该结构同时具备了查询和修改功能，这会为后面的样式操作提供基础。 2. 转换样式表中的属性值，使其标准化 将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。 3. 计算出 DOM 树中每个节点的具体样式样式计算阶段的目的是为了计算出 DOM 节点中每个元素的具体样式，在计算过程中需要遵守 CSS 的继承和层叠两个规则。这个阶段最终输出的内容是每个 DOM 节点的样式，并被保存在 ComputedStyle 的结构内 📚CSS 继承 CSS 继承就是每个 DOM 节点都包含有父节点的样式。 📒层叠 层叠是 CSS 的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法。它在 CSS 处于核心地位，CSS 的全称“层叠样式表”正是强调了这一点 布局阶段因为我们还不知道 DOM 元素的几何位置信息。那么接下来就需要计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做布局。 Chrome 在布局阶段需要完成两个任务：创建布局树和布局计算。 1. 创建布局树 遍历 DOM 树中的所有可见节点，并把这些节点加到布局树中； 而不可见的节点会被布局树忽略掉，因为它的属性包含 dispaly:none，所以这个元素也没有被包进布局树。 2. 布局计算当Webkit创建RenderObject对象之后，每个对象是不知道自己的位置，大小等信息的，WebKit根据盒子模型来计算他的位置，大小等信息，这个过程就是布局计算 布局计算是一个复杂的过程，我简单的可以总结为：界面是由很多很多的框模型组成的，每个框模型是由元素的类型以及display属性决定的。而不同的Box会参与到不同的格式上下文中(Formatting Context)，完成布局的计算。 分层页面是个二维平面，但是层叠上下文能够让 HTML 元素具有三维概念，这些 HTML 元素按照自身属性的优先级分布在垂直于这个二维平面的 z 轴上。 页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-inde 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）。 图层绘制在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制； 渲染引擎实现图层的绘制与之类似，会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表，如下图所示 栅格化（raster）操作绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。 合成和显示一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。 总结 渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。 渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。 创建布局树，并计算元素的布局信息。 对布局树进行分层，并生成分层树。 为每个图层生成绘制列表，并将其提交到合成线程。 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。 合成线程发送绘制图块命令 DrawQuad 给浏览器进程。 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。","link":"/2022/07/24/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/"},{"title":"数据包是如何完整的发送到应用程序","text":"把数据包送达目的主机 数据包要在互联网上进行传输，就要符合网际协议（Internet Protocol，简称 IP）标准。计算机的地址就称为 IP 地址，访问任何网站实际上只是你的计算机向另外一台计算机请求信息。互联网上不同的在线设备都有唯一的地址，相当于我们的身份证号，有且仅有一个。 如果要想把一个数据包从主机 A 发送给主机 B，那么需要携带一下信息： 主机 B 的 IP 地址信息 主机 A 本身的 IP 地址 这些附加的信息会被装进一个叫 IP 头的数据结构里。 把数据包送达应用程序IP 是非常底层的协议，只负责把数据包传送到对方电脑，但是对方电脑并不知道把数据包交给哪个程序。那么就需要基于 IP 之上开发能和应用打交道的协议，比如 UDP（User Datagram Protocol 用户数据包协议），或者TCP（Transmission Control Protocol，传输控制协议。 他们都需要一个头部信息，头部信息中包含了目标端口和本机端口号，不同的是TCP协议的头部信息中还提供了用于排序的序列号，以便接收端通过序号来重排数据包。 TCP协议的特点 TCP 是面向连接的运输层协议。应用程序在使用 TCP 协议之前，必须先建立 TCP 连接。在传送数据完毕后，必须释放已经建立的 TCP 连接 每一条 TCP 连接只能有两个端点，每一条 TCP 连接只能是点对点的(一对一)TCP 提供可靠交付的服务。通过 TCP 连接传送的数据，无差错、不丢失、不重复，并且按序到达- - TCP 提供全双工通信。TCP 允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端都设有发送缓存和接受缓存，用来临时存放双向通信的数据 面向字节流。TCP 中的“流”指的是流入到进程或从进程流出的字节序列 一个完整的 TCP 连接的生命周期包括了“建立连接”“传输数据”和“断开连接”三个阶段。 第一次：客户端给服务端发送一个带有SYN标志的数据包第二次：服务端给客户端发送带有SYN和ACK标志得数据包第三次：客户端给服务端发送带有ACK标志的数据包 UDP协议的特点 UDP是无连接的，即通信时不需要创建连接（发送数据结束时也没有连接可以释放）所以减小了开销和发送数据前的时延； UDP采用最大努力交付，不保证可靠交付，因此主机不需要维护复杂的连接状态； UDP是面向报文的，只在应用层交下来的报文前增加了首部后就向下交付IP层； UDP是无阻塞控制的，即使网络中存在阻塞，也不会影响发送端的发送频率 UDP支持一对一、一对多、多对一、多对多的交互通信 DUP的首部开销小，只有8个字节，它比TCP的20个字节的首部要短。 总结 互联网中的数据是通过数据包来传输的，数据包在传输过程中容易丢失或出错。 IP 负责把数据包送达目的主机。 UDP 负责把数据包送达具体应用。 而 TCP 保证了数据完整地传输，它的连接可分为三个阶段：建立连接、传输数据和断开连接。","link":"/2022/05/26/%E6%95%B0%E6%8D%AE%E5%8C%85%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%8C%E6%95%B4%E7%9A%84%E5%8F%91%E9%80%81%E5%88%B0%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"},{"title":"重定向与负载均衡","text":"1、什么是重定向 重定向技术通常可以用来确定报文是否终结于某个代理，缓存或服务器集群中某台特定的服务器. —— HTTP权威指南 感觉很绕口，举个栗子🌰🙋‍简单理解起来相当于你拿着一个地址从家里出发（浏览器发送请求）去找一个亲戚，到了后发现他已经搬家了，邻居告诉了你一个新的地址（新的请求），此时天已经晚了，你回家休息一晚上（又回到了浏览器），第二天拿着新的地址去找（浏览器再次发送请求），终于找到了。 整个过程，家可以看成浏览器，两个不同的地址可以看成两次不同的request，两个地址都是从家里开始出发，相当于浏览器发送两次不同的请求,先找到旧url，没找到，再回到浏览器去找新url，最终跳转到新的url上，这就是url发生改变的原因。 带入到 HTTP 中，服务器可以通过返回一个重定向响应来进行重定向。这个重定向响应有一个以 3 开头的状态码 ，并且有一个 Location 头字段 表示要重定向到的位置。 2、为什么要重定向由于HTTP应用程序总是要做下列3件事情，所以现代网络中重定向时普遍存在的 可靠的执行HTTP事务 最小化时延 节约网络带宽 出于这些原因，Web内容通常分布在很多地方。这样做是出于可靠性的考虑： 如果一个位置出问题了，还有其他的可用； 如果客户端能去访问较近的资源，就可以更快的收到所请求的内容，以降低响应时间 将目标服务器分散，还可以减少网络拥塞 可以将重定向当作一组有助于找到“最佳”分布式内容的技术。 3、通用的重定向方法http重定向web服务器可以将短的重定向报文发回给客户端，与其他形式相比，http重定向的优点之一就是重定向服务器知道客户端的IP地址，从理论上来讲他可以做出更合理的选择； http重定向的局限 需要原始服务器进行大量处理来判断要重定向到哪条服务器上去。有时，发布重定向所需的处理量几乎与提供页面本身所需的处理量一样。 增加了用户时延，因为访问页面时要进行两次往返 如果重定向服务器出故障，站点就会瘫痪。 DNS重定向DNS重定向，有时称为DNS劫持，是从DNS服务器转移结果的做法。下图中，DNS服务器要决定为www.joes.hardware.com返回4个IP地址中的哪一个； 其中DNS服务器决定要选择使用那个IP，最简单的决策算法就是轮转。DNS轮转使用了DNS主机名解析中的一项特性，在Web服务器集群中平衡负载。 DNS重定向算法： 轮转 负载均衡算法 邻接路由算法 故障屏蔽算法 任播寻址几台服务器使用相同的IP地址。每台服务器都会伪装成一个骨干路由器。其他路由器会将共享的IP地址分组发送给最近的服务器。 任播寻址的局限 需要拥有/配置路由器 有地址冲突的风险，如果路由变化了，与已建立的TCP连接相关的分组会被发送到其他的服务区，可能会使Tcp连接中断 IP/MAC 转发在以太网中，HTTP 报文都是以携带地址的数据分组的形式发送的。每个分组都有一个第四层地址，由源 IP 地址、目的 IP 地址以及 TCP 端口号组成，它是第四层设备所关注的地址。 每个分组还有一个第二层地址，MAC(Media Access Control，媒体访问控制)地址，这是第二层设备(通常是交换机和 Hub)所关注的地址。第二层设备的任务是接收具有特定输入 MAC 地址的分组，然后将其转发到特定的输出 MAC 地址上去。 IP 地址转发在 IP 地址转发中，交换机或其他第四层设备会检测输入分组中的 TCP/IP 地址，并通过修改目的 IP 地址(不是目的 MAC 地址)，对分组进行相应的转发。 与 MAC 转 发相比，这么做的优点是目标服务器不需要位于一跳远的地方；只需要位于交换机的上游就行了，而且通常第三层的端到端因特网路由都会将分组传送到正确的地方。这种类型的转发也被称为 NAT(Network Address Translation，网络地址转换)。","link":"/2022/04/19/%E9%87%8D%E5%AE%9A%E5%90%91%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"title":"浏览器的进程和线程","text":"什么是并行处理在了解进程和线程之前，先来看一下什么是并行处理； 计算机中的并行处理就是同一时刻处理多个任务，比如我们要计算下面这两个表达式的值，并显示出结果12A = 1+2B = 2+3 在编写代码的时候，我们可以把这个过程拆分为三个任务： 任务 1 是计算 A=1+2； 任务 2 是计算 B=2+3； 任务 3 是显示最后计算的结果; 正常情况下，可以使用单线程来处理，也就是说分三步按照顺序分别执行; 如果采用多线程，会怎么样呢？我们只需分“两步走”： 第一步，使用两个个线程同时执行前两个任务； 第二步，再执行第四个显示任务。 通过对比分析，你会发现用单线程执行需要四步，而使用多线程只需要两步。因此，使用并行处理能大大提升性能。 进程 vs 线程 多线程可以并行处理任务，但是线程是不能单独存在的，它是由进程来启动和管理的 在很多地方我们都有看到一句话： 进程是CPU分配资源的最小单位，线程是CPU调度的最小单位。 那么如何理解这句话，如果把进程比作一个工厂，那么线程就像工厂中的员工，工厂与工厂之间相互独立，工厂中的员工相互协作完成任务，每个工厂至少都有一个员工，员工之间共享工厂的仓库。 进程和线程有以下四种关系1. 进程中的任意一线程执行出错，都会导致整个进程的崩溃。所以js（线程）执行报错时导致整个渲染进程停止工作，比如一个工人（线程）在流水线生产产品时由于操作失误，导致机器故障，那就会导致工厂（进程）停产。 也可以模拟以下场景：12A = 1+2B = 20/0 当线程执行到 B = 20/0 时，由于分母为 0，线程会执行出错，这样就会导致整个进程的崩溃，当然另外线程执行的结果也没有了 2. 线程之间共享进程中的数据。如上图所示，工人之间是共享工厂的仓库的，线程之间可以对进程的公共数据进行读写操作。 3. 当一个进程关闭之后，操作系统会回收进程所占用的内存。当一个进程退出时，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。 如果工厂关闭，工厂内的所有资源都会被回收。 4. 进程之间的内容相互隔离。进程隔离是为保护操作系统中进程互不干扰的技术，每一个进程只能访问自己占有的数据，也就避免出现进程 A 写入数据到进程 B 的情况。如果进程之间需要通信，就需要用到进程之间相互通信的机制了。 比如Electron桌面应用中内部得也是chromium的内核，有两个进程，分别是Main主进程和Renderer渲染进程，两者的通信也是需要用到IPC (inter-process communication) 工厂与工厂之间相互独立，资源不共享。","link":"/2022/05/09/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"工具","slug":"工具","link":"/tags/%E5%B7%A5%E5%85%B7/"},{"name":"node","slug":"node","link":"/tags/node/"},{"name":"Element-ui","slug":"Element-ui","link":"/tags/Element-ui/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"移动端","slug":"移动端","link":"/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"Express","slug":"Express","link":"/tags/Express/"},{"name":"HBuilder","slug":"HBuilder","link":"/tags/HBuilder/"},{"name":"mongodb","slug":"mongodb","link":"/tags/mongodb/"},{"name":"express","slug":"express","link":"/tags/express/"},{"name":"ts","slug":"ts","link":"/tags/ts/"},{"name":"微信","slug":"微信","link":"/tags/%E5%BE%AE%E4%BF%A1/"},{"name":"H5","slug":"H5","link":"/tags/H5/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"单元测试","slug":"单元测试","link":"/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"},{"name":"react","slug":"react","link":"/tags/react/"},{"name":"hooks","slug":"hooks","link":"/tags/hooks/"},{"name":"单点登录","slug":"单点登录","link":"/tags/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"},{"name":"Next","slug":"Next","link":"/tags/Next/"},{"name":"http","slug":"http","link":"/tags/http/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"模块化","slug":"模块化","link":"/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"},{"name":"jwt","slug":"jwt","link":"/tags/jwt/"},{"name":"浏览器工作原理","slug":"浏览器工作原理","link":"/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"},{"name":"网络","slug":"网络","link":"/tags/%E7%BD%91%E7%BB%9C/"}],"categories":[{"name":"tags","slug":"tags","link":"/categories/tags/"},{"name":"categories","slug":"categories","link":"/categories/categories/"}]}